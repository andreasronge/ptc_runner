# Multi-Agent Workflows with Context Firewall

```elixir
repo_root = Path.expand("..", __DIR__)

deps =
  if File.exists?(Path.join(repo_root, "mix.exs")) do
    [{:ptc_runner, path: repo_root}, {:llm_client, path: Path.join(repo_root, "llm_client")}]
  else
    [{:ptc_runner, "~> 0.5.0"}]
  end

Mix.install(deps ++ [{:req_llm, "~> 1.0"}, {:kino, "~> 0.14"}], consolidate_protocols: false)
```

## Setup

Add your API key in the Secrets panel (`ss`).

```elixir
api_key = System.get_env("LB_OPENROUTER_API_KEY") || System.get_env("OPENROUTER_API_KEY")
if api_key, do: System.put_env("OPENROUTER_API_KEY", api_key)
if(api_key, do: "API key configured", else: "No API key - add OPENROUTER_API_KEY to secrets")
```

```elixir
model_options =
  if Code.ensure_loaded?(LLMClient) do
    LLMClient.list_models()
    |> Enum.filter(& &1.available)
    |> Enum.map(&{&1.model_id, "#{&1.alias} - #{&1.description}"})
    |> Enum.sort_by(&elem(&1, 1))
  else
    [
      {"openrouter:anthropic/claude-haiku-4.5", "haiku - Claude Haiku 4.5"},
      {"openrouter:google/gemini-2.5-flash", "gemini - Gemini 2.5 Flash"}
    ]
  end

model_input = Kino.Input.select("Model", model_options)
```

```elixir
model = Kino.Input.read(model_input)

my_llm =
  if Code.ensure_loaded?(LLMClient) do
    fn %{system: system, messages: messages} ->
      case LLMClient.generate_text(model, [%{role: :system, content: system} | messages], receive_timeout: 60_000) do
        {:ok, r} -> {:ok, r}
        error -> error
      end
    end
  else
    fn %{system: system, messages: messages} ->
      case ReqLLM.generate_text(model, [%{role: :system, content: system} | messages], receive_timeout: 30_000) do
        {:ok, r} -> {:ok, %{content: ReqLLM.Response.text(r), tokens: ReqLLM.Response.usage(r)}}
        error -> error
      end
    end
  end

"Ready: #{model}"
```

## Context Firewall

Fields prefixed with `_` stay in BEAM memory but are hidden from LLM prompts. This keeps sensitive or large data out of the context window while remaining accessible to tools.

```elixir
alias PtcRunner.SubAgent
alias PtcRunner.SubAgent.Debug

# Data with firewalled field
article = %{
  title: "Quantum Computing Basics",
  keywords: ["quantum", "qubits"],
  _body: "Quantum computers leverage quantum mechanical phenomena like superposition and entanglement. Unlike classical bits that are either 0 or 1, qubits can exist in multiple states simultaneously, enabling parallel computation."
}

# Preview what LLM sees - note _body is hidden
agent = SubAgent.new(
  prompt: "Summarize the article '{{title}}'",
  signature: "(title :string, keywords [:string], _body :string) -> {summary :string}"
)

preview = SubAgent.preview_prompt(agent, context: article)
IO.puts("=== LLM sees this user message ===")
IO.puts(preview.user)
IO.puts("\n=== _body is NOT shown above ===")
```

## Multi-Agent Pipeline

Two agents working together:

1. **Research Agent** - searches and selects relevant articles (returns `_body` without seeing it)
2. **Summarize Agent** - receives article, uses tool to read the firewalled body

```elixir
# Mocked search results
articles = [
  %{id: 1, title: "Quantum Coffee Roasters", keywords: ["quantum", "coffee roasters"], _body: ~s(The Quantum Coffee Roasters launched a new dark blend emphasizing speed, energy, and bold flavor, targeting early-morning commuters and fitness enthusiasts.
)},
  %{id: 2, title: "Qubits Beyond Decoherence", keywords: ["quantum", "qubits"],
    _body: ~s(Researchers at the newly founded Helios Quantum Lab announced an unexpected breakthrough suggesting that qubits can temporarily retain partial information even after decoherence occurs.
The team claims this effect, called “echo-state persistence,” allows a quantum system to reconstruct fragments of its previous computational state without external error correction.
Surprisingly, the phenomenon was observed using room-temperature hardware built from layered carbon lattices rather than superconducting materials.
According to the researchers, this challenges the long-held assumption that decoherence represents a strict, irreversible boundary in quantum computation.
Early simulations indicate the effect could reduce basic error rates by up to 30% in small quantum circuits.
While the findings remain unverified, the announcement has already sparked debate about whether quantum memory is more resilient than previously believed.
)},
  %{id: 3, title: "Questioning Quantum Persistence", keywords: ["quantum", "qubits"],
    _body: ~s(Several quantum physicists have expressed strong skepticism regarding the recent claims made by Helios Quantum Lab, arguing that the reported “echo-state persistence” effect conflicts with well-established models of decoherence. Critics point out that the experiments rely heavily on indirect simulations rather than reproducible physical measurements. Some researchers note that the use of room-temperature carbon lattice hardware introduces uncontrolled noise sources that could easily be misinterpreted as retained quantum information. Others warn that the reported error-rate reductions lack statistical significance and may result from classical post-processing artifacts. According to independent analysts, no known quantum memory model allows partial state reconstruction once decoherence has fully occurred. Until the results are independently replicated, many in the field consider the claims speculative at best.
)}
]

Kino.DataTable.new(Enum.map(articles, &Map.drop(&1, [:_body])), name: "Articles (without _body)")
```

### Step 1: Research Agent

Finds relevant article. The `_body` flows through the return value without the LLM ever seeing it.

```elixir
{_, step1} = SubAgent.run(
  "Remove articles that have keywords that are not related to {{topic}}, such as quatum sport cars",
  signature: "(topic :string, articles [{id :int, title :string, keywords [:string], _body :string}]) -> [{id :int, title :string, keywords [:string], _body :string}]",
  context: %{topic: "quantum computing", articles: articles},
  llm: my_llm,
  debug: true,
  compression: true,
  max_turns: 5
)

IO.puts("=== Research Result ===")
IO.inspect(step1.return, label: "Returned article (includes _body)")
```

```elixir
# Inspect what the LLM actually saw
Debug.print_trace(step1, raw: true)
```

### Step 2: Summarize Agent

Receives the article as context. The `_body` is hidden from the LLM, but accessible via tool.

```elixir
# Pass step1's return as context - _body travels along but stays hidden
{_, step2} = SubAgent.run(
  "Summarize the text '{{body}}' in one sentence",
  context: %{ body: step1.return._body},
  signature: "(body :string) -> {summary :string}",
  llm: my_llm,
  debug: true
)

IO.puts("=== Summary ===")
IO.puts(step2.return.summary)
```

```elixir
# Verify _body was hidden from LLM prompt
Debug.print_trace(step2, raw: false)
```

## Data Flow Visualization

```elixir
IO.puts("""
Pipeline Flow:
==============

[Research Agent]
    |
    | context: %{topic: "quantum computing"}
    | tools: search() -> articles with _body
    | LLM sees: titles, keywords (picks best match)
    | returns: %{title, keywords, _body}
    |          (_body travels through, never seen by LLM)
    v
[Summarize Agent]
    |
    | context: step1.return (includes _body, but hidden)
    | tools: read_content() -> _body via closure
    | LLM sees: title, keywords (NOT _body)
    | LLM calls: read_content() to get text
    | returns: %{summary: "..."}
    v
[Result]

Key: _body stayed in BEAM memory, never in any LLM prompt
""")
```

## Interactive Query

```elixir
topic_input = Kino.Input.text("Topic", default: "quantum physics")
```

```elixir
topic = Kino.Input.read(topic_input)

# Run full pipeline
with {:ok, research} <- SubAgent.run(
       "Find the most relevant article about {{topic}}",
       tools: %{"search" => fn _ -> articles end},
       signature: "(topic :string) -> {id :int, title :string, keywords [:string], _body :string}",
       context: %{topic: topic},
       llm: my_llm
     ),
     {:ok, summary} <- SubAgent.run(
       "Summarize '{{title}}'",
       tools: %{"read_content" => fn _ -> research.return._body end},
       context: research.return,
       signature: "(title :string) -> {summary :string}",
       llm: my_llm
     ) do
  IO.puts("Article: #{research.return.title}")
  IO.puts("Summary: #{summary.return.summary}")
else
  {:error, step} -> IO.puts("Failed: #{step.fail.message}")
end
```

## Learn More

* [SubAgent Concepts](https://hexdocs.pm/ptc_runner/subagent-concepts.html) - Context firewall details
* [SubAgent Patterns](https://hexdocs.pm/ptc_runner/subagent-patterns.html) - Composition patterns
* [LLM Agent Livebook](ptc_runner_llm_agent.livemd) - Basic SubAgent usage
