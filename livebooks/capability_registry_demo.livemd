# Capability Registry & Dynamic Tool Creation

```elixir
Mix.install([
  {:ptc_runner, path: Path.expand("..", __DIR__)},
  {:kino, "~> 0.14"}
])

alias PtcRunner.CapabilityRegistry.{Registry, Linker, Skill, ToolEntry, Discovery, Promotion}
alias PtcRunner.MetaPlanner
alias PtcRunner.PlanRunner
```

## Introduction

The **Capability Registry** is a central repository for:

* **Base Tools**: Raw Elixir functions documented with signatures.
* **Composed Tools**: Reusable PTC-Lisp programs smithed from common patterns.
* **Skills**: Expert advice and system prompt fragments that improve agent performance for specific tasks.

This Livebook demonstrates how to use the registry to provide a "Context Economy"—where agents only see the tools and expertise they actually need—and how to dynamically grow the registry.

## Setup

First, let's create a registry and a mock LLM for our experiments.

````elixir
registry = Registry.new()

# Track LLM calls for multi-turn handling
call_count = Agent.start_link(fn -> 0 end) |> elem(1)

# A mock LLM that handles:
# 1. MetaPlanner (JSON mode) - returns execution plan
# 2. SubAgent with tools (PTC-Lisp mode) - multi-turn: call tool, then return result
# 3. SubAgent in must-return mode (no tools) - return static result
# 4. Synthesis gate (JSON mode) - return summary
mock_llm = fn input ->
  count = Agent.get_and_update(call_count, fn n -> {n, n + 1} end)
  system = Map.get(input, :system, "")
  is_json_mode = Map.get(input, :output) == :json
  tool_names = Map.get(input, :tool_names, [])
  has_tools = length(tool_names) > 0

  cond do
    # MetaPlanner - return JSON plan
    String.contains?(system, "workflow architect") ->
      {:ok, ~S|{
        "tasks": [
          {"id": "search", "agent": "shopper", "input": "Search for electronics", "signature": "{items [{name :string, price :float}]}"},
          {"id": "summarize", "type": "synthesis_gate", "input": "Summarize top 2 items", "depends_on": ["search"], "signature": "{summary :string}"}
        ],
        "agents": {
          "shopper": {"prompt": "You search for products.", "tools": ["search_catalog"]}
        }
      }|}

    # PTC-Lisp with tools - first call executes tool, second returns result
    has_tools and count == 1 ->
      {:ok, ~s|```clojure\n(tool/search_catalog {:query "electronics"})\n```|}

    has_tools ->
      {:ok, ~s|```clojure\n(return {:items (tool/search_catalog {:query "electronics"})})\n```|}

    # Must-return mode (tool_names=[] but still PTC-Lisp task)
    not is_json_mode and tool_names == [] ->
      {:ok, ~s|```clojure\n(return {:items [{:name "Phone" :price 699.0} {:name "Laptop" :price 1299.0}]})\n```|}

    # JSON mode (synthesis gate)
    is_json_mode ->
      {:ok, ~S|{"summary": "Top items: Phone ($699) and Laptop ($1299)"}|}

    true ->
      {:ok, "(return nil)"}
  end
end
````

## 1. Registering Base Tools

Base tools are the building blocks. They are Elixir functions with metadata.

```elixir
search_fn = fn %{query: _q} -> 
  [%{name: "Phone", price: 699.0}, %{name: "Laptop", price: 1299.0}]
end

registry = registry
  |> Registry.register_base_tool(
    "search_catalog",
    search_fn,
    signature: "(query :string) -> [{name :string, price :float}]",
    description: "Search the product catalog by keyword.",
    tags: ["shopping", "search", "products"]
  )

Kino.Tree.new(registry.tools["search_catalog"])
```

## 2. Context-Aware Discovery

The registry can find tools based on tags and descriptions. This allows the Meta Planner to "discover" what it needs without knowing the full toolset upfront.

```elixir
results = Discovery.search(registry, "Find some gadgets", context_tags: ["shopping"])
Kino.DataTable.new(results)
```

## 3. Dynamic Tool Creation (Composed Tools)

Composed tools are programs written in PTC-Lisp that use other tools. They can be dynamically "smithed" and added to the registry.

Imagine an agent discovers that it frequently needs to "Search and Filter by Price". It can create a composed tool for this.

```elixir
composed_code = "(defn search-and-filter [q max-p] 
  (filter (fn [i] (<= (get i :price) max-p)) 
          (tool/search_catalog {:query q})))"

registry = Registry.register_composed_tool(
  registry,
  "budget_search",
  composed_code,
  signature: "(query :string, max_price :float) -> [{name :string, price :float}]",
  description: "Search products and filter those under a specific budget.",
  tags: ["shopping", "budget"],
  dependencies: ["search_catalog"]
)

Kino.Tree.new(registry.tools["budget_search"])
```

## 4. Skills (Expert Knowledge)

Skills provide system prompt fragments. The **Linker** automatically injects them into the agent's prompt if the mission context or the selected tools match the skill's interests.

```elixir
shopping_skill = Skill.new(
  "shopper_tips",
  "Shopping Expertise",
  "Always look for the best price-to-performance ratio. For electronics, mention the warranty.",
  tags: ["shopping"]
)

registry = Registry.register_skill(registry, shopping_skill)
```

## 5. Linking: The Context Economy in Action

When we start a mission, the `Linker` gathers only the required tools and skills. This keeps the prompt clean and reduces "distraction" for the LLM.

```elixir
# Requesting 'budget_search' with context 'shopping'
{:ok, linked} = Linker.link(registry, ["budget_search"], context_tags: ["shopping"])

# Notice how:
# 1. Base tools (search_catalog) are included as dependencies.
# 2. Composed tools are converted to a Lisp prelude.
# 3. The shopping skill is automatically included.

IO.puts("--- Skill Prompt ---\n#{linked.skill_prompt}\n")
IO.puts("--- Lisp Prelude ---\n#{linked.lisp_prelude}\n")
```

## 6. Full Execution with Meta Planner

Now let's see how all this comes together. The `PlanRunner` uses the `registry` option to resolve everything on the fly.

```elixir
# 1. Generate a plan (MetaPlanner)
{:ok, plan} = MetaPlanner.plan("Search for products in the electronics category", 
  llm: mock_llm,
  available_tools: %{"search_catalog" => "Search products"}
)

# 2. Execute the plan (PlanRunner)
# We pass the registry here!
{:ok, results} = PlanRunner.execute(plan,
  llm: mock_llm,
  registry: registry,
  context_tags: ["shopping"]
)

# Kino.Tree.new(plan)
Kino.Tree.new(results)
```

## 7. Learning from Usage (Promotion)

The registry can track patterns. If a specific plan structure is used successfully multiple times, it can be flagged for "Promotion" into a permanent tool or skill.

```elixir
# Track a success
registry = Promotion.track_pattern(registry, plan, :success, mission: "Search products")

# Check if anything is ready for promotion (using a low threshold for the demo)
candidates = Promotion.check_promotion_threshold(registry, threshold: 1)

case candidates do
  [hash | _] ->
    candidate = Promotion.get_candidate(registry, hash)
    IO.puts("Found candidate pattern for promotion!")
    Kino.Tree.new(candidate)
  [] ->
    IO.puts("No candidates yet.")
end
```
