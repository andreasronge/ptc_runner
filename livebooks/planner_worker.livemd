# Planner-Worker-Reviewer: Delegating Research with Quality Gates

## Setup

```elixir
repo_root = Path.expand("..", __DIR__)

deps =
  if File.exists?(Path.join(repo_root, "mix.exs")) do
    [{:ptc_runner, path: repo_root}, {:llm_client, path: Path.join(repo_root, "llm_client")}]
  else
    [{:ptc_runner, "~> 0.7.0"}]
  end

Mix.install(deps ++ [{:req_llm, "~> 1.0"}, {:kino, "~> 0.14"}], consolidate_protocols: false)
```

```elixir
local_path = Path.join(__DIR__, "llm_setup.exs")

if File.exists?(local_path) do
  Code.require_file(local_path)
else
  %{body: code} = Req.get!("https://raw.githubusercontent.com/andreasronge/ptc_runner/main/livebooks/llm_setup.exs")
  Code.eval_string(code)
end

setup = LLMSetup.setup()
```

```elixir
setup = LLMSetup.choose_provider(setup)
```

```elixir
my_llm = LLMSetup.choose_model(setup)
```

## The `fetch_page` Tool

```elixir
# Returns status: "ok" on success, "error" on failure (404, timeout, etc.)
# This way the LLM can branch on status instead of the whole turn failing.
fetch_page = fn %{"url" => url} ->
  case Req.get(url, redirect: true, max_redirects: 3, receive_timeout: 15_000) do
    {:ok, %{status: 200, body: body}} when is_binary(body) ->
      text =
        body
        |> String.replace(~r/<!--.*?-->/s, "")
        |> String.replace(~r/<script[^>]*>.*?<\/script>/s, "")
        |> String.replace(~r/<style[^>]*>.*?<\/style>/s, "")
        |> String.replace(~r/<nav[^>]*>.*?<\/nav>/s, "")
        |> String.replace(~r/<header[^>]*>.*?<\/header>/s, "")
        |> String.replace(~r/<footer[^>]*>.*?<\/footer>/s, "")
        |> String.replace(~r/<(br|\/p|\/div|\/li|\/h\d|\/tr|\/td|\/dt|\/dd)[^>]*>/i, "\n")
        |> String.replace(~r/<[^>]+>/, " ")
        |> String.replace(~r/&\w+;/, " ")
        |> String.replace(~r/[ \t]+/, " ")
        |> String.replace(~r/\n[ \t]*/, "\n")
        |> String.replace(~r/\n{3,}/, "\n\n")
        |> String.trim()
        |> String.slice(0, 6000)

      %{status: "ok", text: text}

    {:ok, %{status: status}} ->
      %{status: "error", text: "HTTP #{status}"}

    {:error, reason} ->
      %{status: "error", text: "Request failed: #{inspect(reason)}"}
  end
end

fetch_page.(%{"url" => "https://elixir-lang.org"}) |> Map.update!(:text, &String.slice(&1, 0, 200))
```

## Phase 1: Generate the Plan

```elixir
alias PtcRunner.SubAgent

planner = SubAgent.new(
  prompt: """
  Research question: {{question}}

  You have access to a `fetch_page` tool that retrieves web page text, plus
  `(tool/grep {:pattern p :text t})` and `(tool/grep-n {:pattern p :text t})` for searching text.

  Plan the steps needed to answer this question. Return exactly 2 steps:
  one per research topic. Do NOT include a compilation/synthesis step —
  the orchestrator will build the final answer itself.
  """,
  signature: "(question :string) -> {steps [:string]}",
  max_turns: 1,
  retry_turns: 1,
  output: :text
)

question =
  "What are the latest stable versions of Elixir and Erlang/OTP, and what are the key new features in each?"

{:ok, plan_step} = SubAgent.run(planner, llm: my_llm, context: %{question: question})

plan = plan_step.return["steps"]
IO.puts("=== Generated Plan ===")
Enum.with_index(plan, 1) |> Enum.each(fn {step, i} -> IO.puts("  #{i}. #{step}") end)

plan
```

## Phase 2: The Three-Role Architecture

Three agents with distinct roles:

* **Worker** — fetches pages, extracts data. Multi-turn, has tools.
* **Reviewer** — judges worker output against criteria. Single-shot JSON, no tools.
* **Planner** — orchestrates worker→reviewer chains. Builds the final answer itself.

The planner writes PTC-Lisp programs that wire worker and reviewer together.
It defines a `do-step` helper that dispatches to the worker, reviews the result,
and reports progress. The planner handles retries at the orchestration level.

```elixir
# Worker: multi-turn research agent for one focused task
worker = SubAgent.new(
  name: "worker",
  prompt: """
  {{task}}

  ## Rules
  - You MUST call `fetch_page` at least once. Never return the task description as your result.
  - Your return map must contain data extracted from web pages, not the task text.
  - Use `fetch_page` to retrieve web pages. It returns `{status :string, text :string}`.
    Check `(:status result)` — `"ok"` means success, `"error"` means failure (404, timeout, etc.).
    On error, try an alternative URL instead of retrying the same one.
  - For GitHub files, use raw URLs: `https://raw.githubusercontent.com/OWNER/REPO/REF/PATH`
  - Use `(tool/grep {:pattern p :text t})` or `(tool/grep-n {:pattern p :text t})` to search text.
    These are tool calls with named arguments, NOT shell commands.
  - Return a map with your findings as soon as you have useful data.
    Partial results are better than no results.
  """,
  description: "Research worker: fetches web pages and extracts information for a specific task",
  signature: "(task :string) -> :map",
  builtin_tools: [:grep, :"grep-n"],
  tools: %{
    "fetch_page" =>
      {fetch_page,
       signature: "(url :string) -> {status :string, text :string}",
       description:
         "Fetch a web page and return its text content. status is \"ok\" on success or \"error\" on failure (404, timeout, etc.). For GitHub files, use raw.githubusercontent.com URLs.",
       cache: true}
  },
  max_turns: 3,
  retry_turns: 1,
  timeout: 30_000
)

# Reviewer: single-shot judge, returns structured verdict
reviewer = SubAgent.new(
  name: "reviewer",
  prompt: """
  You are a quality reviewer. Evaluate whether the research result
  satisfies the acceptance criteria.

  ## Step
  {{step}}

  ## Acceptance Criteria
  {{criteria}}

  ## Result to Review
  {{result}}

  Be pragmatic:
  - Approve if the result contains a version number and at least some feature information.
  - Only reject if the result is completely empty or contains no relevant data at all.
  - A version number alone is sufficient — features are nice-to-have.
  - Partial results with real data should be approved with notes about gaps.
  """,
  description: "Reviews research results against acceptance criteria",
  signature: "(step :string, criteria :string, result :string) -> {approved :bool, summary :string, feedback :string}",
  max_turns: 1,
  retry_turns: 2,
  output: :text
)

# Planner: orchestrates worker→reviewer, reports progress, builds final answer
# The `plan:` option injects a Progress checklist into the user message (requires journaling).
# Each step starts unchecked; calling `(step-done "id" "summary")` checks it off.
# The updated checklist is re-rendered in the feedback after each turn so the LLM
# can see what's done and what remains.
planner_executor = SubAgent.new(
  name: "planner",
  prompt: """
  Answer this research question: {{question}}

  ## Your Role
  You are a planner-orchestrator. You delegate research to `research_worker`
  and verify results with `reviewer`. You never fetch pages yourself.

  ## The `do-step` Pattern
  Define a helper that dispatches to worker and reviewer. Use `(pr-str map)`
  to format the result as readable key-value pairs before sending to the reviewer:

  (defn do-step [id task criteria]
    (let [result (tool/research_worker {:task task})
          result_str (pr-str result)
          review (tool/reviewer {:step task :criteria criteria :result result_str})]
      (if (:approved review)
        (do (step-done id (:summary review)) result)
        (do (step-done id (str "REJECTED: " (:feedback review))) nil))))

  ## Rules
  - Always define `do-step` first, then use it for each plan step.
  - Use the step IDs from the Progress checklist.
  - Batch independent steps in the same turn (e.g. steps 1 and 2 together).
  - Maximum 1 retry per step. If a step fails twice, skip it and move on.
  - After all research steps are done, build the final answer map yourself
    from the collected data. Do NOT delegate synthesis to the worker.
    Extract fields with keywords: `(:version data)`, `(:features data)`.
  - Write specific but achievable acceptance criteria.
    Good: "Must include a version number"
    Bad: "Must include version, release date, 5+ features with descriptions"
  - If a step returns nil (rejected), you may retry once with a refined task.
    After that, skip and work with what you have.
  - Only `(return ...)` when all steps are done or skipped.
    Build the return map yourself:
    (return {:elixir elixir-data :erlang erlang-data})
  """,
  signature: "(question :string) -> :map",
  plan: plan,
  journaling: true,
  tools: %{
    "research_worker" => SubAgent.as_tool(worker, cache: true),
    "reviewer" => SubAgent.as_tool(reviewer, cache: true)
  },
  max_turns: 8,
  max_depth: 2,
  timeout: 180_000
)

{result, step} =
  SubAgent.run(planner_executor,
    llm: my_llm,
    context: %{question: question},
    journal: %{},
    max_heap: 2_500_000,
    debug: true
  )

SubAgent.Debug.print_trace(step, raw: true)

{result, step.return}
```

```elixir
# Render interactive trace tree (agent hierarchy with expandable details)
PtcRunner.Kino.TraceTree.new(step)
```

```elixir
if step.summaries && map_size(step.summaries) > 0 do
  IO.puts("=== Summaries (#{map_size(step.summaries)} entries) ===\n")

  Enum.each(step.summaries, fn {id, summary} ->
    IO.puts("  [done] #{id}: #{summary}")
  end)
else
  IO.puts("(no summaries)")
end

IO.puts("")

if step.journal && map_size(step.journal) > 0 do
  IO.puts("=== Journal (#{map_size(step.journal)} entries) ===\n")

  Enum.each(step.journal, fn {id, value} ->
    val_str = inspect(value, limit: 5, printable_limit: 120)
    IO.puts("  [cached] #{id}: #{String.slice(val_str, 0, 120)}")
  end)
else
  IO.puts("(no journal entries)")
end
```

This livebook demonstrates the **planner-worker-reviewer** pattern — a three-role hierarchy:

1. **Planner** (JSON, single-shot) generates a step list
2. **Planner-executor** (multi-turn, PTC-Lisp) orchestrates the workflow
3. **Worker** (multi-turn, PTC-Lisp) handles one focused research task
4. **Reviewer** (single-shot, JSON) judges worker output against criteria

### The `do-step` Pattern

The key insight: the planner never inspects raw worker output. Instead, it writes
a `do-step` helper that chains worker→reviewer mechanically:

```
worker produces result → format-result → reviewer judges against criteria → approved? → step-done
                                                                          → rejected? → planner retries (max 1) or skips
```

This eliminates the problem where the planner marks steps done despite poor results.
The reviewer is a dedicated judge with explicit acceptance criteria.

### Three Roles, Clear Responsibilities

| Role     | Mode                | Sees                               | Decides                                          |
| -------- | ------------------- | ---------------------------------- | ------------------------------------------------ |
| Planner  | Multi-turn PTC-Lisp | Reviewer verdicts (via checklist)  | What to research, acceptance criteria, data flow |
| Worker   | Multi-turn PTC-Lisp | One focused task prompt            | How to fetch and extract data                    |
| Reviewer | Single-shot JSON    | Step + criteria + formatted result | Whether result is sufficient                     |

### Key Design Decisions

* **No synthesis step**: The planner builds the final answer map itself from collected data,
  rather than delegating to the worker. This avoids the worker echoing back task text.
* **Formatted results for reviewer**: `(pr-str map)` converts maps to readable key-value
  strings instead of passing opaque `%{...}` via `(str map)`.
* **Max 1 retry per step**: Prevents the planner from burning all turns retrying one step.
* **Pragmatic reviewer**: Approves partial results with real data; only rejects empty/irrelevant output.

### Comparison with Other Patterns

|                          | Plan-and-Execute | Planner-Worker | Planner-Worker-Reviewer          |
| ------------------------ | ---------------- | -------------- | -------------------------------- |
| Verification             | Self-assessment  | Planner judges | Dedicated reviewer               |
| Planner sees raw results | Yes              | Yes            | No — only verdicts             |
| Retry on poor results    | Manual           | Manual         | Planner-controlled via `do-step` |
| LLM calls per step       | 1                | 2              | 2-4 (worker + reviewer)          |

### When to Use This Pattern

* **Quality matters more than speed** — the reviewer catches vague or incomplete results
* **Acceptance criteria are definable** — each step has clear success conditions
* **Results vary in quality** — web scraping, API calls, data extraction
* **Audit trail needed** — reviewer verdicts are structured, loggable data

### Batching Independent Steps

The planner can dispatch independent steps in the same turn:

```clojure
(def elixir-data (do-step "1" "Find Elixir version..." "Must include a version number"))
(def erlang-data (do-step "2" "Find Erlang version..." "Must include a version number"))
```

Steps 1 and 2 run sequentially within one planner turn (PTC-Lisp is single-threaded),
but the planner doesn't need an extra turn to see their results — the reviewer
handles verification inline.

After all steps complete, the planner builds the final answer itself:

```clojure
(return {:elixir elixir-data :erlang erlang-data})
```

### Limitations

* **More LLM calls** — 2-4 per step (worker turns + reviewer). The reviewer is cheap
  (single-shot JSON) but it adds up.

* **Prompt complexity** — the planner must write the `do-step` helper correctly.
  Using `pr-str` eliminates the need for a custom `format-result` helper,
  but the overall pattern still requires careful prompting.

* **`step-done` in `defn`** — works because `defn` calls run in the same process.
  Would NOT work if `do-step` were called inside `pmap`/`pcalls`.

* [Plan & Execute Livebook](plan_and_execute.livemd) — Single-agent plan-and-execute pattern

* [Navigator Pattern Guide](https://hexdocs.pm/ptc_runner/subagent-navigator.html) — Journaled tasks and planning design space

* [Composition Patterns](https://hexdocs.pm/ptc_runner/subagent-patterns.html) — Dynamic agent creation and orchestration
