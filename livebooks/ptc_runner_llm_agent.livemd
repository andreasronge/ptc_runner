# PTC-Lisp SubAgent

```elixir
# For local dev: run `mix deps.get` in the project root first
repo_root = Path.expand("..", __DIR__)

deps =
  if File.exists?(Path.join(repo_root, "mix.exs")) do
    # Local dev includes LLMClient for model presets
    [
      {:ptc_runner, path: repo_root},
      {:llm_client, path: Path.join(repo_root, "llm_client")}
    ]
  else
    [{:ptc_runner, "~> 0.3.3"}]
  end

Mix.install(deps ++ [{:req_llm, "~> 1.0"}, {:kino, "~> 0.14"}], consolidate_protocols: false)
```

## Introduction

SubAgents are LLM-powered agents that write PTC-Lisp programs to compute answers. Instead of the LLM answering directly, it generates code that runs in a sandboxed interpreter - giving you deterministic, verifiable results.

## Configuration

For cloud models, add your API key in the Secrets panel (left sidebar, `ss`). Local models (Ollama) work without a key.

```elixir
# Try Livebook secret first, fall back to environment
api_key =
  case System.get_env("LB_OPENROUTER_API_KEY") do
    nil -> System.get_env("OPENROUTER_API_KEY")
    key -> key
  end

if api_key, do: System.put_env("OPENROUTER_API_KEY", api_key)

if api_key do
  "OpenRouter API key configured"
else
  "No API key - local models (Ollama) only"
end
```

```elixir
# Build model options from LLMClient if available
model_options =
  if Code.ensure_loaded?(LLMClient) do
    LLMClient.list_models()
    |> Enum.filter(fn m -> m.available end)
    |> Enum.map(fn m -> {m.model_id, "#{m.alias} - #{m.description}"} end)
    |> Enum.sort_by(fn {_, label} -> label end)
  else
    # Fallback for public mode
    [
      {"openrouter:anthropic/claude-haiku-4.5", "haiku - Claude Haiku 4.5"},
      {"openrouter:google/gemini-2.5-flash", "gemini - Gemini 2.5 Flash"},
      {"openrouter:deepseek/deepseek-chat-v3-0324", "deepseek - DeepSeek Chat V3"},
      {"openrouter:mistralai/devstral-2512:free", "devstral - Devstral (free)"}
    ]
  end

IO.puts("Available models: #{length(model_options)}")
model_input = Kino.Input.select("Model", model_options)
```

```elixir
model = Kino.Input.read(model_input)

# Create LLM callback - uses LLMClient if available (supports Ollama), else ReqLLM
my_llm =
  if Code.ensure_loaded?(LLMClient) do
    fn %{system: system, messages: messages} ->
      full_messages = [%{role: :system, content: system} | messages]

      case LLMClient.generate_text(model, full_messages, receive_timeout: 60_000) do
        {:ok, response} -> {:ok, response.content}
        {:error, reason} -> {:error, reason}
      end
    end
  else
    fn %{system: system, messages: messages} ->
      full_messages = [%{role: :system, content: system} | messages]

      case ReqLLM.generate_text(model, full_messages, receive_timeout: 30_000) do
        {:ok, response} -> {:ok, ReqLLM.Response.text(response)}
        {:error, reason} -> {:error, reason}
      end
    end
  end

IO.puts("LLM ready: #{model}")
```

## Basic Example

The simplest SubAgent - no tools, no validation:

```elixir
alias PtcRunner.SubAgent.Debug

{:ok, step} = PtcRunner.SubAgent.run(
  "What is the sum of the first 5 prime numbers?",
  llm: my_llm,
  debug: true
)

# Show the program the LLM generated

#Debug.print_trace(step)

IO.puts("\nResult: #{step.return}")
```

The agent doesn't answer from memory - it writes a program like `(+ 2 3 5 7 11)` and executes it. The result is computed, not recalled.

## With Type Signatures

Signatures validate the output structure. Use `context` to pass data and `max_turns: 1` for single-shot (no tools needed):

```elixir
{:ok, step} = PtcRunner.SubAgent.run(
  "Classify this review as positive/negative/neutral with confidence 0.0-1.0: {{review}}",
  context: %{review: "Great product, fast shipping! Would definitely buy again."},
  signature: "(review :string) -> {sentiment :string, confidence :float}",
  max_turns: 1,
  llm: my_llm,
  debug: true
)

Debug.print_trace(step)
IO.puts("\nSentiment: #{step.return.sentiment}, Confidence: #{step.return.confidence}")
```

## With Tools

Tools let the agent call functions to gather data:

```elixir
expenses = [
  %{"id" => 1, "category" => "travel", "amount" => 450.00, "vendor" => "Airlines Inc"},
  %{"id" => 2, "category" => "food", "amount" => 32.50, "vendor" => "Cafe Luna"},
  %{"id" => 3, "category" => "travel", "amount" => 189.00, "vendor" => "Hotel Central"},
  %{"id" => 4, "category" => "office", "amount" => 299.99, "vendor" => "Tech Store"},
  %{"id" => 5, "category" => "food", "amount" => 28.00, "vendor" => "Deli Express"}
]

tools = %{
  "list-expenses" => {fn _args -> expenses end,
    signature: "() -> [{id :int, category :string, amount :float, vendor :string}]",
    description: "Returns all expense records"
  }
}

{:ok, step} = PtcRunner.SubAgent.run(
  "What is the total travel expense?",
  tools: tools,
  signature: "{total :float}",
  llm: my_llm
)

step.return
```

## Debug: Viewing the Trace

Enable `debug: true` to capture full trace data. Here's a query with tools:

```elixir
{:ok, step} = PtcRunner.SubAgent.run(
  "What is the average expense amount?",
  tools: tools,
  signature: "{average :float}",
  llm: my_llm,
  debug: true
)

# Print execution trace
Debug.print_trace(step)

step.return
```

Show full LLM messages with `messages: true`:

```elixir
Debug.print_trace(step, messages: true)
```

## Interactive Query

Try your own questions:

```elixir
question_input = Kino.Input.textarea("Your question",
  default: "Show spending by category with count and total for each"
)
```

```elixir
question = Kino.Input.read(question_input)

case PtcRunner.SubAgent.run(question, tools: tools, llm: my_llm, debug: true) do
  {:ok, step} ->
    Debug.print_trace(step)
    IO.puts("\nResult:")
    IO.inspect(step.return, pretty: true)

  {:error, step} ->
    IO.puts("Failed: #{step.fail.message}")
end
```

## Error Handling

When things go wrong, check `step.fail`:

```elixir
# Force an error with impossible signature
case PtcRunner.SubAgent.run(
  "Return the number 42",
  signature: "{impossible_field :unicorn}",  # invalid type
  llm: my_llm,
  max_turns: 2
) do
  {:ok, step} ->
    IO.puts("Success: #{inspect(step.return)}")

  {:error, step} ->
    IO.puts("Failed!")
    IO.puts("Reason: #{step.fail.reason}")
    IO.puts("Message: #{step.fail.message}")
end
```

## Learn More

* [Playground Livebook](ptc_runner_playground.livemd) - PTC-Lisp basics without LLM
* [SubAgent Getting Started](https://hexdocs.pm/ptc_runner/subagent-getting-started.html) - Full guide
* [PTC-Lisp Specification](https://hexdocs.pm/ptc_runner/ptc-lisp-specification.html) - Language reference

<!-- livebook:{"offset":6613,"stamp":{"token":"XCP.6gZ0V_cpTNLLLN7bsCIJUrjkGO5iKIdLCSxY08xBufZ6lKXSAvSJ4ZmoNC913mlhbPyrLiBZ5z8qi2SEFAHTAMsr5lPGmNlYArQR7YnFqTFOOopzG9l1qiyT565v","version":2}} -->
