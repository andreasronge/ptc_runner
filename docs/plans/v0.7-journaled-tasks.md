# Plan: v0.7 Journaled Task System (The Navigator)

## 1. Problem Statement

Current `SubAgent` execution is ephemeral. This leads to three primary issues in production workflows:

1.  **Execution Ambiguity (Idempotency)**: If an agent run retries or crashes mid-way, tools with side effects (emails, API calls) may be executed multiple times.
2.  **State Fragility**: Long-running workflows (e.g., "Wait for a phone call") require the developer to either keep a process alive or manually track what has been done.
3.  **Opaque Progress**: It is difficult to see exactly which steps of a complex "plan" have been completed and which are pending.

## 2. Proposed Architecture: The Navigator

We move from an **"Agent-as-Process"** model to an **"Agent-as-Navigator"** model. 

The **Journal** is a map passed via `context` that records task results. The **Navigator** is a stateless agent that "re-navigates" its mission by checking the Journal to see what is already done.

- **ptc_runner stays a pure library**: No DB dependency, no Oban dependency, no shared state.
- **Developer owns persistence**: The app passes the journal in via `context` and persists it from the `Step` result.
- **Progressive Enhancement**: If no `journal` is provided in `context`, `(task)` executes `expr` normally and returns its result, but does not cache. A trace warning is emitted so the developer knows idempotency is inactive.

## 3. The `(task id expr)` Lifecycle

When the Navigator encounters a `(task id expr)` block:

1.  **ID Validation**: `id` must be a string literal. Unquoted symbols (e.g., `(task order_1 ...)`) are rejected by the analyzer as a static error.
2.  **Lookahead**: Check `context.journal` for `id`.
    - If key exists, return the cached value immediately. Skip `expr`.
    - If key is missing, proceed to execution.
3.  **Execution**: Evaluate `expr`.
    - **Commit Boundary**: If `expr` returns a value, it is committed to the journal.
    - **Fail Propagation**: If `expr` calls `(fail ...)` or crashes, it is NOT committed to the journal, and the failure propagates up to halt execution — same as `(fail)` anywhere else. `(task)` is a caching wrapper, not an error boundary.
4.  **Transparent Semantics**: The `(task)` form evaluates to the result of `expr`. Metadata is managed internally.
5.  **Result Persistence**: The updated journal is returned in `Step.journal`. Keys are always strings.

### Journal Storage

The `journal` is a dedicated field on the `Context` struct — not nested inside the `ctx` user-data map. This separates engine state from user data:

```elixir
# journal is a top-level Context field, like memory and tools
context = %Context{ctx: %{user_id: 1}, journal: %{}, tools: [...]}
```

**Serialization note:** The engine stores whatever `expr` returns as-is. If the developer round-trips the journal through JSON (e.g., storing in PostgreSQL), values must be JSON-safe. This is the developer's responsibility — the engine imposes no serialization constraints.

## 4. The Mission Log (LLM Perception)

To help the LLM understand its progress, the engine automatically injects a "Mission Log" into the system prompt if a journal is present. 

**Rules:**
- **Completed Only**: Only shows tasks that have successfully finished.
- **Truncation**: Results are truncated to ~200 characters to protect the context window.
- **Data Propagation**: The LLM uses the results shown in the log as inputs for subsequent tasks.

**Example Rendering:**
```text
## Mission Log (Completed Tasks)
- [✓] dial_bob: "call_123"
- [✓] check_auth: true
```

## 5. Design Principles & Best Practices

### Semantic IDs
Task IDs should be **Semantic** (Intent + Data). 
- *Bad*: `(task "step_1" ...)`
- *Good*: `(task "charge_invoice_123" ...)`
This prevents stale cache hits if an agent re-plans and re-orders its work.

### Implicit Re-planning
There is no engine-level "Plan Object." Re-planning happens on every re-invocation:
- The LLM sees the Mission Log and the current instructions.
- It is free to branch or pivot. If a previous task produced an unexpected result, the LLM simply generates different code for the current turn.
- Uncompleted tasks (from aborted plans) never enter the journal and are simply ignored by the engine.

## 6. Implementation Scope (v0.7)

### Deliverables
- **The Primitive**: `(task id expr)` form in PTC-Lisp.
- **The Journal Field**: `Step.journal` field in the result struct.
- **The Mission Log Generator**: Automatic prompt formatting for the LLM.
- **The Navigator Guide**: Documentation explaining the "Re-run with context" pattern.

### Non-Goals (Deferred)
- **Yielding**: Use `(return {:status :waiting})` instead.
- **Concurrency/Locking**: If using `pmap`, developers manage their own tool-level locking.
- **Database Adapters**: Journal is a pure Map; persistence is the app's responsibility.

## 7. Workflow Example (v0.7)

The application handles the "Wait for Callback" or "Schedule" logic via external tools (e.g. Oban).

### Step 1: Initial Run
**Prompt:** "Charge 100 on the card and then ship the item..."
**LLM Executes:** `(task "order_1" (tool/charge_card 100))`

**Elixir Response:**
```elixir
{:ok, step} = SubAgent.run(agent, context: %{journal: %{}})
# step.journal = %{"order_1" => "tx_123"}
MyRepo.save_journal(wf_id, step.journal)
```

### Step 2: Re-invocation
The application fetches the journal and re-invokes after an external event (e.g. human approval).

**Elixir Code:**
```elixir
journal = MyRepo.get_journal(wf_id)
{:ok, step} = SubAgent.run(agent, context: %{journal: journal})
```

**LLM Navigation:**
1. The LLM sees `- [✓] order_1: "tx_123"` in the **Mission Log**.
2. Its instructions say "Charge, then Ship." 
3. It takes the text `"tx_123"` from the log and executes:
   `(task "ship_1" (tool/ship_item "tx_123"))`

For a more complete example with human-in-the-loop approval, async waiting, and branching, see [Wire Transfer Example](../../examples/wire_transfer/README.md).
