# PTC-Lisp Parser Implementation Plan

This document specifies how to implement the PTC-Lisp parser using NimbleParsec.

**Status:** Draft v2 (incorporates review feedback)

## Overview

The parser transforms PTC-Lisp source code into an Elixir AST suitable for interpretation. It handles the complete syntax defined in [ptc-lisp-specification.md](ptc-lisp-specification.md).

**Pipeline:**
```
source (string) → Parser (NimbleParsec) → Raw AST (tagged tuples)
```

## Module Structure

```
lib/ptc_runner/lisp/
├── parser.ex          # NimbleParsec definitions
├── ast.ex             # AST type specs and constructors
└── parser_helpers.ex  # Post-processing functions for reduce/map
```

---

## 1. AST Node Types

All AST nodes are tagged tuples for pattern matching in the interpreter:

```elixir
# In lib/ptc_runner/lisp/ast.ex

defmodule PtcRunner.Lisp.AST do
  @moduledoc "AST node types for PTC-Lisp"

  @type t ::
          # Literals
          nil
          | boolean()
          | number()
          | {:string, String.t()}
          | {:keyword, atom()}
          # Collections
          | {:vector, [t()]}
          | {:map, [{t(), t()}]}
          # Symbols
          | {:symbol, atom()}
          | {:ns_symbol, :ctx | :memory, atom()}  # ctx/foo, memory/bar
          # Calls
          | {:list, [t()]}  # (op arg1 arg2 ...)

  @doc "Create a keyword node"
  def keyword(name) when is_binary(name), do: {:keyword, String.to_atom(name)}

  @doc "Create a symbol node"
  def symbol(name) when is_binary(name) do
    case String.split(name, "/", parts: 2) do
      ["ctx", key] -> {:ns_symbol, :ctx, String.to_atom(key)}
      ["memory", key] -> {:ns_symbol, :memory, String.to_atom(key)}
      [name] -> {:symbol, String.to_atom(name)}
      [_ns, _key] -> {:symbol, String.to_atom(name)}  # other ns like foo/bar
    end
  end

  @doc "Create a vector node"
  def vector(elements), do: {:vector, elements}

  @doc "Create a map node from flat list [k1, v1, k2, v2, ...]"
  def map_node(pairs) do
    chunked = Enum.chunk_every(pairs, 2)
    {:map, Enum.map(chunked, fn [k, v] -> {k, v} end)}
  end

  @doc "Create a list (call) node"
  def list(elements), do: {:list, elements}
end
```

### Design Decisions

1. **Literals pass through directly**: `nil`, `true`, `false`, integers, floats are Elixir values
2. **Strings wrapped**: `{:string, "hello"}` distinguishes from atoms/keywords
3. **Keywords as atoms**: `{:keyword, :status}` for `:status`
4. **Namespaced symbols special-cased**: `ctx/foo` → `{:ns_symbol, :ctx, :foo}`
5. **Lists are generic**: `{:list, [...]}` — the interpreter determines if it's `let`, `if`, `where`, etc.

### Key Decisions (from review)

#### Atom Safety

**Problem**: `String.to_atom/1` on user input is a potential atom leak / DOS vector in long-running systems.

**Decision**: Use a hybrid approach:
- **Core functions** (filter, map, where, all-of, etc.): Use `String.to_existing_atom/1` — these are pre-registered
- **Keywords** (field names like `:status`): Keep as atoms — field names are bounded by actual data schemas
- **User-defined symbols** in `let`/`fn`: Consider keeping as strings internally

For v1, accept the atom risk with the understanding that:
1. Programs are generated by LLMs, not arbitrary user input
2. Each execution is sandboxed with memory limits
3. Can revisit if this becomes a production concern

#### Error Handling

**Decision**: `Parser.parse/1` NEVER raises — all errors return `{:error, {:parse_error, message}}`.

This includes map validation errors. Wrap internal exceptions:

```elixir
def parse(source) when is_binary(source) do
  try do
    case program(source) do
      {:ok, [ast], "", _, _, _} -> {:ok, ast}
      {:ok, _, rest, _, {line, _}, _} -> {:error, {:parse_error, "..."}}
      {:error, reason, _, _, {line, offset}, byte_offset} -> {:error, {:parse_error, "..."}}
    end
  rescue
    e in ArgumentError -> {:error, {:parse_error, e.message}}
  end
end
```

#### Strings: Single-Line Only

**Decision**: Strings are single-line only (no embedded newlines).

Rationale:
- Easier to debug in LLM-generated code
- Closer to JSON semantics
- Explicit `\n` for newlines is clearer

Implementation: Exclude `\n` and `\r` from `string_char`:

```elixir
string_char =
  choice([
    escape_sequence,
    utf8_char([not: ?\\, not: ?", not: ?\n, not: ?\r])
  ])
```

---

## 2. Parser Implementation

### 2.1 Whitespace and Comments

```elixir
# Whitespace: space, tab, newline, comma (Clojure treats comma as whitespace)
whitespace_char = ascii_char([?\s, ?\t, ?\n, ?\r, ?,])

# Comment: ; to end of line
comment =
  string(";")
  |> repeat(lookahead_not(ascii_char([?\n])) |> utf8_char([]))
  |> optional(ascii_char([?\n]))

# Combined: zero or more whitespace/comments
defcombinatorp :ws,
  repeat(choice([whitespace_char, comment]))
  |> ignore()
```

**Key insight**: Use `ignore()` so whitespace doesn't appear in results.

### 2.2 Literals

#### Nil and Booleans

```elixir
nil_literal =
  string("nil")
  |> lookahead_not(symbol_rest_char())
  |> replace(nil)

true_literal =
  string("true")
  |> lookahead_not(symbol_rest_char())
  |> replace(true)

false_literal =
  string("false")
  |> lookahead_not(symbol_rest_char())
  |> replace(false)
```

**Important**: Use `lookahead_not` to prevent `nil` from matching in `nilly` or `true` in `truthy`.

#### Numbers

```elixir
# Integer: optional minus, digits
integer_literal =
  optional(string("-"))
  |> ascii_string([?0..?9], min: 1)
  |> reduce(:parse_integer)

# Float: optional minus, digits, dot, digits, optional exponent
float_literal =
  optional(string("-"))
  |> ascii_string([?0..?9], min: 1)
  |> string(".")
  |> ascii_string([?0..?9], min: 1)
  |> optional(
    ascii_char([?e, ?E])
    |> optional(ascii_char([?+, ?-]))
    |> ascii_string([?0..?9], min: 1)
  )
  |> reduce(:parse_float)

# Number: try float first (longer match), then integer
number =
  choice([float_literal, integer_literal])
```

**Helper functions** (in `parser_helpers.ex`):

```elixir
def parse_integer(parts) do
  parts |> Enum.join() |> String.to_integer()
end

def parse_float(parts) do
  parts |> Enum.join() |> String.to_float()
end
```

#### Strings

```elixir
# Escape sequences: \\ \" \n \t \r
escape_sequence =
  string("\\")
  |> choice([
    string("\\") |> replace("\\"),
    string("\"") |> replace("\""),
    string("n") |> replace("\n"),
    string("t") |> replace("\t"),
    string("r") |> replace("\r")
  ])

# Regular character: anything except \ and " and newlines (single-line strings only)
regular_char = utf8_char([not: ?\\, not: ?", not: ?\n, not: ?\r])

# String content
string_content =
  repeat(choice([escape_sequence, regular_char]))

# Complete string literal
string_literal =
  ignore(string("\""))
  |> concat(string_content)
  |> ignore(string("\""))
  |> reduce(:build_string)
```

**Helper**:
```elixir
def build_string(chars) do
  {:string, chars |> List.flatten() |> to_string()}
end
```

### 2.3 Keywords

```elixir
# Keyword: colon followed by identifier chars (no / allowed per spec)
keyword_char = ascii_char([?a..?z, ?A..?Z, ?0..?9, ?-, ?_])

keyword =
  ignore(string(":"))
  |> ascii_string([?a..?z, ?A..?Z, ?0..?9, ?-, ?_], min: 1)
  |> map({PtcRunner.Lisp.AST, :keyword, []})
```

### 2.4 Symbols

```elixir
# Symbol first char: letter or special initial
symbol_first_char = ascii_char([?a..?z, ?A..?Z, ?+, ?-, ?*, ?/, ?<, ?>, ?=, ??, ?!])

# Symbol rest char: first char plus digits, -, _, /
symbol_rest_char = ascii_char([?a..?z, ?A..?Z, ?0..?9, ?+, ?-, ?*, ?/, ?<, ?>, ?=, ??, ?!, ?_])

# Full symbol
symbol =
  ascii_string([?a..?z, ?A..?Z, ?+, ?-, ?*, ?/, ?<, ?>, ?=, ??, ?!], 1)
  |> optional(ascii_string([?a..?z, ?A..?Z, ?0..?9, ?+, ?-, ?*, ?/, ?<, ?>, ?=, ??, ?!, ?_], min: 1))
  |> reduce(:join_and_make_symbol)
```

**Helper**:
```elixir
def join_and_make_symbol(parts) do
  name = Enum.join(parts)
  PtcRunner.Lisp.AST.symbol(name)
end
```

**Special cases handled by `AST.symbol/1`**:
- `ctx/input` → `{:ns_symbol, :ctx, :input}`
- `memory/results` → `{:ns_symbol, :memory, :results}`
- `filter` → `{:symbol, :filter}`
- `->>` → `{:symbol, :->>`}

### 2.5 Collections

#### Vectors

```elixir
defcombinatorp :vector,
  ignore(string("["))
  |> concat(parsec(:ws))
  |> repeat(parsec(:expr) |> concat(parsec(:ws)))
  |> ignore(string("]"))
  |> wrap()
  |> map({PtcRunner.Lisp.AST, :vector, []})
```

#### Maps

```elixir
defcombinatorp :map,
  ignore(string("{"))
  |> concat(parsec(:ws))
  |> repeat(parsec(:expr) |> concat(parsec(:ws)))
  |> ignore(string("}"))
  |> wrap()
  |> reduce(:build_map)
```

**Helper** (validates even number of elements):
```elixir
def build_map([elements]) do
  if rem(length(elements), 2) != 0 do
    raise "Map literal must have even number of forms"
  end
  PtcRunner.Lisp.AST.map_node(elements)
end
```

#### Lists (S-expressions)

```elixir
defcombinatorp :list,
  ignore(string("("))
  |> concat(parsec(:ws))
  |> repeat(parsec(:expr) |> concat(parsec(:ws)))
  |> ignore(string(")"))
  |> wrap()
  |> map({PtcRunner.Lisp.AST, :list, []})
```

### 2.6 Expression (Recursive)

```elixir
defcombinatorp :expr,
  choice([
    nil_literal,
    true_literal,
    false_literal,
    float_literal,    # Before integer (longer match)
    integer_literal,
    string_literal,
    keyword,
    symbol,
    parsec(:vector),
    parsec(:map),
    parsec(:list)
  ])
```

### 2.7 Program Entry Point

```elixir
defparsec :parse,
  parsec(:ws)
  |> concat(parsec(:expr))
  |> concat(parsec(:ws))
  |> eos()
```

---

## 3. Complete Parser Module

```elixir
defmodule PtcRunner.Lisp.Parser do
  @moduledoc """
  NimbleParsec-based parser for PTC-Lisp.

  Transforms source code into AST nodes.
  """

  import NimbleParsec
  alias PtcRunner.Lisp.AST
  alias PtcRunner.Lisp.ParserHelpers

  # ============================================================
  # Whitespace and Comments
  # ============================================================

  whitespace_char = ascii_char([?\s, ?\t, ?\n, ?\r, ?,])

  comment =
    string(";")
    |> repeat(lookahead_not(ascii_char([?\n])) |> utf8_char([]))
    |> optional(ascii_char([?\n]))

  defcombinatorp :ws,
    repeat(choice([ignore(whitespace_char), ignore(comment)]))

  # ============================================================
  # Literals
  # ============================================================

  # Character classes for lookahead
  symbol_rest = [?a..?z, ?A..?Z, ?0..?9, ?+, ?-, ?*, ?/, ?<, ?>, ?=, ??, ?!, ?_]

  nil_literal =
    string("nil")
    |> lookahead_not(ascii_char(symbol_rest))
    |> replace(nil)

  true_literal =
    string("true")
    |> lookahead_not(ascii_char(symbol_rest))
    |> replace(true)

  false_literal =
    string("false")
    |> lookahead_not(ascii_char(symbol_rest))
    |> replace(false)

  # Numbers
  sign = ascii_char([?-, ?+])

  integer_literal =
    optional(ascii_char([?-]))
    |> ascii_string([?0..?9], min: 1)
    |> reduce({ParserHelpers, :parse_integer, []})

  exponent =
    ascii_char([?e, ?E])
    |> optional(sign)
    |> ascii_string([?0..?9], min: 1)

  float_literal =
    optional(ascii_char([?-]))
    |> ascii_string([?0..?9], min: 1)
    |> string(".")
    |> ascii_string([?0..?9], min: 1)
    |> optional(exponent)
    |> reduce({ParserHelpers, :parse_float, []})

  # Strings
  escape_sequence =
    ignore(string("\\"))
    |> choice([
      string("\\") |> replace(?\\),
      string("\"") |> replace(?"),
      string("n") |> replace(?\n),
      string("t") |> replace(?\t),
      string("r") |> replace(?\r)
    ])

  # Single-line strings only - exclude literal newlines
  string_char =
    choice([
      escape_sequence,
      utf8_char([not: ?\\, not: ?", not: ?\n, not: ?\r])
    ])

  string_literal =
    ignore(string("\""))
    |> repeat(string_char)
    |> ignore(string("\""))
    |> reduce({ParserHelpers, :build_string, []})

  # Keywords (no / allowed)
  keyword =
    ignore(string(":"))
    |> ascii_string([?a..?z, ?A..?Z, ?0..?9, ?-, ?_], min: 1)
    |> unwrap_and_tag(:keyword)
    |> map({ParserHelpers, :to_keyword, []})

  # Symbols (/ allowed for namespacing)
  symbol_first = [?a..?z, ?A..?Z, ?+, ?-, ?*, ?/, ?<, ?>, ?=, ??, ?!]

  symbol =
    ascii_string(symbol_first, 1)
    |> optional(ascii_string(symbol_rest, min: 1))
    |> reduce({ParserHelpers, :build_symbol, []})

  # ============================================================
  # Collections (recursive)
  # ============================================================

  defcombinatorp :vector,
    ignore(string("["))
    |> concat(parsec(:ws))
    |> repeat(parsec(:expr) |> concat(parsec(:ws)))
    |> ignore(string("]"))
    |> tag(:vector)
    |> map({ParserHelpers, :build_vector, []})

  defcombinatorp :map_literal,
    ignore(string("{"))
    |> concat(parsec(:ws))
    |> repeat(parsec(:expr) |> concat(parsec(:ws)))
    |> ignore(string("}"))
    |> tag(:map)
    |> map({ParserHelpers, :build_map, []})

  defcombinatorp :list,
    ignore(string("("))
    |> concat(parsec(:ws))
    |> repeat(parsec(:expr) |> concat(parsec(:ws)))
    |> ignore(string(")"))
    |> tag(:list)
    |> map({ParserHelpers, :build_list, []})

  # ============================================================
  # Expression
  # ============================================================

  defcombinatorp :expr,
    choice([
      nil_literal,
      true_literal,
      false_literal,
      float_literal,
      integer_literal,
      string_literal,
      keyword,
      symbol,
      parsec(:vector),
      parsec(:map_literal),
      parsec(:list)
    ])

  # ============================================================
  # Entry Point
  # ============================================================

  defparsec :program,
    parsec(:ws)
    |> concat(parsec(:expr))
    |> concat(parsec(:ws))
    |> eos()

  # ============================================================
  # Public API
  # ============================================================

  @doc """
  Parse PTC-Lisp source code into AST.

  Returns `{:ok, ast}` or `{:error, {:parse_error, message}}`.
  """
  @spec parse(String.t()) :: {:ok, AST.t()} | {:error, {:parse_error, String.t()}}
  def parse(source) when is_binary(source) do
    case program(source) do
      {:ok, [ast], "", _context, _position, _offset} ->
        {:ok, ast}

      {:ok, _result, rest, _context, {line, _}, _offset} ->
        {:error, {:parse_error, "Unexpected input at line #{line}: #{inspect(String.slice(rest, 0, 20))}"}}

      {:error, reason, rest, _context, {line, line_offset}, offset} ->
        column = offset - line_offset + 1
        snippet = String.slice(rest, 0, 20)
        {:error, {:parse_error, "#{reason} at line #{line}, column #{column}: #{inspect(snippet)}"}}
    end
  end
end
```

---

## 4. Parser Helpers Module

```elixir
defmodule PtcRunner.Lisp.ParserHelpers do
  @moduledoc "Helper functions for parser reductions"

  alias PtcRunner.Lisp.AST

  # ============================================================
  # Number parsing
  # ============================================================

  def parse_integer(parts) do
    parts
    |> Enum.map(&to_string_part/1)
    |> Enum.join()
    |> String.to_integer()
  end

  def parse_float(parts) do
    parts
    |> Enum.map(&to_string_part/1)
    |> Enum.join()
    |> String.to_float()
  end

  defp to_string_part(part) when is_integer(part), do: <<part::utf8>>
  defp to_string_part(part) when is_binary(part), do: part

  # ============================================================
  # String building
  # ============================================================

  def build_string(chars) do
    str = chars |> Enum.map(&to_string_part/1) |> Enum.join()
    {:string, str}
  end

  # ============================================================
  # Keyword/Symbol building
  # ============================================================

  def to_keyword({:keyword, name}), do: {:keyword, String.to_atom(name)}

  def build_symbol(parts) do
    name = Enum.join(parts)
    AST.symbol(name)
  end

  # ============================================================
  # Collection building
  # ============================================================

  def build_vector({:vector, elements}), do: {:vector, elements}

  def build_map({:map, elements}) do
    if rem(length(elements), 2) != 0 do
      raise ArgumentError, "Map literal requires even number of forms, got #{length(elements)}"
    end

    pairs =
      elements
      |> Enum.chunk_every(2)
      |> Enum.map(fn [k, v] -> {k, v} end)

    {:map, pairs}
  end

  def build_list({:list, elements}), do: {:list, elements}
end
```

---

## 5. Testing Strategy

### 5.1 Unit Tests by Category

```elixir
defmodule PtcRunner.Lisp.ParserTest do
  use ExUnit.Case, async: true

  alias PtcRunner.Lisp.Parser

  describe "literals" do
    test "nil" do
      assert {:ok, nil} = Parser.parse("nil")
    end

    test "booleans" do
      assert {:ok, true} = Parser.parse("true")
      assert {:ok, false} = Parser.parse("false")
    end

    test "integers" do
      assert {:ok, 42} = Parser.parse("42")
      assert {:ok, -17} = Parser.parse("-17")
      assert {:ok, 0} = Parser.parse("0")
    end

    test "floats" do
      assert {:ok, 3.14} = Parser.parse("3.14")
      assert {:ok, -0.5} = Parser.parse("-0.5")
      assert {:ok, 2.5e10} = Parser.parse("2.5e10")
    end

    test "strings" do
      assert {:ok, {:string, "hello"}} = Parser.parse(~s("hello"))
      assert {:ok, {:string, "line1\nline2"}} = Parser.parse(~s("line1\\nline2"))
      assert {:ok, {:string, "quote: \""}} = Parser.parse(~s("quote: \\""))
    end

    test "keywords" do
      assert {:ok, {:keyword, :name}} = Parser.parse(":name")
      assert {:ok, {:keyword, :user_id}} = Parser.parse(":user_id")
    end
  end

  describe "symbols" do
    test "simple symbols" do
      assert {:ok, {:symbol, :filter}} = Parser.parse("filter")
      assert {:ok, {:symbol, :sort-by}} = Parser.parse("sort-by")
      assert {:ok, {:symbol, :empty?}} = Parser.parse("empty?")
    end

    test "operator symbols" do
      assert {:ok, {:symbol, :+}} = Parser.parse("+")
      assert {:ok, {:symbol, :->>}} = Parser.parse("->>")
      assert {:ok, {:symbol, :>=}} = Parser.parse(">=")
    end

    test "namespaced symbols" do
      assert {:ok, {:ns_symbol, :ctx, :input}} = Parser.parse("ctx/input")
      assert {:ok, {:ns_symbol, :memory, :results}} = Parser.parse("memory/results")
    end

    test "nil/true/false don't match as prefixes" do
      # "nilly" should be a symbol, not nil + "ly"
      assert {:ok, {:symbol, :nilly}} = Parser.parse("nilly")
      assert {:ok, {:symbol, :truthy}} = Parser.parse("truthy")
    end
  end

  describe "collections" do
    test "empty vector" do
      assert {:ok, {:vector, []}} = Parser.parse("[]")
    end

    test "vector with elements" do
      assert {:ok, {:vector, [1, 2, 3]}} = Parser.parse("[1 2 3]")
    end

    test "nested vectors" do
      assert {:ok, {:vector, [{:vector, [1, 2]}, {:vector, [3, 4]}]}} =
               Parser.parse("[[1 2] [3 4]]")
    end

    test "empty map" do
      assert {:ok, {:map, []}} = Parser.parse("{}")
    end

    test "map with entries" do
      assert {:ok, {:map, [{{:keyword, :a}, 1}, {{:keyword, :b}, 2}]}} =
               Parser.parse("{:a 1 :b 2}")
    end

    test "list (s-expression)" do
      assert {:ok, {:list, [{:symbol, :+}, 1, 2]}} = Parser.parse("(+ 1 2)")
    end

    test "nested list" do
      assert {:ok, {:list, [{:symbol, :filter},
                            {:list, [{:symbol, :where}, {:keyword, :active}, {:symbol, :=}, true]},
                            {:symbol, :users}]}} =
               Parser.parse("(filter (where :active = true) users)")
    end
  end

  describe "whitespace and comments" do
    test "ignores whitespace" do
      assert {:ok, {:vector, [1, 2, 3]}} = Parser.parse("  [ 1  2  3 ]  ")
    end

    test "commas as whitespace" do
      assert {:ok, {:vector, [1, 2, 3]}} = Parser.parse("[1, 2, 3]")
    end

    test "ignores comments" do
      assert {:ok, 42} = Parser.parse("; this is a comment\n42")
      assert {:ok, {:list, [{:symbol, :+}, 1, 2]}} =
               Parser.parse("(+ 1 ; inline comment\n 2)")
    end
  end

  describe "complex expressions" do
    test "threading macro" do
      source = """
      (->> ctx/products
           (filter (where :in-stock true))
           (sort-by :price)
           (take 10))
      """
      assert {:ok, {:list, [{:symbol, :->>}, {:ns_symbol, :ctx, :products} | _]}} =
               Parser.parse(source)
    end

    test "let with destructuring" do
      source = "(let [{:keys [name age]} user] name)"
      assert {:ok, {:list, [{:symbol, :let} | _]}} = Parser.parse(source)
    end
  end

  describe "error cases" do
    test "unclosed vector" do
      assert {:error, {:parse_error, _}} = Parser.parse("[1 2 3")
    end

    test "unclosed string" do
      assert {:error, {:parse_error, _}} = Parser.parse(~s("hello))
    end

    test "odd number of map elements returns error tuple" do
      # Consistent error handling - no exceptions escape parse/1
      assert {:error, {:parse_error, _}} = Parser.parse("{:a 1 :b}")
    end

    test "namespaced keywords are invalid" do
      # Spec: "no namespaced keywords like :foo/bar"
      assert {:error, {:parse_error, _}} = Parser.parse(":foo/bar")
    end

    test "quoted lists are rejected" do
      # Spec: "NO lists '(1 2 3)"
      assert {:error, {:parse_error, _}} = Parser.parse("'(1 2 3)")
    end

    test "multiline strings are rejected" do
      # Single-line strings only
      assert {:error, {:parse_error, _}} = Parser.parse("\"hello\nworld\"")
    end
  end

  describe "numeric edge cases" do
    test "leading decimal point is invalid" do
      assert {:error, {:parse_error, _}} = Parser.parse(".5")
    end

    test "trailing decimal point is invalid" do
      assert {:error, {:parse_error, _}} = Parser.parse("5.")
    end

    test "exponent without decimal is invalid" do
      # We require digits.digits before exponent
      assert {:error, {:parse_error, _}} = Parser.parse("2e10")
    end

    test "positive sign on numbers" do
      # +5 parses as symbol, not number
      assert {:ok, {:symbol, :+5}} = Parser.parse("+5")
    end
  end

  describe "symbol boundary edge cases" do
    test "nil? is a symbol not nil" do
      assert {:ok, {:symbol, :nil?}} = Parser.parse("nil?")
    end

    test "true? is a symbol not true" do
      assert {:ok, {:symbol, :true?}} = Parser.parse("true?")
    end

    test "false-positive is a symbol not false" do
      assert {:ok, {:symbol, :"false-positive"}} = Parser.parse("false-positive")
    end

    test "nilly is a symbol not nil" do
      assert {:ok, {:symbol, :nilly}} = Parser.parse("nilly")
    end
  end
end
```

### 5.2 Property-Based Tests

```elixir
# Using StreamData
property "round-trip integers" do
  check all int <- integer() do
    {:ok, result} = Parser.parse(Integer.to_string(int))
    assert result == int
  end
end

property "round-trip simple strings" do
  check all str <- string(:alphanumeric) do
    source = inspect(str)  # "hello" format
    {:ok, {:string, result}} = Parser.parse(source)
    assert result == str
  end
end
```

---

## 6. Implementation Order

### Phase 1: Core Infrastructure
1. Create `lib/ptc_runner/lisp/ast.ex` with type specs
2. Create `lib/ptc_runner/lisp/parser_helpers.ex` with helper functions
3. Create `lib/ptc_runner/lisp/parser.ex` with basic structure

### Phase 2: Literals Only
1. Implement nil, true, false
2. Implement integers
3. Implement floats
4. Implement strings with escapes
5. Implement keywords
6. **Test**: All literal parsing works

### Phase 3: Symbols
1. Implement simple symbols
2. Implement operator symbols (`+`, `->>`, `>=`, etc.)
3. Implement namespaced symbols (`ctx/x`, `memory/y`)
4. Add lookahead for nil/true/false boundaries
5. **Test**: Symbol parsing works, no false matches

### Phase 4: Collections
1. Implement vectors `[]`
2. Implement maps `{}`
3. Implement lists `()`
4. Wire up recursion with `parsec(:expr)`
5. **Test**: Nested structures parse correctly

### Phase 5: Whitespace & Comments
1. Implement whitespace handling (space, tab, newline, comma)
2. Implement comment handling (`; to EOL`)
3. **Test**: Comments ignored, whitespace flexible

### Phase 6: Error Messages
1. Add line/column tracking
2. Improve error messages with context
3. **Test**: Errors are informative

### Phase 7: Integration
1. Wire parser into `PtcRunner.Lisp.run/2`
2. Add public API with proper error handling
3. **Test**: End-to-end parsing works

---

## 7. Edge Cases and Gotchas

### 7.1 Symbol Boundaries

The keywords `nil`, `true`, `false` must not match as prefixes:
```
nil    → nil literal
nilly  → symbol :nilly
true   → true literal
truthy → symbol :truthy
```

**Solution**: Use `lookahead_not(ascii_char(symbol_rest))` after matching the keyword.

### 7.2 Number Ambiguity

`-5` could be:
- Negative integer `-5`
- Symbol `-` followed by `5`

**Solution**: In PTC-Lisp, `-5` is always a negative number. The symbol `-` only appears in list position: `(- 10 5)`.

### 7.3 Operator Ordering

In `choice()`, longer operators must come before shorter:
```elixir
choice([
  string("->>") |> ...,  # Before ->
  string("->") |> ...,   # Before -
  string(">=") |> ...,   # Before >
  string("<=") |> ...,   # Before <
  string("!=") |> ...,   # Before !
  ...
])
```

This is already handled by parsing symbols as strings rather than char-by-char.

### 7.4 Map Validation

Maps require even number of forms. This should fail:
```clojure
{:a 1 :b}  ; Error: odd number of forms
```

**Solution**: Validate in `build_map/1` helper, return error (caught by try/rescue in `parse/1`).

### 7.5 Namespaced Keywords

The spec forbids `:foo/bar` (namespaced keywords). Only symbols can have `/`:
```
:status     → keyword :status (valid)
:foo/bar    → parse error (invalid)
ctx/input   → namespaced symbol (valid)
```

**Solution**: Keyword parser only allows `[a-zA-Z0-9_-]`, no `/`.

**How it works**: `:foo/bar` parses as keyword `:foo`, then `/bar` remains. Since there's no whitespace between them, `ws` matches zero chars, and `eos()` fails on `/bar` → parse error.

### 7.6 Quoted Lists

The spec says "NO lists '(1 2 3)". Quote `'` is not a valid expression start.

**How it works**: `'` is not whitespace, not a valid symbol start, and there's no production for it. Parsing `'(1 2 3)` fails immediately with "unexpected input".

### 7.7 Numeric Edge Cases

| Input | Result | Reason |
|-------|--------|--------|
| `42` | integer 42 | Valid |
| `-5` | integer -5 | Negative number |
| `3.14` | float 3.14 | Valid |
| `2.5e10` | float 2.5e10 | Valid with exponent |
| `.5` | parse error | Leading decimal not allowed |
| `5.` | parse error | Trailing decimal not allowed |
| `2e10` | parse error | Exponent requires decimal |
| `+5` | symbol `:+5` | `+` is symbol-first char |

### 7.8 Single-Line Strings

Strings cannot contain literal newlines:
```clojure
"hello
world"    ; Parse error - multiline not allowed
```

Use escape sequences instead:
```clojure
"hello\nworld"  ; Valid - explicit newline escape
```

---

## 8. Performance Considerations

1. **Use `defcombinatorp`** for recursive combinators to avoid code bloat
2. **Order `choice()` by frequency**: Put common cases first (symbols, keywords likely most common)
3. **Avoid backtracking**: Structure grammar to minimize re-parsing
4. **Consider `:inline` option** for hot paths if profiling shows bottlenecks

---

## 9. Future Extensions

### 9.1 Source Locations

Add `line/2` and `byte_offset/2` combinators to track source positions for better error messages:

```elixir
defcombinatorp :expr_with_loc,
  line()
  |> concat(byte_offset())
  |> concat(parsec(:expr))
  |> reduce(:attach_location)
```

### 9.2 Reader Macros (if needed)

If we add `#()` short function syntax later:
```elixir
reader_macro =
  string("#")
  |> concat(parsec(:list))
  |> reduce(:expand_short_fn)
```

### 9.3 Validation Pass

After parsing, a validation pass could:
- Check `where` has correct operator
- Verify `let` has even bindings
- Ensure `if` has exactly 3 forms

This keeps the parser simple (syntactic only) and moves semantic checks to a separate phase.

---

## References

- [NimbleParsec Documentation](https://hexdocs.pm/nimble_parsec/NimbleParsec.html)
- [NimbleParsec GitHub](https://github.com/dashbitco/nimble_parsec)
- [Parser Combinators in Elixir (Serokell)](https://serokell.io/blog/parser-combinators-in-elixir)
- [Boolean Expression Parser Tutorial](https://stefan.lapers.be/posts/elixir-writing-an-expression-parser-with-nimble-parsec/)
- [SQL Predicate Parser Example](https://revelry.co/insights/development/elixir/nimbleparsec/)
- [PTC-Lisp Specification](ptc-lisp-specification.md)
