# PTC-Lisp Phase 1 Benchmark Report

**Date:** 2024-12-07
**Status:** PASS

## Executive Summary

Both LLMs achieved **100% syntax validity**, exceeding the 90% target. PTC-Lisp syntax is LLM-friendly and can be reliably generated by modern LLMs given a concise prompt.

## Test Configuration

| Parameter | Value |
|-----------|-------|
| Generator Models | gemini-2.5-flash, deepseek-v3.2 |
| Judge Model | claude-3.5-haiku (via OpenRouter) |
| Scenarios | 8 |
| Iterations per scenario | 3 |
| Total generations | 48 |

## Results by Model

| Model | Valid Rate | Cost |
|-------|------------|------|
| gemini-2.5-flash | **100%** (24/24) | $0.0225 |
| deepseek-v3.2 | **100%** (24/24) | $0.0200 |

## Results by Difficulty Level

| Level | Description | gemini-2.5-flash | deepseek-v3.2 |
|-------|-------------|------------------|---------------|
| L1 | Simple filter/count | 6/6 | 6/6 |
| L2 | Pipelines, aggregates | 6/6 | 6/6 |
| L3 | Predicate combinators, conditionals | 6/6 | 6/6 |
| L4 | Tool calls, memory contract | 6/6 | 6/6 |

## Test Scenarios

### Level 1 (Simple)
- **simple_filter**: Filter items by price > 100
- **simple_count**: Count active users

### Level 2 (Pipeline)
- **pipeline_filter_sort**: Filter employees by salary, sort descending, take top 5
- **aggregate_sum**: Sum amounts for completed orders

### Level 3 (Predicates)
- **predicate_combinator**: Filter products using `any-of` and `none-of` combinators
- **conditional_logic**: Categorize orders by amount using `cond`

### Level 4 (Tool + Memory)
- **tool_call_transform**: Call tool, filter results, extract field
- **memory_contract**: Store results in memory with `:result` key

## Sample Outputs

### simple_filter (gemini-2.5-flash)
```clojure
(filter (where :price > 100) ctx/input)
```

### predicate_combinator (gemini-2.5-flash)
```clojure
(->> ctx/products
     (filter (none-of (where :in_stock = false)))
     (filter (any-of (where :category = "electronics")
                     (where :price > 500))))
```

### memory_contract (gemini-2.5-flash)
```clojure
(let [all-orders (call "get-orders" {})
      high-value-orders (filter (where :amount > 1000) all-orders)]
  {:high_value_orders high-value-orders
   :result (count high-value-orders)})
```

### conditional_logic (deepseek-v3.2)
```clojure
(let [orders ctx/orders]
  (mapv (fn [order]
          (let [amount (:amount order)
                size (cond
                      (< amount 100) "small"
                      (<= amount 500) "medium"
                      :else "large")]
            {:id (:id order)
             :size size}))
        orders))
```

## Key Observations

1. **Both models correctly used PTC-Lisp idioms:**
   - `where` predicates with operators (`(where :price > 100)`)
   - Predicate combinators (`all-of`, `any-of`, `none-of`) instead of `and`/`or`
   - Namespace access (`ctx/input`, `memory/cached`)
   - Tool calls with string names (`(call "get-users" {})`)
   - Memory contract with `:result` key

2. **No common error patterns** — Zero syntax errors across all 48 generations

3. **Cost efficiency** — Total benchmark cost: $0.04 (96 API calls)

## Conclusion

PTC-Lisp syntax is **LLM-friendly**. The Clojure-like DSL can be reliably generated by modern LLMs given a concise prompt (~2.5KB quick reference). This validates proceeding with implementation.

### Recommendation

**Proceed with PTC-Lisp implementation.** Phase 1 evaluation criteria met.

## Files

- Benchmark script: `test/support/ptc_lisp_benchmark.ex`
- Raw results: `priv/ptc_lisp_benchmark/20251207T092329/`
