# PtcRunner.SubAgent Specification

> **Status:** Draft (branch: `spike-subagent`)

This document specifies the SubAgent API for the PtcRunner library.

---

## Table of Contents

1. [Overview](#overview)
2. [Module Structure](#module-structure)
3. [Core API](#core-api)
   - [SubAgent.delegate/2](#subagentdelegate2)
   - [SubAgent.as_tool/1](#subagent_as_tool1)
4. [Execution Loop](#execution-loop)
   - [Loop.run/2](#looprun2)
   - [System Tools](#system-tools)
5. [Tool Registration](#tool-registration)
   - [Tool Formats](#tool-formats)
   - [LLMTool](#llmtool)
   - [Reserved Names](#reserved-names)
6. [Signatures & Validation](#signatures--validation)
7. [Templates](#templates)
8. [LLM Callback](#llm-callback)
9. [Memory Operations](#memory-operations)
10. [Configuration](#configuration)
11. [Design Decisions](#design-decisions)
12. [Planned Features](#planned-features)
    - [SubAgent Compilation (Derive & Apply)](#subagent-compilation)

---

## Overview

A SubAgent is an isolated worker that executes missions using PTC-Lisp programs generated by an LLM.

**Key concepts:**
- **Mission:** A prompt describing what to accomplish
- **Signature:** Contract defining expected inputs and outputs
- **Tools:** Functions the agent can call
- **Step:** Result struct containing return value, metrics, and trace

**Module structure:**
```
lib/ptc_runner/
├── sub_agent.ex              # Main API
├── step.ex                   # Shared result struct
└── sub_agent/
    ├── loop.ex               # Agentic loop
    ├── prompt.ex             # System prompt generation
    ├── signature.ex          # Signature parsing
    └── llm_tool.ex           # LLM-powered tools
```

---

## Core API

### SubAgent.delegate/2

Delegate a mission to an isolated sub-agent.

```elixir
@spec delegate(String.t(), keyword()) :: {:ok, Step.t()} | {:error, Step.t()}
def delegate(prompt, opts)
```

**Required options:**
- `:llm` - LLM callback function (see [LLM Callback](#llm-callback))

**Optional options:**

| Option | Type | Default | Description |
|--------|------|---------|-------------|
| `:signature` | `String.t()` | `"() -> :any"` | Input/output contract |
| `:tools` | `map()` | `%{}` | Callable tools |
| `:tool_catalog` | `map()` | `%{}` | Non-callable tools (planning visibility) |
| `:context` | `map() \| Step.t()` | `%{}` | Values available as `ctx/` in PTC-Lisp |
| `:context_signature` | `String.t()` | `nil` | Type info for context |
| `:max_turns` | `pos_integer()` | `5` | Maximum LLM calls |
| `:timeout` | `pos_integer()` | `5000` | Per-program timeout (ms) |
| `:mission_timeout` | `pos_integer()` | `60000` | Total mission timeout (ms) |
| `:prompt_limit` | `map()` | `%{list: 5, string: 1000}` | Truncation limits |
| `:llm_retry` | `map()` | `%{max_attempts: 3, backoff: :exponential}` | Retry config |
| `:signature_validation` | `atom()` | `:enabled` | Validation mode |

**Example:**

```elixir
{:ok, step} = SubAgent.delegate(
  "Find the top 3 customers by revenue",
  llm: my_llm,
  signature: "() -> {customers [{name :string, revenue :int}]}",
  tools: %{"get_customers" => &MyApp.get_customers/1}
)

step.return.customers
#=> [%{name: "Acme", revenue: 1_200_000}, ...]
```

**Auto-chaining:**

When passing a `Step` struct to `:context`, both `return` and `signature` are extracted:

```elixir
# These are equivalent:
delegate(prompt, context: step1.return, context_signature: step1.signature)
delegate(prompt, context: step1)
```

**Template placeholders:**

The prompt can contain `{{placeholder}}` references to context:

```elixir
delegate(
  "Summarize emails for {{user_name}}",
  context: %{user_name: "Alice", emails: [...]},
  ...
)
```

Placeholders are validated against context before execution.

---

### SubAgent.as_tool/1

Wrap a SubAgent configuration as a callable tool.

```elixir
@spec as_tool(keyword()) :: (map() -> term())
def as_tool(opts)
```

**Required options:**
- `:prompt` - Template string with `{{placeholder}}` references
- `:signature` - Full contract including inputs: `"(input :type) -> {output :type}"`
- `:llm` - LLM callback

**Optional options:**
- `:tools` - If provided, runs as multi-turn agent (otherwise single-turn judgment)
- `:max_turns` - Override default turns

**Execution modes:**

| Mode | Condition | Behavior |
|------|-----------|----------|
| Judgment | `max_turns: 1` or `2`, no `:tools` | Single LLM call, result parsed directly |
| Agent | `max_turns > 2` or `:tools` provided | Multi-turn, explicit `return`/`fail` required |

**Example:**

```elixir
email_agent = SubAgent.as_tool(
  prompt: "Find emails matching: {{query}}",
  signature: "(query :string) -> {count :int, _ids [:int]}",
  llm: my_llm,
  tools: email_tools
)

# Use as a tool in another agent
delegate("Process urgent emails", tools: %{"find_emails" => email_agent}, ...)
```

**On success:** Returns `step.return` (including firewalled fields).
**On failure:** Raises `PtcRunner.SubAgent.Error` with the `Step` struct.

---

## Execution Loop

### Loop.run/2

Low-level agentic loop. Called internally by `delegate/2`.

```elixir
@spec run(String.t(), keyword()) :: {:ok, Step.t()} | {:error, Step.t()}
def run(prompt, opts)
```

**Loop behavior:**

1. LLM generates a PTC-Lisp program
2. Program executes in sandbox
3. Results merge into context for next turn
4. Repeat until `return` or `fail` is called

**Turn result handling:**
- Results are wrapped in a `Step` struct per turn
- Public fields added to LLM history
- Full results (including firewalled) merged into `ctx/`
- Previous turn's error available as `ctx/fail`

---

### System Tools

Injected into every SubAgent loop:

#### `return`

Complete the mission successfully.

```
return(data :any) -> !
```

- **Argument:** Value matching the signature's output type
- **Effect:** Terminates loop, returns `{:ok, step}`
- **Validation:** If data doesn't match signature, error fed back for self-correction

```clojure
(call "return" {:count 5 :items ["a" "b"]})
```

#### `fail`

Terminate with an error.

```
fail(error {:reason :keyword, :message :string, :op :string?, :details :map?}) -> !
```

- **Effect:** Terminates loop, returns `{:error, step}`

```clojure
(call "fail" {:reason :not_found :message "User does not exist"})
```

---

## Tool Registration

### Tool Formats

Tools in the `:tools` map can be:

**1. Function reference (extracts `@spec`):**
```elixir
"get_user" => &MyApp.get_user/1
```

**2. Function with explicit signature:**
```elixir
"search" => {&MyApp.search/2, "(query :string, limit :int) -> [{id :int}]"}
```

**3. Anonymous function:**
```elixir
"get_time" => fn _args -> DateTime.utc_now() end
```

**4. LLMTool struct:**
```elixir
"classify" => LLMTool.new(prompt: "...", signature: "...")
```

**5. SubAgent-as-tool:**
```elixir
"researcher" => SubAgent.as_tool(prompt: "...", signature: "...", tools: ...)
```

### tools vs tool_catalog

| Aspect | `tools` | `tool_catalog` |
|--------|---------|----------------|
| In prompt | "Tools you can call" | "Tools for planning (do not call)" |
| Callable | Yes | No |
| Use case | Execution | Planning visibility |

### LLMTool

Create tools that use LLM for classification, evaluation, or judgment.

```elixir
defmodule PtcRunner.SubAgent.LLMTool do
  defstruct [:prompt, :signature, :llm, :description, :tools]

  @spec new(keyword()) :: t()
  def new(opts)
end
```

**Options:**
- `:prompt` - Template with `{{placeholder}}` references
- `:signature` - Contract (inputs validated against placeholders)
- `:llm` - `:caller` (default), atom (registry lookup), or function
- `:description` - For schema generation
- `:tools` - If provided, runs as multi-turn agent

**Example:**

```elixir
LLMTool.new(
  prompt: "Is {{email.subject}} urgent for {{tier}} customer?",
  signature: "(email {:subject :string}, tier :string) -> {:urgent :bool, :reason :string}"
)
```

**Placeholder validation:** Every `{{placeholder}}` must match a signature parameter.

### Reserved Names

The following tool names cannot be used:
- `return` - System tool for completion
- `fail` - System tool for failure

Attempting to register reserved names returns `{:error, :reserved_tool_name}`.

---

## Signatures & Validation

See [malli-schema.md](malli-schema.md) for full schema specification.

### Shorthand Syntax

```
Primitives:
  :string :int :float :bool :keyword :any

Lists:
  [:int]                          ; list of integers
  [{:id :int :name :string}]      ; list of maps

Maps:
  {:id :int :name :string}        ; required fields
  :map                            ; any map

Optional fields (? suffix):
  {:id :int :email :string?}      ; email is optional

Nested:
  {:user {:id :int :profile {:bio :string}}}
```

### Full Signature Format

```
(inputs) -> outputs
```

**Examples:**
```
() -> {count :int}                           ; no inputs
(query :string) -> [{id :int}]               ; one input
(user {:id :int}, limit :int) -> :any        ; nested input
```

**Shorthand:** Omit `() ->` when no inputs:
```elixir
signature: "{count :int}"  # equivalent to "() -> {count :int}"
```

### Validation Modes

```elixir
delegate(prompt, signature_validation: :enabled)
```

| Mode | Behavior |
|------|----------|
| `:enabled` | Validate inputs/outputs, fail on errors (default) |
| `:warn_only` | Validate, log warnings, continue |
| `:disabled` | Skip validation |
| `:strict` | Reject extra fields, require all tools have specs |

---

## Templates

### Syntax

```
{{var}}              ; simple value
{{a.b}}              ; nested access
{{#list}}...{{/list}} ; iteration (empty list = empty string)
```

### Validation

Placeholders are validated against signature parameters at registration:

```elixir
# Valid: placeholder matches signature
LLMTool.new(
  prompt: "Hello {{name}}",
  signature: "(name :string) -> {greeting :string}"
)

# Error: placeholder not in signature
LLMTool.new(
  prompt: "Hello {{unknown}}",
  signature: "(name :string) -> {greeting :string}"
)
#=> {:error, {:template_error, "placeholder {{unknown}} not found in signature"}}
```

### ~PROMPT Sigil

Compile-time placeholder extraction:

```elixir
import PtcRunner.SubAgent.Sigils

~PROMPT"Hello {{name}}, you have {{count}} items"
#=> %PtcRunner.Prompt{
#=>   template: "Hello {{name}}, you have {{count}} items",
#=>   placeholders: [%{path: ["name"], type: :simple}, %{path: ["count"], type: :simple}]
#=> }
```

---

## LLM Callback

### Signature

```elixir
@type llm :: (llm_input() -> {:ok, String.t()} | {:error, term()})

@type llm_input :: %{
  required(:system) => String.t(),
  required(:messages) => [%{role: :user | :assistant, content: String.t()}],
  optional(:turn) => pos_integer(),
  optional(:prompt) => String.t(),
  optional(:tool_names) => [String.t()],
  optional(:llm_opts) => map()
}
```

### System Prompt Contents

Generated by `PtcRunner.SubAgent.Prompt`:

1. Core PTC-Lisp instructions
2. Language reference (Clojure subset, `call`, `ctx/`, `memory/`)
3. Error recovery (`ctx/fail` for previous turn errors)
4. Data inventory (typed view of `ctx/` variables)
5. Tool schemas
6. Output format (` ```clojure ` blocks)

### Response Parsing

1. **Code blocks:** Searches for ` ```clojure ` or ` ```lisp `
2. **Plain code:** If no blocks, text starting with `(` parsed as code
3. **Multiple blocks:** Executed sequentially in `do` block
4. **No code:** Boundary reminder sent, prompting for code

---

## Memory Operations

Per-agent scoped memory via PTC-Lisp:

```clojure
(memory/put :key value)    ; store
(memory/get :key)          ; retrieve
memory/key                 ; shorthand access
```

### Limits

| Limit | Default | Description |
|-------|---------|-------------|
| Memory size | 1MB | Per-agent memory map size |
| Nesting depth | 3 | SubAgent spawn depth |
| Turn budget | 20 | Total turns across mission tree |

Exceeding limits returns `{:error, step}` with appropriate reason.

---

## Configuration

### LLM Registry

Use atoms to reference configured models:

```elixir
# config/config.exs
config :ptc_runner, :models, %{
  haiku: [module: PtcRunner.SubAgent.LLM.Anthropic, model: "claude-3-haiku-..."],
  gpt4: [module: PtcRunner.SubAgent.LLM.OpenAI, model: "gpt-4-turbo"]
}

# Usage
delegate(prompt, llm: :haiku, ...)
```

### Retry Configuration

```elixir
llm_retry: %{
  max_attempts: 3,
  backoff: :exponential,  # or :linear
  retryable_errors: [:rate_limit, :timeout]  # optional filter
}
```

**Retry scope:** Only LLM callback failures consume retry budget. Logic errors (syntax, validation) are fed back to LLM as next turn.

---

## Design Decisions

### DD-1: Optional Field Syntax (`?` suffix)

Use `:type?` for optional fields. `[:type]` is reserved for lists.

```
{:email :string?}   ; optional field
{:tags [:string]}   ; list of strings
```

### DD-2: Reserved Names Error at Registration

Fail early at `delegate/2` if user registers `return` or `fail` tools.

### DD-3: Lenient Extra Fields by Default

`:enabled` mode allows extra fields in return data. Use `:strict` for exact matching.

### DD-4: Soft Failures Don't Consume Retry Budget

Logic errors (bad syntax, validation) use turn budget. Infrastructure errors (timeouts, rate limits) use retry budget.

### DD-5: Auto-Chaining with Step Detection

Passing `Step` to `:context` auto-extracts `return` and `signature`.

### DD-6: Malli-based Schema System

Internal representation uses Malli-subset. Shorthand transpiles to Malli.

---

## Planned Features

### SubAgent Compilation (Derive & Apply)

For highly repetitive tasks (batch processing), an agent can be **derived** into a reusable PTC-Lisp function. This separates the cognitive logic (writing the program) from the execution (running the program).

```elixir
@spec compile(keyword()) :: {:ok, CompiledAgent.t()} | {:error, Step.t()}
def compile(opts)

@spec validate_compiled(CompiledAgent.t(), [map()]) :: :ok | {:error, [map()]}
def validate_compiled(compiled, test_cases)
```

**Options for `compile/2`:**
- `:mission` - Prompt describing the program's logic.
- `:signature` - The functional contract.
- `:llm` - LLM to use for generation.
- `:sample` - Optional. Sample data to help the LLM understand structure.
- `:tools` - Optional. Tools used **only during compilation** (e.g., to fetch domain rules). The derived function is pure PTC-Lisp.

**The CompiledAgent Struct:**

```elixir
defmodule PtcRunner.SubAgent.CompiledAgent do
  @type metadata :: %{
    compiled_at: DateTime.t(),
    tokens_used: non_neg_integer(),
    turns: pos_integer(),
    llm_model: String.t() | nil
  }

  defstruct [
    :source,      # Inspectable PTC-Lisp source code
    :signature,   # Functional contract (String)
    :execute,     # Pre-bound (fn(args) -> result) executor
    :metadata     # t:metadata()
  ]
end
```

**Execution Pattern (`execute`)**

The `execute` function handles arguments based on the signature's input count:

- **Single parameter** (e.g., `(item :map) -> ...`):
  `compiled.execute(item_data)` calls the function with the item directly.
- **Multiple parameters** (e.g., `(item :map, threshold :float) -> ...`):
  `compiled.execute(%{item: ..., threshold: ...})` uses a map of named arguments.

**Patterns:**

1. **Derive Phase**: LLM analyzes data/requirements and writes a pure PTC-Lisp function.
2. **Validation (optional)**: User runs `validate_compiled/2` against test cases to ensure logic holds.
3. **Apply Phase**: The function is executed on the full dataset with **zero LLM cost and latency**.

**Error Handling:**
- The `:on_error` option (planned) allows falling back to a full agentic loop (`:fallback`) if the derived function fails on an unseen edge case.

---

## Related Documents

- [step.md](step.md) - Step struct specification
- [malli-schema.md](malli-schema.md) - Schema system
- [lisp-api-updates.md](lisp-api-updates.md) - Changes to Lisp API
- [tutorial.md](tutorial.md) - Usage examples
