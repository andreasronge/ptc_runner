# PtcRunner.SubAgent Specification

> **Status:** Draft specification based on spike validation (branch: `spike-subagent`)

This document specifies the core SubAgent API for inclusion in the PtcRunner library.

## Overview

A SubAgent is an isolated worker that executes tasks using PTC-Lisp programs generated by an LLM. The core library provides:

- **`PtcRunner.SubAgent`** - Main API for task delegation
- **`PtcRunner.SubAgent.Loop`** - Multi-turn agentic execution
- **`PtcRunner.SubAgent.RefExtractor`** - Deterministic value extraction

The LLM integration is callback-based with no external dependencies.

## Module Structure

```
lib/ptc_runner/
├── sub_agent.ex                 # Main API
└── sub_agent/
    ├── loop.ex                  # Agentic loop implementation
    ├── ref_extractor.ex         # Value extraction from results
    └── prompt.ex                # System prompt generation
```

---

## API Specification

### PtcRunner.SubAgent

```elixir
defmodule PtcRunner.SubAgent do
  @moduledoc """
  Isolated task execution with context efficiency.

  SubAgents execute tasks using PTC-Lisp programs generated by an LLM.
  Each SubAgent runs in isolation with its own tools, context, and memory.

  ## Example

      llm = fn %{system: sys, messages: msgs} ->
        # Call your LLM provider
        {:ok, "```clojure\\n(call \\"get_data\\" {})\\n```"}
      end

      {:ok, result} = PtcRunner.SubAgent.delegate(
        "Find the top customer",
        llm: llm,
        tools: %{"get_customers" => &MyApp.get_customers/1}
      )

      result.summary  #=> "Top customer is Acme Corp with $1.2M revenue"
  """

  # ============================================================
  # Types
  # ============================================================

  @typedoc "LLM callback function"
  @type llm :: (llm_input() -> {:ok, String.t()} | {:error, term()})

  @typedoc "Input passed to LLM callback"
  @type llm_input :: %{
    required(:system) => String.t(),
    required(:messages) => [message()]
  }

  @typedoc "Conversation message"
  @type message :: %{
    required(:role) => :user | :assistant,
    required(:content) => String.t()
  }

  @typedoc "Tool function - receives args map, returns any term"
  @type tool :: (map() -> term())

  @typedoc "Ref extractor - Access path or function"
  @type ref_spec :: [Access.access_fun(term(), term())] | (term() -> term())

  @typedoc "Successful result"
  @type result :: %{
    required(:result) => term(),
    required(:summary) => String.t() | nil,
    required(:refs) => map(),
    required(:trace) => [trace_entry()],
    required(:usage) => usage()
  }

  @typedoc "Single turn in execution trace"
  @type trace_entry :: %{
    required(:iteration) => pos_integer(),
    optional(:program) => String.t(),
    optional(:result) => term(),
    optional(:error) => term(),
    optional(:answer) => String.t(),
    optional(:tool_calls) => [tool_call()],
    required(:usage) => usage()
  }

  @typedoc "Tool call record"
  @type tool_call :: %{
    required(:name) => String.t(),
    required(:args) => map(),
    required(:result) => term()
  }

  @typedoc "Token usage statistics"
  @type usage :: %{
    required(:input_tokens) => non_neg_integer(),
    required(:output_tokens) => non_neg_integer(),
    required(:total_tokens) => non_neg_integer(),
    required(:requests) => non_neg_integer()
  }

  @typedoc "Error result"
  @type error :: %{
    required(:reason) => term(),
    required(:trace) => [trace_entry()],
    required(:usage) => usage()
  }

  # ============================================================
  # Main API
  # ============================================================

  @doc """
  Delegate a task to an isolated sub-agent.

  The sub-agent generates PTC-Lisp programs to accomplish the task,
  executing them in a sandboxed environment with access to the
  provided tools.

  ## Required Options

  - `:llm` - Callback function for LLM calls (see `t:llm/0`)

  ## Options

  - `:tools` - Map of tool name (string) to function (default: `%{}`)
  - `:context` - Values available as `ctx/key` in PTC-Lisp (default: `%{}`)
  - `:refs` - Extraction specs for result values (default: `%{}`)
  - `:max_turns` - Maximum LLM calls before failing (default: `5`)
  - `:timeout` - Per-program execution timeout in ms (default: `5000`)
  - `:max_ref_retries` - Retries if required refs are nil (default: `1`)

  ## Return Value

  On success, returns `{:ok, result}` where result contains:

  - `:result` - The final computed value
  - `:summary` - Human-readable summary from LLM
  - `:refs` - Extracted reference values for chaining
  - `:trace` - Execution trace for debugging
  - `:usage` - Token usage statistics

  On failure, returns `{:error, error}` with reason and trace.

  ## Examples

      # Basic usage
      {:ok, result} = PtcRunner.SubAgent.delegate(
        "List all products",
        llm: my_llm,
        tools: %{"get_products" => &Shop.list_products/1}
      )

      # With refs for chaining
      {:ok, result} = PtcRunner.SubAgent.delegate(
        "Find urgent emails",
        llm: my_llm,
        tools: email_tools,
        refs: %{
          email_ids: fn r -> Enum.map(r, & &1[:id]) end,
          count: &length/1
        }
      )

      # Pass refs to next step
      {:ok, step2} = PtcRunner.SubAgent.delegate(
        "Draft replies",
        llm: my_llm,
        tools: draft_tools,
        context: %{email_ids: result.refs.email_ids}
      )
  """
  @spec delegate(String.t(), keyword()) :: {:ok, result()} | {:error, error()}
  def delegate(task, opts)

  @doc """
  Wrap a SubAgent configuration as a callable tool.

  Returns a function that can be used as a tool in another SubAgent,
  enabling hierarchical agent orchestration.

  ## Options

  Same as `delegate/2`, except `:llm` can be provided here or at call time.

  ## Example

      customer_agent = PtcRunner.SubAgent.as_tool(
        llm: my_llm,
        tools: %{"search" => &CRM.search/1},
        refs: %{customer_id: [Access.at(0), :id]}
      )

      # Use in parent agent
      {:ok, result} = PtcRunner.SubAgent.delegate(
        "Find top customer and their orders",
        llm: my_llm,
        tools: %{
          "customer-finder" => customer_agent,
          "order-lookup" => order_agent
        }
      )

  ## Tool Interface

  The returned function expects a map with `:task` key:

      customer_agent.(%{"task" => "Find top customer by revenue"})
      #=> %{result: [...], summary: "...", refs: %{customer_id: 123}, trace: [...]}
  """
  @spec as_tool(keyword()) :: tool()
  def as_tool(opts)
end
```

---

### PtcRunner.SubAgent.Loop

```elixir
defmodule PtcRunner.SubAgent.Loop do
  @moduledoc """
  Multi-turn agentic execution loop.

  Manages the conversation between LLM and PTC-Lisp interpreter:

  1. LLM generates a program (or final answer)
  2. Program is executed via `PtcRunner.Lisp.run/2`
  3. Result (or error) is fed back to LLM
  4. Repeat until LLM answers without a program

  ## Features

  - Tool call recording for observability
  - Error recovery (errors fed back to LLM)
  - Token usage accumulation
  - Memory scoping (per-loop scratchpad)
  - Configurable termination (max_turns, answer detection)
  """

  @doc """
  Run the agentic loop until completion or failure.

  ## Options

  - `:llm` - Required. LLM callback function
  - `:tools` - Tool functions (default: `%{}`)
  - `:context` - Initial context values (default: `%{}`)
  - `:memory` - Initial memory state (default: `%{}`)
  - `:max_turns` - Maximum iterations (default: `5`)
  - `:timeout` - Per-program timeout (default: `5000`)
  - `:system_prompt` - Override default prompt

  ## Return Value

      {:ok, answer, trace, usage, final_memory}
      {:error, reason, trace, usage}
  """
  @spec run(String.t(), keyword()) ::
    {:ok, String.t(), [map()], map(), map()} |
    {:error, term(), [map()], map()}
  def run(task, opts)
end
```

---

### PtcRunner.SubAgent.RefExtractor

```elixir
defmodule PtcRunner.SubAgent.RefExtractor do
  @moduledoc """
  Deterministic value extraction from SubAgent results.

  Refs are extracted after the agentic loop completes, providing
  reliable values for chaining between SubAgents.

  ## Extraction Methods

  1. **Path-based** - Using Access paths
  2. **Function-based** - Using arbitrary functions

  ## Examples

      result = [%{id: 1, name: "Alice"}, %{id: 2, name: "Bob"}]

      refs = RefExtractor.extract(result, %{
        first_id: [Access.at(0), :id],      # Path-based
        count: &length/1,                    # Function-based
        names: fn r -> Enum.map(r, & &1.name) end
      })

      #=> %{first_id: 1, count: 2, names: ["Alice", "Bob"]}
  """

  @type spec :: [Access.access_fun(term(), term())] | (term() -> term())

  @doc """
  Extract values from a result using the given specs.

  Returns a map with the same keys as the spec map.
  Missing paths return `nil`.
  """
  @spec extract(term(), %{atom() => spec()}) :: map()
  def extract(result, specs)

  @doc """
  Validate that required refs are non-nil.

  Returns `{:ok, refs}` if all required refs are present,
  or `{:error, missing_keys}` listing which refs are nil.
  """
  @spec validate(map(), [atom()]) :: {:ok, map()} | {:error, [atom()]}
  def validate(refs, required_keys)
end
```

---

## LLM Callback Contract

The LLM callback is the integration point for any LLM provider.

### Signature

```elixir
@spec llm_callback(input :: map()) :: {:ok, String.t()} | {:error, term()}
```

### Input Structure

```elixir
%{
  system: "You are a PTC-Lisp agent. Query datasets using ```clojure blocks...",
  messages: [
    %{role: :user, content: "Find urgent emails"},
    %{role: :assistant, content: "```clojure\n(call \"list_emails\" {})\n```"},
    %{role: :user, content: "Result: [%{id: 1, subject: \"Urgent\"}]"},
    # ... conversation continues
  ]
}
```

### Output

- **Success:** `{:ok, "LLM response text"}` - May contain code blocks or final answer
- **Error:** `{:error, reason}` - Any error term

### Example Implementation

```elixir
# Minimal example (for testing)
fn %{system: _system, messages: messages} ->
  # Echo back a simple program
  {:ok, ~s'```clojure\n(+ 1 2)\n```'}
end

# With an HTTP-based LLM
fn %{system: system, messages: messages} ->
  body = %{
    model: "gpt-4",
    messages: [
      %{"role" => "system", "content" => system}
      | Enum.map(messages, fn %{role: r, content: c} ->
          %{"role" => to_string(r), "content" => c}
        end)
    ]
  }

  case Req.post("https://api.openai.com/v1/chat/completions",
         json: body,
         headers: [{"Authorization", "Bearer #{api_key}"}]) do
    {:ok, %{status: 200, body: %{"choices" => [%{"message" => %{"content" => text}} | _]}}} ->
      {:ok, text}
    {:ok, %{status: status, body: body}} ->
      {:error, {:api_error, status, body}}
    {:error, reason} ->
      {:error, reason}
  end
end
```

---

## Implementation Hints

Based on the spike validation (`spike-subagent` branch).

### Loop Implementation

```elixir
defmodule PtcRunner.SubAgent.Loop do
  def run(task, opts) do
    llm = Keyword.fetch!(opts, :llm)
    tools = Keyword.get(opts, :tools, %{})
    max_turns = Keyword.get(opts, :max_turns, 5)
    timeout = Keyword.get(opts, :timeout, 5000)

    # Build initial context
    context = build_context(opts)
    system_prompt = Keyword.get_lazy(opts, :system_prompt, fn ->
      PtcRunner.SubAgent.Prompt.generate(tools)
    end)

    # Initialize state
    state = %{
      messages: [%{role: :user, content: task}],
      memory: Keyword.get(opts, :memory, %{}),
      trace: [],
      usage: zero_usage(),
      iteration: max_turns
    }

    loop(llm, system_prompt, tools, context, timeout, state)
  end

  defp loop(_llm, _system, _tools, _ctx, _timeout, %{iteration: 0} = state) do
    {:error, :max_turns_reached, state.trace, state.usage}
  end

  defp loop(llm, system, tools, ctx, timeout, state) do
    # 1. Call LLM
    case llm.(%{system: system, messages: state.messages}) do
      {:ok, response} ->
        state = update_usage(state, response)

        # 2. Extract program or detect answer
        case extract_program(response) do
          {:program, code} ->
            # 3. Execute program
            case execute(code, tools, ctx, state.memory, timeout) do
              {:ok, result, tool_calls, new_memory} ->
                # 4. Record and continue
                state = record_success(state, code, result, tool_calls, new_memory)
                state = append_result_message(state, result)
                loop(llm, system, tools, update_ctx(ctx, result), timeout, state)

              {:error, reason} ->
                # Feed error back to LLM
                state = record_error(state, code, reason)
                state = append_error_message(state, reason)
                loop(llm, system, tools, ctx, timeout, state)
            end

          {:answer, text} ->
            # Done - LLM responded without program
            state = record_answer(state, text)
            {:ok, text, state.trace, state.usage, state.memory}
        end

      {:error, reason} ->
        {:error, {:llm_error, reason}, state.trace, state.usage}
    end
  end

  defp execute(code, tools, ctx, memory, timeout) do
    tool_calls = []  # Accumulator for recording

    tool_fn = fn name, args ->
      case Map.fetch(tools, name) do
        {:ok, fun} ->
          result = fun.(args)
          # Record call (side effect via process dictionary or agent)
          record_tool_call(name, args, result)
          result
        :error ->
          raise "Unknown tool: #{name}"
      end
    end

    case PtcRunner.Lisp.run(code,
           tools: tool_fn,
           context: ctx,
           memory: memory,
           timeout: timeout) do
      {:ok, result, _delta, new_memory} ->
        {:ok, result, get_recorded_calls(), new_memory}
      {:error, reason} ->
        {:error, reason}
    end
  end
end
```

### Program Extraction

```elixir
defp extract_program(response) do
  # Look for ```clojure or ```lisp code blocks
  case Regex.run(~r/```(?:clojure|lisp)?\s*([\s\S]+?)```/, response) do
    [_, code] -> {:program, String.trim(code)}
    nil -> {:answer, response}
  end
end
```

### RefExtractor Implementation

```elixir
defmodule PtcRunner.SubAgent.RefExtractor do
  def extract(result, specs) when is_map(specs) do
    Map.new(specs, fn {key, spec} ->
      {key, extract_one(result, spec)}
    end)
  end

  defp extract_one(result, path) when is_list(path) do
    get_in(result, path)
  rescue
    _ -> nil
  end

  defp extract_one(result, fun) when is_function(fun, 1) do
    fun.(result)
  rescue
    _ -> nil
  end

  def validate(refs, required_keys) do
    missing = Enum.filter(required_keys, fn key ->
      Map.get(refs, key) == nil
    end)

    case missing do
      [] -> {:ok, refs}
      keys -> {:error, keys}
    end
  end
end
```

### Tool Call Recording

Use process dictionary or an Agent to record tool calls during execution:

```elixir
defp record_tool_call(name, args, result) do
  calls = Process.get(:tool_calls, [])
  Process.put(:tool_calls, [{name, args, result} | calls])
end

defp get_recorded_calls do
  calls = Process.get(:tool_calls, [])
  Process.delete(:tool_calls)

  calls
  |> Enum.reverse()
  |> Enum.map(fn {name, args, result} ->
    %{name: name, args: args, result: result}
  end)
end
```

---

## Context Variables

Available in PTC-Lisp programs via `ctx/` prefix:

| Variable | Description |
|----------|-------------|
| `ctx/key` | User-provided context values |
| `ctx/last-result` | Result of previous turn's program |

## Memory Operations

Per-agent scoped memory via PTC-Lisp:

```clojure
(memory/put :key value)    ; Store value
(memory/get :key)          ; Retrieve value
memory/key                 ; Shorthand access
```

---

## Error Handling

### Ref Retry Flow

When required refs are nil, the agent gets another chance:

1. Execute loop until answer
2. Extract refs
3. If required refs nil and retries remaining:
   - Feed error message to LLM
   - Continue loop
4. If still nil, return error to caller

```elixir
def delegate(task, opts) do
  refs_spec = Keyword.get(opts, :refs, %{})
  required = extract_required_keys(refs_spec)
  max_retries = Keyword.get(opts, :max_ref_retries, 1)

  do_delegate(task, opts, refs_spec, required, max_retries)
end

defp do_delegate(task, opts, refs_spec, required, retries) do
  case Loop.run(task, opts) do
    {:ok, answer, trace, usage, memory} ->
      result = extract_result(answer, memory)
      refs = RefExtractor.extract(result, refs_spec)

      case RefExtractor.validate(refs, required) do
        {:ok, _} ->
          {:ok, build_result(result, answer, refs, trace, usage)}

        {:error, missing} when retries > 0 ->
          # Retry with error feedback
          error_msg = format_ref_error(missing, result, refs_spec)
          new_opts = append_message(opts, error_msg)
          do_delegate(task, new_opts, refs_spec, required, retries - 1)

        {:error, missing} ->
          {:error, %{reason: {:missing_refs, missing}, trace: trace, usage: usage}}
      end

    {:error, _, _, _} = err ->
      err
  end
end
```

---

## Test Strategy

### Unit Tests

```elixir
# RefExtractor
test "extracts values using Access paths"
test "extracts values using functions"
test "returns nil for missing paths"
test "validates required refs"

# Loop
test "single-turn completion"
test "multi-turn with tool calls"
test "error recovery feeds back to LLM"
test "max_turns terminates loop"
test "tool calls recorded in trace"
test "memory persists across turns"

# SubAgent
test "delegate with mock LLM"
test "as_tool returns callable function"
test "refs extracted after completion"
test "ref retry on missing required refs"
test "nested SubAgents (as_tool in tools)"
```

### Integration Tests

```elixir
# With real LLM (optional, behind flag)
test "end-to-end task delegation"
test "chained SubAgents pass refs"
test "plan generation via create_plan tool"
```

---

## Migration from Spike

The spike code in `demo/lib/ptc_demo/` should be:

1. **Moved to core:** `AgenticLoop` → `PtcRunner.SubAgent.Loop`
2. **Moved to core:** `RefExtractor` → `PtcRunner.SubAgent.RefExtractor`
3. **Adapted:** `SubAgent` → `PtcRunner.SubAgent` (remove ReqLLM dependency)
4. **Kept in demo:** `LispAgent`, `ModelRegistry`, LLM helpers

---

## Open Questions

1. **Usage extraction:** How to extract token counts from LLM callback?
   - Option A: Callback returns `{:ok, text, usage}`
   - Option B: Separate `:usage_callback` option
   - Option C: Don't track (demo concern only)

2. **Streaming:** Should the callback support streaming?
   - Probably out of scope for v1

3. **System prompt customization:** Full override or composable parts?

---

## Related Documents

- [Tutorial](tutorial.md) - Usage guide and examples
- [Spike Summary](spike-summary.md) - Validation results
- [PtcRunner Guide](../guide.md) - Core PTC-Lisp documentation
