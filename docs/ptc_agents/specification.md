# PtcRunner.SubAgent Specification

> **Status:** Draft (branch: `spike-subagent`)

This document specifies the SubAgent API for the PtcRunner library.

---

## Table of Contents

1. [Overview](#overview)
2. [Module Structure](#module-structure)
3. [Core API](#core-api)
   - [SubAgent.new/1](#subagentnew1)
   - [SubAgent.run/2](#subagentrun2)
   - [SubAgent.run!/2 and then!/2](#subagentrun2-and-then2)
   - [SubAgent.as_tool/2](#subagentas_tool2)
   - [SubAgent.compile/2](#subagentcompile2)
4. [Chaining Patterns](#chaining-patterns)
5. [LLM Inheritance](#llm-inheritance)
6. [Execution Loop](#execution-loop)
   - [Loop.run/2](#looprun2)
   - [System Tools](#system-tools)
7. [Tool Registration](#tool-registration)
   - [Tool Formats](#tool-formats)
   - [LLMTool](#llmtool)
   - [Reserved Names](#reserved-names)
8. [Signatures & Validation](#signatures--validation)
9. [Templates](#templates)
10. [LLM Callback](#llm-callback)
    - [System Prompt Contents](#system-prompt-contents)
    - [System Prompt Customization](#system-prompt-customization)
11. [Memory Operations](#memory-operations)
12. [Debugging & Introspection](#debugging--introspection)
   - [Step.trace Structure](#steptrace-structure)
   - [Debug Mode](#debug-mode)
   - [Prompt Preview](#prompt-preview)
   - [Telemetry Hooks](#telemetry-hooks)
13. [Configuration](#configuration)
14. [Design Decisions](#design-decisions)

---

## Overview

A SubAgent is an isolated worker that executes tasks using PTC-Lisp programs generated by an LLM.

**Key concepts:**
- **Prompt:** A template describing what to accomplish (supports `{{placeholder}}` expansion)
- **Signature:** Contract defining expected inputs and outputs
- **Tools:** Functions the agent can call
- **Step:** Result struct containing return value, metrics, and trace

**Design philosophy:**
- **Agents as data:** SubAgents are defined as structs, enabling composition and delayed execution
- **Separation of definition and execution:** Static config (prompt, signature, tools) vs runtime params (llm, context)
- **LLM inheritance:** Child agents can inherit the parent's LLM unless overridden

**Module structure:**
```
lib/ptc_runner/
├── sub_agent.ex              # Main API
├── step.ex                   # Shared result struct
└── sub_agent/
    ├── loop.ex               # Agentic loop
    ├── prompt.ex             # System prompt generation
    ├── signature.ex          # Signature parsing
    └── llm_tool.ex           # LLM-powered tools
```

---

## Core API

The SubAgent API consists of functions for definition, execution, and composition.

---

### SubAgent.new/1

Creates a SubAgent struct (agent as data). No LLM is called - this just defines the agent.

```elixir
@spec new(keyword()) :: t()
def new(opts)
```

**Struct fields (static definition):**

| Field | Type | Description |
|-------|------|-------------|
| `prompt` | `String.t()` | Template with `{{placeholder}}` support |
| `signature` | `String.t()` | Contract for inputs/outputs |
| `tools` | `map()` | Callable tools |
| `max_turns` | `pos_integer()` | Maximum LLM calls (default: 5) |
| `tool_catalog` | `map()` | Schemas for planning (not callable) |
| `prompt_limit` | `map()` | Truncation config for LLM view |
| `mission_timeout` | `pos_integer()` | Max ms for entire execution |
| `llm_retry` | `map()` | Infrastructure retries (network, 5xx) - does NOT use turns |
| `llm` | `atom() \| function()` | Optional LLM override (for inheritance) |
| `system_prompt` | `system_prompt_opts()` | System prompt customization (see below) |

**Validation (raises `ArgumentError` on failure):**
- `prompt` is required and must be a string
- `max_turns` must be a positive integer (if provided)
- `tools` must be a map (if provided)
- If `signature` is provided, template placeholders must match signature parameters

```elixir
# Error: placeholder not in signature
SubAgent.new(
  prompt: "Find emails for {{user}}",
  signature: "(person :string) -> {count :int}"
)
#=> raises ArgumentError, "placeholders {{user}} not found in signature"
```

**Example:**
```elixir
# Define a reusable agent
email_finder = SubAgent.new(
  prompt: "Find urgent emails for {{user}}",
  signature: "(user :string) -> {count :int, _ids [:int]}",
  tools: email_tools,
  max_turns: 5
)

# Execute later with runtime params
{:ok, step} = SubAgent.run(email_finder, llm: llm, context: %{user: "alice"})
```

---

### SubAgent.run/2

Executes a SubAgent. Always takes a SubAgent struct (or string for convenience).

```elixir
@spec run(SubAgent.t() | String.t(), keyword()) :: {:ok, Step.t()} | {:error, Step.t()}
def run(agent, opts \\ [])
```

**Runtime options:**

| Option | Type | Description |
|--------|------|-------------|
| `llm` | `atom() \| function()` | Required unless agent has `llm` set |
| `llm_registry` | `%{atom() => function()}` | Maps atoms to LLM callbacks (inherited by children) |
| `context` | `map() \| Step.t()` | Input data available as `ctx/` |
| `llm_opts` | `map()` | Per-call LLM options (temperature, etc.) |
| `context_signature` | `String.t()` | Type info for context (auto-set if `Step` passed) |

**Convenience form:** When first argument is a string, struct fields can be passed in opts:
```elixir
# These are equivalent:
SubAgent.run(SubAgent.new(prompt: "Find {{x}}", signature: "..."), llm: llm)
SubAgent.run("Find {{x}}", signature: "...", llm: llm)
```

**Execution Behavior:**

Behavior is determined explicitly by `max_turns` and `tools` parameters. No implicit mode switching.

| `max_turns` | `tools` | Behavior | Termination |
|-------------|---------|----------|-------------|
| `1` | none | Single-turn: one LLM call, expression result returned | Expression value |
| `1` | provided | Single-turn with tools: one turn to use tools | Must call `return`/`fail` |
| `>1` | none | Multi-turn exploration: pure computation with memory feedback | Must call `return`/`fail` |
| `>1` | provided | Agentic loop: multiple turns until done | Must call `return`/`fail` |

**Key Behavioral Differences:**

| Aspect | Single-turn (`max_turns: 1`, no tools) | Multi-turn (`max_turns > 1`) |
|--------|----------------------------------------|------------------------------|
| **Termination** | Expression result returned | Must call `return` or `fail` |
| **Turn count** | Exactly 1 | 1 to `max_turns` |
| **Tool access** | None | User tools (if provided) + system tools |
| **Error recovery** | Fatal (no turns left for feedback) | LLM can self-correct in next turn |
| **Memory feedback** | N/A | Map results merge into `memory/` via Memory Result Contract |
| **ctx/ access** | Yes | Yes |
| **memory/ access** | Yes | Yes |

**Multi-turn without user tools:** Enables iterative data exploration where each turn's expression result (if a map) merges into memory, and the LLM uses accumulated state to refine its analysis before calling `return`.

**Example: Single-turn execution**
```elixir
{:ok, step} = SubAgent.run("{{x}} + {{y}}", context: %{x: 10, y: 5}, llm: llm)
step.return #=> 15
```

**Example: Agentic loop**
```elixir
{:ok, step} = SubAgent.run(email_finder,
  llm: :sonnet,
  context: %{user: "alice@example.com"}
)
```

**Example: Multi-turn exploration (no user tools)**
```elixir
# Agent explores data iteratively, accumulating findings in memory
explorer = SubAgent.new(
  prompt: "Analyze the dataset in ctx/data. Explore its structure, find patterns, and return a summary.",
  signature: "() -> {row_count :int, columns [:string], insights [:string]}",
  max_turns: 5
  # No tools - just pure PTC-Lisp computation
)

{:ok, step} = SubAgent.run(explorer, llm: llm, context: %{data: large_dataset})
```

The LLM might generate:
```clojure
; Turn 1 - explore structure, results merge into memory
{:row-count (count ctx/data)
 :sample (take 3 ctx/data)}
; Memory now has: {:row-count 1000, :sample [...]}

; Turn 2 - based on sample, explore columns
{:columns (keys (first ctx/data))
 :return "found columns"}  ; :return controls what LLM sees, rest persists
; LLM sees: "found columns"
; Memory now has: {:row-count 1000, :sample [...], :columns [...]}

; Turn 3 - satisfied with exploration, call return to terminate
(return {:row_count memory/row-count
         :columns memory/columns
         :insights ["Dataset has 1000 rows" "All numeric values"]})
; Loop terminates, validated against signature
```

---

### SubAgent.run!/2 and then!/2

Bang variants for pipe-style chaining. Raise `SubAgentError` on failure.

```elixir
@spec run!(SubAgent.t() | String.t(), keyword()) :: Step.t()
def run!(agent, opts)

@spec then!(Step.t(), String.t() | SubAgent.t(), keyword()) :: Step.t()
def then!(step, agent, opts \\ [])
```

**`run!/2`** - Returns `Step` directly (raises on error):
```elixir
step = SubAgent.run!(agent, llm: llm, context: %{...})
```

**`then!/2`** - Chains steps, auto-sets `context`:
```elixir
SubAgent.run!(finder_agent, llm: llm)
|> SubAgent.then!(drafter_agent, llm: llm)
|> SubAgent.then!(sender_agent, llm: llm)
```

Implementation:
```elixir
def run!(agent, opts) do
  case run(agent, opts) do
    {:ok, step} -> step
    {:error, step} -> raise SubAgentError, step: step
  end
end

def then!(step, agent, opts \\ []) do
  run!(agent, Keyword.put(opts, :context, step))
end
```

---

### SubAgent.as_tool/2

Wraps a SubAgent as a tool callable by other agents.

```elixir
@spec as_tool(SubAgent.t(), keyword()) :: SubAgentTool.t()
def as_tool(agent, opts \\ [])
```

Returns a `SubAgentTool` struct that the execution loop recognizes:

```elixir
defmodule PtcRunner.SubAgent.SubAgentTool do
  defstruct [:agent, :bound_llm, :signature, :description]

  @type t :: %__MODULE__{
    agent: SubAgent.t(),
    bound_llm: atom() | function() | nil,
    signature: String.t() | nil,
    description: String.t() | nil
  }
end
```

When called:
1. Resolves LLM (agent.llm → bound llm → parent's llm)
2. Executes `run(agent, llm: resolved_llm, context: args)`
3. Returns `step.return` on success, raises on failure

**Example:**
```elixir
# Define agent
finder = SubAgent.new(
  prompt: "Find customer by {{description}}",
  signature: "(description :string) -> {id :int, name :string}",
  tools: crm_tools
)

# Wrap as tool (llm can be bound or inherited)
finder_tool = SubAgent.as_tool(finder)

# Use in parent agent
parent_tools = %{
  "find_customer" => finder_tool,
  "get_orders" => &MyApp.get_orders/1
}

{:ok, step} = SubAgent.run(orchestrator, llm: llm, tools: parent_tools)
# When parent calls "find_customer", it inherits parent's llm
```

---

### SubAgent.compile/2

Generates a reusable PTC-Lisp function from an agent. The LLM is called once to derive the logic; subsequent executions require no LLM.

```elixir
@spec compile(SubAgent.t(), keyword()) :: {:ok, CompiledAgent.t()} | {:error, Step.t()}
def compile(agent, opts)
```

**Options:**
- `llm` - Required. Used once during compilation. Can be a function or atom.
- `llm_registry` - Required if `llm` is an atom. Maps atoms to callbacks.
- `sample` - Sample data to help LLM understand structure.

**What can be compiled:**

| Tool Type | Compilable? | Reason |
|-----------|-------------|--------|
| Pure Elixir functions | ✓ | Deterministic |
| LLMTool | ✗ | Needs LLM at execution |
| SubAgent as tool | ✗ | Needs LLM at execution |

**Example:**
```elixir
# Define agent with pure tools
scorer = SubAgent.new(
  prompt: "Calculate anomaly score for {{report}}",
  signature: "(report :map) -> {score :float, reason :string}",
  tools: %{"lookup_threshold" => &MyApp.lookup_threshold/1}
)

# Compile with function - LLM derives the logic once
{:ok, compiled} = SubAgent.compile(scorer, llm: my_llm_fn, sample: sample_reports)

# Or compile with atom + registry
{:ok, compiled} = SubAgent.compile(scorer,
  llm: :sonnet,
  llm_registry: registry,
  sample: sample_reports
)

# Execute many times - no LLM calls, but tools still run
results = Enum.map(all_reports, fn r -> compiled.execute(%{report: r}) end)
```

**What compile produces:**
- `compiled.source` - Inspectable PTC-Lisp function
- `compiled.execute` - Callable that runs the function
- `compiled.metadata` - Compilation stats (tokens, model, timestamp)

---

## Chaining Patterns

### Using `with` (Recommended)

The idiomatic Elixir pattern for sequential agent chains with error handling:

```elixir
with {:ok, step1} <- SubAgent.run(finder, llm: llm),
     {:ok, step2} <- SubAgent.run(drafter, llm: llm, context: step1),
     {:ok, step3} <- SubAgent.run(sender, llm: llm, context: step2) do
  {:ok, step3}
else
  {:error, %{fail: %{reason: :not_found}}} -> {:error, :no_data}
  {:error, step} -> {:error, step.fail}
end
```

**Benefits:**
- Pattern matches on happy path
- Short-circuits on first `{:error, _}`
- Explicit error handling via `else`
- Auto-chaining: passing `Step` to `:context` extracts both `return` and `signature`

### Using Pipes (for crash-on-error)

When you want to crash on failure, use bang variants:

```elixir
SubAgent.run!(finder, llm: llm)
|> SubAgent.then!(drafter, llm: llm)
|> SubAgent.then!(sender, llm: llm)
```

### Parallel Execution (DIY)

For concurrent agent execution, use standard Elixir patterns:

```elixir
agents = [email_agent, calendar_agent, crm_agent]

results =
  agents
  |> Task.async_stream(fn agent -> SubAgent.run(agent, llm: llm) end)
  |> Enum.map(fn {:ok, result} -> result end)
```

---

## LLM Inheritance

SubAgents can inherit their LLM from the parent, allowing flexible model selection. Atoms like `:haiku` are resolved via the `llm_registry` (see [LLM Registry](#llm-registry)).

**Resolution order (first non-nil wins):**

1. `agent.llm` - Struct override: "this agent always uses haiku"
2. `as_tool(..., llm: x)` - Bound at tool creation
3. Parent's llm - Inherited at call time
4. `run(..., llm: x)` - Required at top level

**Registry inheritance:** The `llm_registry` is automatically passed down to all child SubAgents. You only need to provide it once at the top-level `run/2` call.

**Example:**
```elixir
# User-provided registry (see LLM Registry section)
registry = %{haiku: &MyApp.LLM.haiku/1, sonnet: &MyApp.LLM.sonnet/1}

# Agent that always uses haiku (set in struct)
classifier = SubAgent.new(
  prompt: "Classify {{text}}",
  signature: "(text :string) -> {category :string}",
  llm: :haiku  # Always uses haiku
)

# Agent that inherits LLM (no llm in struct)
finder = SubAgent.new(
  prompt: "Find {{item}}",
  signature: "(item :string) -> {id :int}",
  tools: search_tools
  # llm: nil - will inherit
)

# Tools with different inheritance
parent_tools = %{
  "classify" => SubAgent.as_tool(classifier),         # Uses haiku (struct override)
  "find" => SubAgent.as_tool(finder),                 # Inherits parent's llm
  "summarize" => SubAgent.as_tool(summarizer, llm: :haiku)  # Bound to haiku
}

# Parent uses sonnet; child tools inherit or override as configured
# Registry passed once, inherited by all children
{:ok, step} = SubAgent.run(orchestrator,
  llm: :sonnet,
  llm_registry: registry,
  tools: parent_tools
)
```

**3+ Level Deep Inheritance Example:**

```
┌─────────────────────────────────────────────────────────────────┐
│                   LLM INHERITANCE (3 LEVELS)                     │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  Level 1: Orchestrator                                          │
│  └── run(..., llm: :sonnet)  ← Top-level LLM                    │
│       │                                                          │
│       ├── Tool: "analyzer"                                      │
│       │   └── SubAgent.as_tool(analyzer)                        │
│       │       └── agent.llm: nil → inherits :sonnet             │
│       │           │                                              │
│       │           ├── Level 2: Analyzer calls tools              │
│       │           │   │                                          │
│       │           │   ├── Tool: "classifier"                    │
│       │           │   │   └── as_tool(classifier, llm: :haiku)  │
│       │           │   │       └── bound_llm: :haiku → uses :haiku│
│       │           │   │           │                              │
│       │           │   │           └── Level 3: Classifier        │
│       │           │   │               └── Uses :haiku (bound)    │
│       │           │   │                                          │
│       │           │   └── Tool: "scorer"                        │
│       │           │       └── as_tool(scorer)                   │
│       │           │           └── agent.llm: nil, bound: nil    │
│       │           │               → inherits :sonnet from L1    │
│       │           │               │                              │
│       │           │               └── Level 3: Scorer            │
│       │           │                   └── Uses :sonnet (inherited)│
│       │           │                                              │
│       │           └── Tool: "expert"                            │
│       │               └── as_tool(expert)                       │
│       │                   └── agent.llm: :opus                  │
│       │                       → Uses :opus (struct override)     │
│       │                       │                                  │
│       │                       └── Level 3: Expert                │
│       │                           └── Uses :opus (struct)        │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

```elixir
# User-provided registry (passed once at top level)
registry = %{
  haiku: &MyApp.LLM.haiku/1,
  sonnet: &MyApp.LLM.sonnet/1,
  opus: &MyApp.LLM.opus/1
}

# Level 3 agents
classifier = SubAgent.new(prompt: "Classify", signature: "...")  # No llm
scorer = SubAgent.new(prompt: "Score", signature: "...")         # No llm
expert = SubAgent.new(prompt: "Expert analysis", signature: "...", llm: :opus)

# Level 2 analyzer with nested tools
analyzer = SubAgent.new(
  prompt: "Analyze {{data}}",
  signature: "(data :map) -> {analysis :map}",
  tools: %{
    "classifier" => SubAgent.as_tool(classifier, llm: :haiku),  # Bound
    "scorer" => SubAgent.as_tool(scorer),                       # Inherits
    "expert" => SubAgent.as_tool(expert)                        # Struct override
  }
)

# Level 1 orchestrator - registry passed once, flows to all children
{:ok, step} = SubAgent.run(
  "Analyze the data",
  llm: :sonnet,
  llm_registry: registry,
  tools: %{
    "analyzer" => SubAgent.as_tool(analyzer)  # Inherits :sonnet
  }
)

# Resolution results:
# - Analyzer: uses :sonnet (inherited from run call)
# - Classifier: uses :haiku (bound at as_tool)
# - Scorer: uses :sonnet (inherited through analyzer)
# - Expert: uses :opus (struct override, ignores inheritance)
# Registry is available at all levels for atom resolution
```

**Implementation in loop:**
```elixir
def execute_tool(%SubAgentTool{agent: agent, bound_llm: bound}, args, %{llm: parent_llm, llm_registry: registry}) do
  # Resolution order: struct > bound > parent > error
  llm = agent.llm || bound || parent_llm || raise "llm required"

  # Registry is inherited - passed to child agent
  case SubAgent.run(agent, llm: llm, llm_registry: registry, context: args) do
    {:ok, step} -> step.return
    {:error, step} -> raise SubAgentError, step: step
  end
end
```

---

## Execution Loop

### Loop.run/2

Low-level agentic loop. Called internally by `run/2`.

```elixir
@spec run(String.t(), keyword()) :: {:ok, Step.t()} | {:error, Step.t()}
def run(prompt, opts)
```

**Loop behavior:**

1. LLM generates a PTC-Lisp program
2. Program executes in sandbox
3. Results merge into context for next turn
4. Repeat until `return` or `fail` is called

**Turn result handling:**
- Results are wrapped in a `Step` struct per turn
- Public fields added to LLM history
- Full results (including firewalled) merged into `ctx/`
- Previous turn's error available as `ctx/fail`

---

### System Tools

System tools are **implicitly injected** into every SubAgent's tool registry. They appear in the tool schema shown to the LLM and are called via the standard `(call ...)` syntax.

**Design Decision (DD-9):** System tools are real tools, not keywords. This ensures:
- Consistent `(call ...)` invocation pattern for everything
- LLM sees them in the tool schema alongside user tools
- Unified handling in the interpreter

#### `return`

Complete the mission successfully.

```
return(data :any) -> :exit-success
```

- **Argument:** Value matching the signature's output type
- **Effect:** Terminates loop, returns `{:ok, step}`
- **Validation:** If data doesn't match signature, error fed back for self-correction
- **Note:** The `:exit-success` return type indicates this terminates the loop

```clojure
(return {:count 5 :items ["a" "b"]})
```

#### `fail`

Terminate with an error.

```
fail(error {:reason :keyword, :message :string, :op :string?, :details :map?}) -> :exit-error
```

- **Effect:** Terminates loop, returns `{:error, step}`
- **Note:** The `:exit-error` return type indicates this terminates the loop with failure

**Fail signature fields:**

| Field | Type | Required | Description |
|-------|------|----------|-------------|
| `reason` | `:keyword` | Yes | Machine-readable error code |
| `message` | `:string` | Yes | Human-readable description |
| `op` | `:string` | No | Operation/tool that failed |
| `details` | `:map` | No | Additional context |

```clojure
(fail {:reason :not_found :message "User does not exist"})
```

#### System Tool Implementation

```elixir
# System tools are injected before user tools
defp inject_system_tools(user_tools) do
  system_tools = %{
    "return" => {:system, :return},
    "fail" => {:system, :fail}
  }
  Map.merge(system_tools, user_tools)
end
```

---

## Tool Registration

### Tool Formats

Tools in the `:tools` map can be:

**1. Function reference (extracts `@spec` and `@doc`):**
```elixir
"get_user" => &MyApp.get_user/1
```

**2. Function with explicit signature:**
```elixir
"search" => {&MyApp.search/2, "(query :string, limit :int) -> [{id :int}]"}
```

**3. Function with signature and description (keyword list):**
```elixir
"analyze" => {&MyApp.analyze/1,
  signature: "(data :map) -> {score :float}",
  description: "Analyze data and return anomaly score"
}
```

**4. Anonymous function:**
```elixir
"get_time" => fn _args -> DateTime.utc_now() end
```

**5. LLMTool struct:**
```elixir
"classify" => LLMTool.new(prompt: "...", signature: "...", description: "...")
```

**6. SubAgent-as-tool:**
```elixir
"researcher" => SubAgent.as_tool(prompt: "...", signature: "...", tools: ...)
```

### Tool Format Summary

| Format | Signature | Description | Use Case |
|--------|-----------|-------------|----------|
| `fun` | Auto (@spec) | Auto (@doc) | Quick prototyping |
| `{fun, "sig"}` | Explicit | None | Validation without docs |
| `{fun, signature: "...", description: "..."}` | Explicit | Explicit | Production tools |
| `{fun, :skip}` | Skipped | None | Dynamic/untyped tools |
| `LLMTool.new(...)` | Explicit | Explicit | LLM-powered tools |
| `SubAgent.as_tool(...)` | From agent | From prompt | Nested agents |

Descriptions are shown to the LLM in the system prompt's tool schema section, helping it understand when and how to use each tool.

### tools vs tool_catalog

| Aspect | `tools` | `tool_catalog` |
|--------|---------|----------------|
| In prompt | "Tools you can call" | "Tools for planning (do not call)" |
| Callable | Yes | No |
| Use case | Execution | Planning visibility |

### LLMTool

Create tools that use LLM for classification, evaluation, or judgment.

```elixir
defmodule PtcRunner.SubAgent.LLMTool do
  defstruct [:prompt, :signature, :llm, :description, :tools]

  @spec new(keyword()) :: t()
  def new(opts)
end
```

**Options:**
- `:prompt` - Template with `{{placeholder}}` references
- `:signature` - Contract (inputs validated against placeholders)
- `:llm` - `:caller` (default), atom (registry lookup), or function
- `:description` - For schema generation
- `:tools` - If provided, runs as multi-turn agent

**LLM inheritance - `:caller` vs `nil`:**

| Context | Value | Meaning |
|---------|-------|---------|
| `LLMTool.new(llm: :caller)` | `:caller` | Explicitly inherit from calling agent (default) |
| `LLMTool.new(llm: :haiku)` | atom | Use specific model via registry |
| `SubAgent.new(llm: nil)` | `nil` | Implicitly inherit from parent |
| `SubAgent.new(llm: :haiku)` | atom | Use specific model via registry |

The `:caller` atom is **only valid for LLMTool** and explicitly signals "use whatever LLM the calling agent is using." For SubAgent, omitting `llm` (or setting `nil`) achieves the same inheritance behavior.

**Example:**

```elixir
LLMTool.new(
  prompt: "Is {{email.subject}} urgent for {{tier}} customer?",
  signature: "(email {:subject :string}, tier :string) -> {:urgent :bool, :reason :string}"
)
```

**Placeholder validation:** Every `{{placeholder}}` must match a signature parameter.

### Reserved Names

The following tool names cannot be used:
- `return` - System tool for completion
- `fail` - System tool for failure

Attempting to register reserved names returns `{:error, :reserved_tool_name}`.

---

## Signatures & Validation

See [signature-syntax.md](signature-syntax.md) for full signature syntax specification.

### Shorthand Syntax

```
Primitives:
  :string :int :float :bool :keyword :any

Lists:
  [:int]                          ; list of integers
  [{:id :int :name :string}]      ; list of maps

Maps:
  {:id :int :name :string}        ; required fields
  :map                            ; any map

Optional fields (? suffix):
  {:id :int :email :string?}      ; email is optional

Nested:
  {:user {:id :int :profile {:bio :string}}}
```

### Full Signature Format

```
(inputs) -> outputs
```

**Examples:**
```
() -> {count :int}                           ; no inputs
(query :string) -> [{id :int}]               ; one input
(user {:id :int}, limit :int) -> :any        ; nested input
```

**Shorthand:** Omit `() ->` when no inputs:
```elixir
signature: "{count :int}"  # equivalent to "() -> {count :int}"
```

### Validation Modes

```elixir
SubAgent.run(agent, signature_validation: :enabled, llm: llm)
```

| Mode | Behavior |
|------|----------|
| `:enabled` | Validate inputs/outputs, fail on errors (default) |
| `:warn_only` | Validate, log warnings, continue |
| `:disabled` | Skip validation |
| `:strict` | Reject extra fields, require all tools have specs |

---

## Templates

### Syntax

```
{{var}}              ; simple value
{{a.b}}              ; nested access
{{#list}}...{{/list}} ; iteration (empty list = empty string)
```

### Validation

Placeholders are validated against signature parameters at registration:

```elixir
# Valid: placeholder matches signature
LLMTool.new(
  prompt: "Hello {{name}}",
  signature: "(name :string) -> {greeting :string}"
)

# Error: placeholder not in signature
LLMTool.new(
  prompt: "Hello {{unknown}}",
  signature: "(name :string) -> {greeting :string}"
)
#=> {:error, {:template_error, "placeholder {{unknown}} not found in signature"}}
```

### ~PROMPT Sigil

Compile-time placeholder extraction:

```elixir
import PtcRunner.SubAgent.Sigils

~PROMPT"Hello {{name}}, you have {{count}} items"
#=> %PtcRunner.Prompt{
#=>   template: "Hello {{name}}, you have {{count}} items",
#=>   placeholders: [%{path: ["name"], type: :simple}, %{path: ["count"], type: :simple}]
#=> }
```

---

## LLM Callback

### Signature

```elixir
@type llm :: (llm_input() -> {:ok, llm_response()} | {:error, term()})

@type llm_response :: String.t() | %{
  required(:content) => String.t(),
  optional(:tokens) => %{
    optional(:input) => pos_integer(),
    optional(:output) => pos_integer()
  }
}

@type llm_input :: %{
  required(:system) => String.t(),
  required(:messages) => [%{role: :user | :assistant, content: String.t()}],
  optional(:turn) => pos_integer(),
  optional(:prompt) => String.t(),
  optional(:tool_names) => [String.t()],
  optional(:llm_opts) => map()
}
```

The LLM callback can return either a plain string (backward compatible) or a map with
`content` and optional `tokens`. When tokens are provided, they are:
- Included in telemetry measurements for `:llm, :stop` and `:turn, :stop` events
- Accumulated in `Step.usage` fields (`input_tokens`, `output_tokens`, `total_tokens`)

### System Prompt Contents

Generated by `PtcRunner.SubAgent.Prompt`:

1. Core PTC-Lisp instructions
2. Language reference (Clojure subset, `call`, `ctx/`, `memory/`)
3. Error recovery (`ctx/fail` for previous turn errors)
4. Data inventory (typed view of `ctx/` variables)
5. Tool schemas
6. Output format (` ```clojure ` blocks)

### System Prompt Customization

Developers can customize the system prompt via the `system_prompt` field. This enables custom personas, modified language specifications, or additional instructions.

**Type definition:**

```elixir
@type language_spec :: String.t() | atom() | (map() -> String.t())

@type system_prompt_opts ::
  %{
    optional(:prefix) => String.t(),
    optional(:suffix) => String.t(),
    optional(:language_spec) => language_spec(),
    optional(:output_format) => String.t()
  }
  | (String.t() -> String.t())
  | String.t()
```

**Options:**

| Option | Type | Description |
|--------|------|-------------|
| `:prefix` | `String.t()` | Prepended before all generated content |
| `:suffix` | `String.t()` | Appended after all generated content |
| `:language_spec` | `language_spec()` | Language reference (string, atom, or callback - see below) |
| `:output_format` | `String.t()` | Replaces output format instructions |

**language_spec forms:**

| Form | Description |
|------|-------------|
| `String.t()` | Custom language specification string (used as-is) |
| `atom()` | Resolved via `PtcRunner.Lisp.Prompts.get!/1` (e.g., `:minimal`, `:default`) |
| `fn ctx -> String.t()` | Callback called per-turn with context map |

**Callback context (for function form):**

| Key | Type | Description |
|-----|------|-------------|
| `:turn` | `integer` | Current turn number (1-indexed) |
| `:model` | `atom \| function` | The LLM reference |
| `:memory` | `map` | Current memory state |
| `:messages` | `list` | Conversation history |

**Alternative forms:**

- **Function:** `fn default_prompt -> modified_prompt end` - Full transformation control
- **String:** Complete override (use with caution)

**Examples:**

```elixir
# Add persona prefix and safety suffix
SubAgent.new(
  prompt: "Analyze {{data}}",
  signature: "(data :map) -> {result :map}",
  system_prompt: %{
    prefix: "You are a senior data analyst. Be thorough and precise.",
    suffix: "Always validate your assumptions before returning."
  }
)

# Use a preset prompt profile (atom form)
SubAgent.new(
  prompt: "Simple query",
  signature: "(query :string) -> {answer :any}",
  system_prompt: %{language_spec: :minimal}  # Token-efficient prompt
)

# Dynamic prompt selection based on context (callback form)
SubAgent.new(
  prompt: "Analyze {{data}}",
  signature: "(data :map) -> {result :map}",
  system_prompt: %{
    language_spec: fn ctx ->
      alias PtcRunner.Lisp.Prompts
      if ctx.turn > 1, do: Prompts.get(:multi_turn), else: Prompts.get(:minimal)
    end
  }
)

# Custom DSL variant (e.g., JSON output instead of Lisp)
SubAgent.new(
  prompt: "Transform {{input}}",
  signature: "(input :map) -> {output :map}",
  system_prompt: %{
    language_spec: custom_json_dsl_spec(),
    output_format: "Respond with a single JSON object in a ```json code block."
  }
)

# Full transformation for advanced use cases
SubAgent.new(
  prompt: "Complex task",
  signature: "() -> {result :any}",
  system_prompt: fn default ->
    default
    |> String.replace("PTC-Lisp", "MyDSL")
    |> Kernel.<>("\n\nAdditional instructions here.")
  end
)

# Complete override (danger zone - breaks if internals change)
SubAgent.new(
  prompt: "Custom agent",
  signature: "() -> :any",
  system_prompt: "You are a custom agent. Output Lisp in ```clojure blocks..."
)
```

**Prompt Assembly Order:**

When using a map, the final system prompt is assembled as:

```
1. prefix (if provided)
2. Core PTC-Lisp instructions
3. language_spec (custom or default language reference)
4. Error recovery section
5. Data inventory
6. Tool schemas
7. output_format (custom or default)
8. suffix (if provided)
```

**Warning:** Full string overrides bypass all generated sections. You become responsible for:
- Correct output format instructions (for response parsing)
- Tool schema documentation
- Data inventory (ctx/ variables)
- Error recovery instructions

Use map options or function transformations when possible.

### Response Parsing

1. **Code blocks:** Searches for ` ```clojure ` or ` ```lisp `
2. **Plain code:** If no blocks, text starting with `(` parsed as code
3. **Multiple blocks:** Executed sequentially in `do` block
4. **No code:** Boundary reminder sent, prompting for code

---

## Memory Operations

Per-agent scoped memory via PTC-Lisp:

```clojure
(memory/put :key value)    ; store
(memory/get :key)          ; retrieve
memory/key                 ; shorthand access
```

### Limits

| Limit | Default | Description |
|-------|---------|-------------|
| Memory size | 1MB | Per-agent memory map size |
| Nesting depth | 3 | SubAgent spawn depth |
| Turn budget | 20 | Total turns across mission tree |

Exceeding limits returns `{:error, step}` with appropriate reason.

---

## Debugging & Introspection

SubAgents provide comprehensive debugging capabilities for inspecting prompts, generated programs, and execution flow.

---

### Step.trace Structure

Every `Step` includes a `trace` field containing per-turn execution history. Aggregated metrics are in `step.usage`, not duplicated in trace.

```elixir
@type trace :: [trace_entry()]

@type trace_entry :: %{
  turn: pos_integer(),
  program: String.t(),
  result: term(),
  tool_calls: [tool_call()]
}

@type tool_call :: %{
  name: String.t(),
  args: map(),
  result: term(),
  error: String.t() | nil,        # Error message if tool failed
  timestamp: DateTime.t(),         # When tool was called
  duration_ms: non_neg_integer()   # How long tool took
}
```

**Note:** Debug mode (`debug: true`) captures additional fields per turn (AST, context snapshots, full prompts). See Debug Mode section.

**Accessing trace data:**

```elixir
{:ok, step} = SubAgent.run(agent, llm: llm)

# Inspect all turns
for entry <- step.trace do
  IO.puts("Turn #{entry.turn}:")
  IO.puts("  Program: #{entry.program}")
  IO.puts("  Tools called: #{Enum.map(entry.tool_calls, & &1.name)}")
end

# Find which turn called a specific tool
step.trace
|> Enum.filter(fn entry ->
  Enum.any?(entry.tool_calls, & &1.name == "search")
end)
```

---

### Debug Mode

Enable verbose tracing with the `:debug` option:

```elixir
{:ok, step} = SubAgent.run(agent,
  llm: llm,
  debug: true
)
```

**Debug mode enables:**

| Feature | Normal | Debug |
|---------|--------|-------|
| Turn traces | ✓ | ✓ |
| Full system prompt in trace | ✓ | ✓ |
| Parsed AST in trace | ✗ | ✓ |
| Context snapshots per turn | ✗ | ✓ |
| Tool argument/result logging | Summary | Full |
| Memory state per turn | ✗ | ✓ |

**Debug output helper:**

```elixir
# Pretty-print execution trace
SubAgent.Debug.print_trace(step)

# Output:
# ┌─ Turn 1 ─────────────────────────────────────
# │ Prompt: Find urgent emails for alice@example.com
# │ Program:
# │   (let [emails (call "list_emails" {:user ctx/user})]
# │     (return {:count (count emails) :ids (map :id emails)}))
# │ Tools:
# │   → list_emails({user: "alice@example.com"})
# │     ← [{id: 1, subject: "Urgent"}, {id: 2, subject: "Hello"}]
# │ Result: {:count 2, :ids [1, 2]}
# │ Duration: 245ms | Tokens: 150 in / 89 out
# └──────────────────────────────────────────────
```

**Filtering traces:**

```elixir
# Only keep traces for failed runs (reduce memory in production)
SubAgent.run(agent, llm: llm, trace: :on_error)

# Disable tracing entirely
SubAgent.run(agent, llm: llm, trace: false)
```

| Trace Option | Behavior |
|--------------|----------|
| `true` (default) | Always capture traces |
| `:on_error` | Only keep trace if run fails |
| `false` | No trace (minimal memory) |

---

### Prompt Preview

Inspect the expanded prompt without executing:

```elixir
@spec preview_prompt(SubAgent.t(), keyword()) :: %{
  system: String.t(),
  user: String.t(),
  tool_schemas: [map()]
}
def preview_prompt(agent, opts \\ [])
```

**Example:**

```elixir
agent = SubAgent.new(
  prompt: "Find emails for {{user}} from {{sender}}",
  signature: "(user :string, sender :string) -> {count :int}",
  tools: %{"list_emails" => &MyApp.list_emails/1}
)

preview = SubAgent.preview_prompt(agent,
  context: %{user: "alice", sender: "bob@example.com"}
)

IO.puts(preview.system)
# Outputs the full system prompt with:
# - PTC-Lisp instructions
# - Tool schemas
# - Data inventory showing ctx/user and ctx/sender

IO.puts(preview.user)
# "Find emails for alice from bob@example.com"

IO.inspect(preview.tool_schemas)
# [%{name: "list_emails", signature: "...", description: "..."}]
```

**Use cases:**

- Verify template expansion before running
- Debug system prompt generation
- Test prompt changes without LLM calls
- Export prompts for external review

---

### Telemetry Hooks

SubAgent emits telemetry events for observability integration.

**Events:**

| Event | Measurements | Metadata |
|-------|--------------|----------|
| `[:ptc_runner, :sub_agent, :run, :start]` | - | agent, context |
| `[:ptc_runner, :sub_agent, :run, :stop]` | duration | agent, step, status |
| `[:ptc_runner, :sub_agent, :run, :exception]` | duration | agent, kind, reason, stacktrace |
| `[:ptc_runner, :sub_agent, :turn, :start]` | - | agent, turn |
| `[:ptc_runner, :sub_agent, :turn, :stop]` | duration, tokens | agent, turn, program |
| `[:ptc_runner, :sub_agent, :llm, :start]` | - | agent, turn, messages |
| `[:ptc_runner, :sub_agent, :llm, :stop]` | duration, tokens | agent, turn, response |
| `[:ptc_runner, :sub_agent, :tool, :start]` | - | agent, tool_name, args |
| `[:ptc_runner, :sub_agent, :tool, :stop]` | duration | agent, tool_name, result |
| `[:ptc_runner, :sub_agent, :tool, :exception]` | duration | agent, tool_name, kind, reason, stacktrace |

**Attaching handlers:**

```elixir
:telemetry.attach_many(
  "sub-agent-logger",
  [
    [:ptc_runner, :sub_agent, :run, :stop],
    [:ptc_runner, :sub_agent, :tool, :stop]
  ],
  &MyApp.Telemetry.handle_event/4,
  nil
)

defmodule MyApp.Telemetry do
  def handle_event([:ptc_runner, :sub_agent, :run, :stop], measurements, metadata, _config) do
    Logger.info("SubAgent completed",
      duration_ms: measurements.duration,
      status: metadata.status,
      turns: length(metadata.step.trace)
    )
  end

  def handle_event([:ptc_runner, :sub_agent, :tool, :stop], measurements, metadata, _config) do
    Logger.debug("Tool called",
      tool: metadata.tool_name,
      duration_ms: measurements.duration
    )
  end
end
```

**Integration with common observability tools:**

```elixir
# OpenTelemetry integration
{:ok, _} = OpentelemetryTelemetry.attach_handlers(:ptc_runner)

# Prometheus metrics
PtcRunner.Telemetry.Prometheus.setup()
```

---

### Debugging Chained Agents

When debugging multi-agent chains, each Step contains its own trace:

```elixir
with {:ok, step1} <- SubAgent.run(finder, llm: llm),
     {:ok, step2} <- SubAgent.run(processor, llm: llm, context: step1),
     {:ok, step3} <- SubAgent.run(sender, llm: llm, context: step2) do

  # Each step has independent trace
  SubAgent.Debug.print_trace(step1)
  SubAgent.Debug.print_trace(step2)
  SubAgent.Debug.print_trace(step3)

  # Or combine for full pipeline view
  SubAgent.Debug.print_chain([step1, step2, step3])
end
```

**Debugging nested SubAgents (as_tool):**

When a SubAgent calls another SubAgent as a tool, the child's trace is captured in the tool call:

```elixir
parent_step.trace.turns
|> Enum.flat_map(& &1.execution.tool_calls)
|> Enum.filter(& &1.name == "child_agent")
|> Enum.map(fn call ->
  # Child's full Step is available
  call.result.trace
end)
```

---

### Debug Struct Options

For struct inspection during development:

```elixir
# Inspect agent definition
agent = SubAgent.new(prompt: "...", signature: "...", tools: tools)
IO.inspect(agent, label: "Agent config")

# Inspect with custom options
IO.inspect(step, limit: :infinity, printable_limit: :infinity)

# Derive Inspect protocol excludes sensitive fields by default
# Override with:
IO.inspect(step, custom_options: [show_llm_responses: true])
```

---

## Configuration

### LLM Registry

The library is **provider-agnostic** - it does not include LLM provider modules. Users supply LLM callbacks as functions or atoms that resolve via a user-provided registry.

**LLM callback signature:**

```elixir
@type llm_callback :: (llm_input() -> {:ok, String.t()} | {:error, term()})
```

**Using atoms with a registry:**

Atoms like `:haiku` or `:sonnet` are resolved via the `:llm_registry` option. The registry is a map from atoms to callback functions.

```elixir
# Define your LLM callbacks
defmodule MyApp.LLM do
  def haiku(input) do
    Anthropic.chat(model: "claude-3-haiku-20240307", ...)
  end

  def sonnet(input) do
    Anthropic.chat(model: "claude-3-5-sonnet-20241022", ...)
  end
end

# Create registry
registry = %{
  haiku: &MyApp.LLM.haiku/1,
  sonnet: &MyApp.LLM.sonnet/1
}

# Pass registry at top-level run
SubAgent.run(agent, llm: :sonnet, llm_registry: registry)
```

**Registry inheritance:**

The registry flows down to child SubAgents automatically. You only need to pass it once at the top level:

```elixir
# Child agents with llm: :haiku resolve using parent's registry
classifier = SubAgent.new(prompt: "Classify", llm: :haiku)

tools = %{"classify" => SubAgent.as_tool(classifier)}

# Registry passed once, inherited by all children
SubAgent.run(orchestrator, llm: :sonnet, llm_registry: registry, tools: tools)
```

**Direct function (no registry needed):**

```elixir
# Functions work without any registry
SubAgent.run(agent, llm: fn input -> MyApp.call_llm(input) end)
```

**Optional app-level default:**

For applications that want to avoid passing the registry repeatedly:

```elixir
# In application.ex start/2
Application.put_env(:ptc_runner, :default_llm_registry, MyApp.llm_registry())

# Then llm_registry is optional - falls back to default
SubAgent.run(agent, llm: :haiku)
```

**Livebook example:**

```elixir
Mix.install([{:ptc_runner, "~> 0.1"}, {:req, "~> 0.5"}])

defmodule MyLLM do
  def call(model, input) do
    # ... call API with Req
    {:ok, response}
  end
end

registry = %{
  haiku: &MyLLM.call("claude-3-haiku-20240307", &1),
  sonnet: &MyLLM.call("claude-3-5-sonnet-20241022", &1)
}

{:ok, step} = SubAgent.run("Summarize {{text}}",
  llm: :sonnet,
  llm_registry: registry,
  context: %{text: article}
)
```

**Gotchas & Edge Cases:**

1. **Struct overrides binding:** If an agent has `llm: :haiku` in its struct definition, `SubAgent.as_tool(agent, llm: :sonnet)` will **not** override it. The struct setting always wins. This is intentional - struct-level `llm` means "this agent always uses this model." To make an agent re-parameterizable, leave `llm: nil` in the struct and use `as_tool(..., llm: x)` or inheritance.

2. **Mission-global registry:** The registry is passed once at the top-level `run/2` and flows to all children. There is no per-agent registry override. If two agents both use `:haiku` but need different implementations, use different atom names:
   ```elixir
   registry = %{
     haiku: &MyApp.LLM.haiku/1,
     haiku_custom: &MyApp.LLM.haiku_with_logging/1
   }
   ```

3. **Missing registry error:** If an agent uses an atom (e.g., `llm: :gpt4`) but no `llm_registry` is provided, the error will be `{:error, :llm_not_found}`. This can be confusing if a deeply nested child agent uses an atom while the top-level call used a function. Always provide `llm_registry` when any agent in the tree might use atoms.

### Retry Configuration

```elixir
llm_retry: %{
  max_attempts: 3,
  backoff: :exponential,  # or :linear, :constant
  base_delay: 1000,  # milliseconds
  retryable_errors: [:rate_limit, :timeout]  # optional filter
}
```

**Retry scope:** Only LLM callback failures consume retry budget. Logic errors (syntax, validation) are fed back to LLM as next turn.

---

## Design Decisions

### DD-1: Optional Field Syntax (`?` suffix)

Use `:type?` for optional fields. `[:type]` is reserved for lists.

```
{:email :string?}   ; optional field
{:tags [:string]}   ; list of strings
```

### DD-2: Reserved Names Error at Registration

Fail early at `run/2` if user registers `return` or `fail` tools.

### DD-3: Lenient Extra Fields by Default

`:enabled` mode allows extra fields in return data. Use `:strict` for exact matching.

### DD-4: Soft Failures Don't Consume Retry Budget

Logic errors (bad syntax, validation) use turn budget. Infrastructure errors (timeouts, rate limits) use retry budget.

### DD-5: Auto-Chaining with Step Detection

Passing `Step` to `:context` auto-extracts `return` and `signature`.

**Chaining with failed steps:** If you pass a failed `Step` (where `step.fail` is set) to `:context`, the agent immediately returns `{:error, step}` with `fail.reason: :chained_failure`. This prevents cascading errors and makes failure handling explicit.

```elixir
{:error, failed_step} = SubAgent.run(failing_agent, llm: llm)
{:error, chained_step} = SubAgent.run(next_agent, llm: llm, context: failed_step)

chained_step.fail.reason  #=> :chained_failure
chained_step.fail.details #=> %{upstream: failed_step.fail}
```

### DD-6: Agents as Data

SubAgents are defined as structs via `new/1`, separating definition from execution. This enables:
- Delayed execution
- Reusable agent definitions
- Composition patterns (chaining, parallel)
- Serialization/inspection

### DD-7: LLM Inheritance

Child SubAgents can inherit the parent's LLM. Resolution order:
1. Agent struct `llm` field (override)
2. `as_tool(..., llm: x)` bound LLM
3. Parent's LLM (inherited)
4. `run(..., llm: x)` (required at top level)

### DD-8: Compile Only Works with Pure Tools

`SubAgent.compile/2` generates deterministic PTC-Lisp functions. It can include calls to pure Elixir tools (which execute at runtime), but cannot include LLMTool or SubAgent tools (which would require LLM at execution time).

### DD-9: System Tools Are Real Tools

`return` and `fail` are implemented as real tools injected into the tool registry, not special keywords. This ensures consistent `(call ...)` syntax and LLM visibility.

### DD-10: CompiledAgent.execute Always Uses Maps

The `execute` function always takes a map of named arguments, regardless of parameter count. This ensures:
- Consistent API across all compiled agents
- Adding parameters doesn't break existing callers
- Clear, self-documenting invocations

### DD-11: Tracing Always On by Default

Traces are captured by default (`trace: true`) because:
- Debugging agent behavior is inherently difficult without execution history
- Memory overhead is acceptable for typical agent runs (< 100 turns)
- Production optimization via `trace: :on_error` or `trace: false` is opt-in
- Failed runs are nearly impossible to debug without trace data

The `debug: true` option enables additional expensive captures (AST, context snapshots) that are off by default.

### DD-12: Telemetry for Observability, Not Control Flow

Telemetry events are fire-and-forget notifications, not callbacks that can modify execution. This ensures:
- Observability handlers cannot break agent execution
- No hidden control flow through telemetry
- Production monitoring doesn't affect behavior
- Clear separation between execution and observation

### DD-13: System Prompt Customization via Structured Options

System prompt customization uses a layered approach rather than a single override string:

1. **Map options** (`:prefix`, `:suffix`, `:language_spec`, `:output_format`) for safe, targeted customization
2. **Function transformer** for advanced modifications with access to the full default prompt
3. **String override** as escape hatch for complete control

This design:
- Preserves generated sections (tools, inventory) by default
- Allows DSL variants without rewriting everything
- Provides escape hatches for power users
- Fails gracefully when internals change (map users get updates, string users don't)

The assembly order places `:prefix` first and `:suffix` last, ensuring custom instructions wrap the core functionality rather than being buried within it.

---

## Edge Cases & Clarifications

This section documents behavior for edge cases and common points of confusion.

### Context Handling

| Input | Equivalent To | Notes |
|-------|---------------|-------|
| `context: %{}` | Empty context | No variables in `ctx/` |
| `context: nil` | Empty context | Same as `%{}` |
| Omitting `context` | Empty context | Same as `%{}` |
| `context: step` (success) | `context: step.return` | Also extracts `context_signature` |
| `context: step` (failure) | Immediate `:chained_failure` | See DD-5 |

### Tool Registration Edge Cases

**Duplicate tool names:** Last registration wins. No error is raised.

```elixir
tools = %{
  "search" => &MyApp.search_v1/1,
  "search" => &MyApp.search_v2/1   # This one is used
}
```

**Empty tools map:** Valid for all execution modes.
- `max_turns: 1, tools: %{}` - Single-turn, expression returned directly
- `max_turns: > 1, tools: %{}` - Multi-turn exploration (memory feedback only)

**Tool function behavior:**

| Tool Returns | Result |
|--------------|--------|
| Value | Passed to Lisp as result |
| `{:ok, value}` | Unwrapped, `value` passed to Lisp |
| `{:error, reason}` | Tool error, fed back to LLM for recovery |
| Raises exception | Tool error with `:tool_error` reason |

### LLM Registry Error Handling

| Scenario | Error |
|----------|-------|
| `llm: :unknown` (atom not in registry) | `{:error, %{fail: %{reason: :llm_not_found, message: "LLM :unknown not found in registry"}}}` |
| Registry value not a function | `{:error, %{fail: %{reason: :invalid_llm, message: "Registry value for :name is not a function"}}}` |
| No registry, atom used | `{:error, %{fail: %{reason: :llm_registry_required, message: "llm_registry required when using atom :name"}}}` |

**Registry inheritance:** The `llm_registry` passed to the top-level `run/2` is automatically inherited by all child SubAgents and LLMTools. You never need to pass it again.

### Timeout Behavior

**Turn timeout** (per-turn limit, default 5s):
- Fires during LLM call → LLM request aborted, counts as infrastructure error (retry budget)
- Fires during tool execution → Tool killed, `:timeout` error fed back to LLM
- Fires during Lisp evaluation → Sandbox killed, `:timeout` error

**Mission timeout** (total limit, default 60s):
- Fires between turns → Immediate termination, returns `{:error, step}` with `:mission_timeout`
- Fires during turn → Current turn aborted, same as turn timeout then mission ends

### Validation Mode Inheritance

Validation modes do **not** inherit to child agents. Each agent uses its own mode (default: `:enabled`).

```elixir
# Parent uses strict, child uses default
SubAgent.run(parent,
  llm: llm,
  signature_validation: :strict,
  tools: %{
    "child" => SubAgent.as_tool(child_agent)  # Uses :enabled (default)
  }
)
```

To enforce strict validation on children, set it in the child's struct or pass explicitly.

### Memory Result Contract vs Return Tool

The `:return` key in a map result controls **LLM visibility** within a turn:

```clojure
;; :return key = what LLM sees in history, rest merges to memory
{:return "Found 5 items" :items [...]}
```

The `return` special form terminates the mission:

```clojure
;; return = mission complete, validate against signature
(return {:count 5})
```

These are different mechanisms at different scopes. The LLM is instructed on both in the system prompt.

### Nesting Limits

| Limit | Default | Description |
|-------|---------|-------------|
| Max nesting depth | 3 | SubAgent → as_tool → SubAgent → as_tool → SubAgent |
| Turn budget (global) | 20 | Total turns across all nested agents |

Exceeding nesting depth returns `{:error, step}` with `:max_depth_exceeded`.

**Recursive calls:** An agent calling itself (directly or indirectly) is allowed up to the nesting limit. Each recursive call counts as a new nesting level.

### Firewalled Fields in Tools

Firewalled fields (`_` prefix) in tool **output** signatures work as expected - hidden from LLM history but available in `ctx/`.

Firewalled fields in tool **input** signatures are not meaningful since inputs come from the LLM's generated code. Use regular field names for inputs.

```elixir
# Output firewall - useful
"(id :int) -> {summary :string, _raw_data :map}"

# Input firewall - not useful, avoid
"(_secret :string) -> :bool"  # LLM still has to provide _secret
```

---

## Appendix: CompiledAgent Struct

```elixir
defmodule PtcRunner.SubAgent.CompiledAgent do
  @type metadata :: %{
    compiled_at: DateTime.t(),
    tokens_used: non_neg_integer(),
    turns: pos_integer(),
    llm_model: String.t() | nil
  }

  defstruct [
    :source,      # Inspectable PTC-Lisp source code
    :signature,   # Functional contract (String)
    :execute,     # Pre-bound (fn(map()) -> result) executor
    :metadata     # t:metadata()
  ]
end
```

**Execute Contract (DD-10):**

The `execute` function **always** takes a map of named arguments:

```elixir
# Single parameter signature: (item :map) -> {score :float}
compiled.execute(%{item: item_data})

# Multiple parameters: (item :map, threshold :float) -> {score :float}
compiled.execute(%{item: item_data, threshold: 0.5})

# No parameters: () -> {result :map}
compiled.execute(%{})
```

**CompiledAgent as Tool:**

Unlike `SubAgent.as_tool/2`, a compiled agent can be wrapped as a tool **without LLM**:

```elixir
# Compile once
{:ok, compiled} = SubAgent.compile(scorer, llm: llm, sample: data)

# Use as tool (no LLM needed at execution)
parent_tools = %{
  "score_item" => CompiledAgent.as_tool(compiled)
}

# Parent calls score_item → runs compiled.execute directly
```

**Implementation:**

```elixir
defmodule PtcRunner.SubAgent.CompiledAgent do
  @doc """
  Wrap a compiled agent as a callable tool.

  Unlike SubAgent.as_tool/2, this does NOT require an LLM at execution time.
  The compiled logic runs deterministically with only pure tool calls.
  """
  @spec as_tool(t()) :: tool()
  def as_tool(%__MODULE__{execute: execute, signature: signature}) do
    %{
      type: :compiled,
      execute: execute,
      signature: signature
    }
  end
end
```

---

## Related Documents

- [step.md](step.md) - Step struct specification
- [signature-syntax.md](../signature-syntax.md) - Signature syntax reference
- [SubAgent Guides](../guides/) - Usage guides and patterns
