# PtcRunner.SubAgent Specification

> **Status:** Draft (branch: `spike-subagent`)

This document specifies the SubAgent API for the PtcRunner library.

---

## Table of Contents

1. [Overview](#overview)
2. [Module Structure](#module-structure)
3. [Core API](#core-api)
   - [SubAgent.new/1](#subagentnew1)
   - [SubAgent.run/2](#subagentrun2)
   - [SubAgent.run!/2 and then!/2](#subagentrun2-and-then2)
   - [SubAgent.as_tool/2](#subagentas_tool2)
   - [SubAgent.compile/2](#subagentcompile2)
4. [Chaining Patterns](#chaining-patterns)
5. [LLM Inheritance](#llm-inheritance)
6. [Execution Loop](#execution-loop)
   - [Loop.run/2](#looprun2)
   - [System Tools](#system-tools)
7. [Tool Registration](#tool-registration)
   - [Tool Formats](#tool-formats)
   - [LLMTool](#llmtool)
   - [Reserved Names](#reserved-names)
8. [Signatures & Validation](#signatures--validation)
9. [Templates](#templates)
10. [LLM Callback](#llm-callback)
11. [Memory Operations](#memory-operations)
12. [Configuration](#configuration)
13. [Design Decisions](#design-decisions)

---

## Overview

A SubAgent is an isolated worker that executes tasks using PTC-Lisp programs generated by an LLM.

**Key concepts:**
- **Prompt:** A template describing what to accomplish (supports `{{placeholder}}` expansion)
- **Signature:** Contract defining expected inputs and outputs
- **Tools:** Functions the agent can call
- **Step:** Result struct containing return value, metrics, and trace

**Design philosophy:**
- **Agents as data:** SubAgents are defined as structs, enabling composition and delayed execution
- **Separation of definition and execution:** Static config (prompt, signature, tools) vs runtime params (llm, context)
- **LLM inheritance:** Child agents can inherit the parent's LLM unless overridden

**Module structure:**
```
lib/ptc_runner/
├── sub_agent.ex              # Main API
├── step.ex                   # Shared result struct
└── sub_agent/
    ├── loop.ex               # Agentic loop
    ├── prompt.ex             # System prompt generation
    ├── signature.ex          # Signature parsing
    └── llm_tool.ex           # LLM-powered tools
```

---

## Core API

The SubAgent API consists of functions for definition, execution, and composition.

---

### SubAgent.new/1

Creates a SubAgent struct (agent as data). No LLM is called - this just defines the agent.

```elixir
@spec new(keyword()) :: SubAgent.t()
def new(opts)
```

**Struct fields (static definition):**

| Field | Type | Description |
|-------|------|-------------|
| `prompt` | `String.t()` | Template with `{{placeholder}}` support |
| `signature` | `String.t()` | Contract for inputs/outputs |
| `tools` | `map()` | Callable tools |
| `max_turns` | `pos_integer()` | Maximum LLM calls (default: 5) |
| `tool_catalog` | `map()` | Schemas for planning (not callable) |
| `prompt_limit` | `map()` | Truncation config for LLM view |
| `mission_timeout` | `pos_integer()` | Max ms for entire execution |
| `llm_retry` | `map()` | Retry config for LLM failures |
| `llm` | `atom() \| function()` | Optional LLM override (for inheritance) |

**Example:**
```elixir
# Define a reusable agent
email_finder = SubAgent.new(
  prompt: "Find urgent emails for {{user}}",
  signature: "(user :string) -> {count :int, _ids [:int]}",
  tools: email_tools,
  max_turns: 5
)

# Execute later with runtime params
{:ok, step} = SubAgent.run(email_finder, llm: llm, context: %{user: "alice"})
```

---

### SubAgent.run/2

Executes a SubAgent. Always takes a SubAgent struct (or string for convenience).

```elixir
@spec run(SubAgent.t() | String.t(), keyword()) :: {:ok, Step.t()} | {:error, Step.t()}
def run(agent, opts \\ [])
```

**Runtime options:**

| Option | Type | Description |
|--------|------|-------------|
| `llm` | `atom() \| function()` | Required unless agent has `llm` set |
| `context` | `map() \| Step.t()` | Input data available as `ctx/` |
| `llm_opts` | `map()` | Per-call LLM options (temperature, etc.) |
| `context_signature` | `String.t()` | Type info for context (auto-set if `Step` passed) |

**Convenience form:** When first argument is a string, struct fields can be passed in opts:
```elixir
# These are equivalent:
SubAgent.run(SubAgent.new(prompt: "Find {{x}}", signature: "..."), llm: llm)
SubAgent.run("Find {{x}}", signature: "...", llm: llm)
```

**Execution Modes:**

| Mode | Trigger | Behavior |
|------|---------|----------|
| **Judgment** | `max_turns: 1`, no tools | Single turn, expression result returned directly |
| **Agent** | `max_turns > 1` or `tools` | Multi-turn, requires explicit `(call "return" ...)` |

**Example: Simple Eval (Judgment Mode)**
```elixir
{:ok, step} = SubAgent.run("{{x}} + {{y}}", context: %{x: 10, y: 5}, llm: llm)
step.return #=> 15
```

**Example: Multi-turn Agent**
```elixir
{:ok, step} = SubAgent.run(email_finder,
  llm: :sonnet,
  context: %{user: "alice@example.com"}
)
```

---

### SubAgent.run!/2 and then!/2

Bang variants for pipe-style chaining. Raise `SubAgentError` on failure.

```elixir
@spec run!(SubAgent.t() | String.t(), keyword()) :: Step.t()
def run!(agent, opts)

@spec then!(Step.t(), String.t() | SubAgent.t(), keyword()) :: Step.t()
def then!(step, agent, opts \\ [])
```

**`run!/2`** - Returns `Step` directly (raises on error):
```elixir
step = SubAgent.run!(agent, llm: llm, context: %{...})
```

**`then!/2`** - Chains steps, auto-sets `context`:
```elixir
SubAgent.run!(finder_agent, llm: llm)
|> SubAgent.then!(drafter_agent, llm: llm)
|> SubAgent.then!(sender_agent, llm: llm)
```

Implementation:
```elixir
def run!(agent, opts) do
  case run(agent, opts) do
    {:ok, step} -> step
    {:error, step} -> raise SubAgentError, step: step
  end
end

def then!(step, agent, opts \\ []) do
  run!(agent, Keyword.put(opts, :context, step))
end
```

---

### SubAgent.as_tool/2

Wraps a SubAgent as a tool callable by other agents.

```elixir
@spec as_tool(SubAgent.t(), keyword()) :: SubAgentTool.t()
def as_tool(agent, opts \\ [])
```

Returns a `SubAgentTool` struct that the execution loop recognizes. When called:
1. Resolves LLM (agent.llm → bound llm → parent's llm)
2. Executes `run(agent, llm: resolved_llm, context: args)`
3. Returns `step.return` on success, raises on failure

**Example:**
```elixir
# Define agent
finder = SubAgent.new(
  prompt: "Find customer by {{description}}",
  signature: "(description :string) -> {id :int, name :string}",
  tools: crm_tools
)

# Wrap as tool (llm can be bound or inherited)
finder_tool = SubAgent.as_tool(finder)

# Use in parent agent
parent_tools = %{
  "find_customer" => finder_tool,
  "get_orders" => &MyApp.get_orders/1
}

{:ok, step} = SubAgent.run(orchestrator, llm: llm, tools: parent_tools)
# When parent calls "find_customer", it inherits parent's llm
```

---

### SubAgent.compile/2

Generates a reusable PTC-Lisp function from an agent. The LLM is called once to derive the logic; subsequent executions require no LLM.

```elixir
@spec compile(SubAgent.t(), keyword()) :: {:ok, CompiledAgent.t()} | {:error, Step.t()}
def compile(agent, opts)
```

**Options:**
- `llm` - Required. Used once during compilation.
- `sample` - Sample data to help LLM understand structure.

**What can be compiled:**

| Tool Type | Compilable? | Reason |
|-----------|-------------|--------|
| Pure Elixir functions | ✓ | Deterministic |
| LLMTool | ✗ | Needs LLM at execution |
| SubAgent as tool | ✗ | Needs LLM at execution |

**Example:**
```elixir
# Define agent with pure tools
scorer = SubAgent.new(
  prompt: "Calculate anomaly score for {{report}}",
  signature: "(report :map) -> {score :float, reason :string}",
  tools: %{"lookup_threshold" => &MyApp.lookup_threshold/1}
)

# Compile - LLM derives the logic once
{:ok, compiled} = SubAgent.compile(scorer, llm: llm, sample: sample_reports)

# Execute many times - no LLM calls, but tools still run
results = Enum.map(all_reports, fn r -> compiled.execute(%{report: r}) end)
```

**What compile produces:**
- `compiled.source` - Inspectable PTC-Lisp function
- `compiled.execute` - Callable that runs the function
- `compiled.metadata` - Compilation stats (tokens, model, timestamp)

---

## Chaining Patterns

### Using `with` (Recommended)

The idiomatic Elixir pattern for sequential agent chains with error handling:

```elixir
with {:ok, step1} <- SubAgent.run(finder, llm: llm),
     {:ok, step2} <- SubAgent.run(drafter, llm: llm, context: step1),
     {:ok, step3} <- SubAgent.run(sender, llm: llm, context: step2) do
  {:ok, step3}
else
  {:error, %{fail: %{reason: :not_found}}} -> {:error, :no_data}
  {:error, step} -> {:error, step.fail}
end
```

**Benefits:**
- Pattern matches on happy path
- Short-circuits on first `{:error, _}`
- Explicit error handling via `else`
- Auto-chaining: passing `Step` to `:context` extracts both `return` and `signature`

### Using Pipes (for crash-on-error)

When you want to crash on failure, use bang variants:

```elixir
SubAgent.run!(finder, llm: llm)
|> SubAgent.then!(drafter, llm: llm)
|> SubAgent.then!(sender, llm: llm)
```

### Parallel Execution (DIY)

For concurrent agent execution, use standard Elixir patterns:

```elixir
agents = [email_agent, calendar_agent, crm_agent]

results =
  agents
  |> Task.async_stream(fn agent -> SubAgent.run(agent, llm: llm) end)
  |> Enum.map(fn {:ok, result} -> result end)
```

---

## LLM Inheritance

SubAgents can inherit their LLM from the parent, allowing flexible model selection.

**Resolution order (first non-nil wins):**

1. `agent.llm` - Struct override: "this agent always uses haiku"
2. `as_tool(..., llm: x)` - Bound at tool creation
3. Parent's llm - Inherited at call time
4. `run(..., llm: x)` - Required at top level

**Example:**
```elixir
# Agent that always uses haiku (set in struct)
classifier = SubAgent.new(
  prompt: "Classify {{text}}",
  signature: "(text :string) -> {category :string}",
  llm: :haiku  # Always uses haiku
)

# Agent that inherits LLM (no llm in struct)
finder = SubAgent.new(
  prompt: "Find {{item}}",
  signature: "(item :string) -> {id :int}",
  tools: search_tools
  # llm: nil - will inherit
)

# Tools with different inheritance
parent_tools = %{
  "classify" => SubAgent.as_tool(classifier),         # Uses haiku (struct override)
  "find" => SubAgent.as_tool(finder),                 # Inherits parent's llm
  "summarize" => SubAgent.as_tool(summarizer, llm: :haiku)  # Bound to haiku
}

# Parent uses sonnet; child tools inherit or override as configured
{:ok, step} = SubAgent.run(orchestrator, llm: :sonnet, tools: parent_tools)
```

**Implementation in loop:**
```elixir
def execute_tool(%SubAgentTool{agent: agent, bound_llm: bound}, args, %{llm: parent_llm}) do
  llm = agent.llm || bound || parent_llm || raise "llm required"

  case SubAgent.run(agent, llm: llm, context: args) do
    {:ok, step} -> step.return
    {:error, step} -> raise SubAgentError, step: step
  end
end
```

---

## Execution Loop

### Loop.run/2

Low-level agentic loop. Called internally by `run/2`.

```elixir
@spec run(String.t(), keyword()) :: {:ok, Step.t()} | {:error, Step.t()}
def run(prompt, opts)
```

**Loop behavior:**

1. LLM generates a PTC-Lisp program
2. Program executes in sandbox
3. Results merge into context for next turn
4. Repeat until `return` or `fail` is called

**Turn result handling:**
- Results are wrapped in a `Step` struct per turn
- Public fields added to LLM history
- Full results (including firewalled) merged into `ctx/`
- Previous turn's error available as `ctx/fail`

---

### System Tools

Injected into every SubAgent loop:

#### `return`

Complete the mission successfully.

```
return(data :any) -> !
```

- **Argument:** Value matching the signature's output type
- **Effect:** Terminates loop, returns `{:ok, step}`
- **Validation:** If data doesn't match signature, error fed back for self-correction

```clojure
(call "return" {:count 5 :items ["a" "b"]})
```

#### `fail`

Terminate with an error.

```
fail(error {:reason :keyword, :message :string, :op :string?, :details :map?}) -> !
```

- **Effect:** Terminates loop, returns `{:error, step}`

```clojure
(call "fail" {:reason :not_found :message "User does not exist"})
```

---

## Tool Registration

### Tool Formats

Tools in the `:tools` map can be:

**1. Function reference (extracts `@spec`):**
```elixir
"get_user" => &MyApp.get_user/1
```

**2. Function with explicit signature:**
```elixir
"search" => {&MyApp.search/2, "(query :string, limit :int) -> [{id :int}]"}
```

**3. Anonymous function:**
```elixir
"get_time" => fn _args -> DateTime.utc_now() end
```

**4. LLMTool struct:**
```elixir
"classify" => LLMTool.new(prompt: "...", signature: "...")
```

**5. SubAgent-as-tool:**
```elixir
"researcher" => SubAgent.as_tool(prompt: "...", signature: "...", tools: ...)
```

### tools vs tool_catalog

| Aspect | `tools` | `tool_catalog` |
|--------|---------|----------------|
| In prompt | "Tools you can call" | "Tools for planning (do not call)" |
| Callable | Yes | No |
| Use case | Execution | Planning visibility |

### LLMTool

Create tools that use LLM for classification, evaluation, or judgment.

```elixir
defmodule PtcRunner.SubAgent.LLMTool do
  defstruct [:prompt, :signature, :llm, :description, :tools]

  @spec new(keyword()) :: t()
  def new(opts)
end
```

**Options:**
- `:prompt` - Template with `{{placeholder}}` references
- `:signature` - Contract (inputs validated against placeholders)
- `:llm` - `:caller` (default), atom (registry lookup), or function
- `:description` - For schema generation
- `:tools` - If provided, runs as multi-turn agent

**Example:**

```elixir
LLMTool.new(
  prompt: "Is {{email.subject}} urgent for {{tier}} customer?",
  signature: "(email {:subject :string}, tier :string) -> {:urgent :bool, :reason :string}"
)
```

**Placeholder validation:** Every `{{placeholder}}` must match a signature parameter.

### Reserved Names

The following tool names cannot be used:
- `return` - System tool for completion
- `fail` - System tool for failure

Attempting to register reserved names returns `{:error, :reserved_tool_name}`.

---

## Signatures & Validation

See [signature-syntax.md](signature-syntax.md) for full signature syntax specification.

### Shorthand Syntax

```
Primitives:
  :string :int :float :bool :keyword :any

Lists:
  [:int]                          ; list of integers
  [{:id :int :name :string}]      ; list of maps

Maps:
  {:id :int :name :string}        ; required fields
  :map                            ; any map

Optional fields (? suffix):
  {:id :int :email :string?}      ; email is optional

Nested:
  {:user {:id :int :profile {:bio :string}}}
```

### Full Signature Format

```
(inputs) -> outputs
```

**Examples:**
```
() -> {count :int}                           ; no inputs
(query :string) -> [{id :int}]               ; one input
(user {:id :int}, limit :int) -> :any        ; nested input
```

**Shorthand:** Omit `() ->` when no inputs:
```elixir
signature: "{count :int}"  # equivalent to "() -> {count :int}"
```

### Validation Modes

```elixir
SubAgent.run(agent, signature_validation: :enabled, llm: llm)
```

| Mode | Behavior |
|------|----------|
| `:enabled` | Validate inputs/outputs, fail on errors (default) |
| `:warn_only` | Validate, log warnings, continue |
| `:disabled` | Skip validation |
| `:strict` | Reject extra fields, require all tools have specs |

---

## Templates

### Syntax

```
{{var}}              ; simple value
{{a.b}}              ; nested access
{{#list}}...{{/list}} ; iteration (empty list = empty string)
```

### Validation

Placeholders are validated against signature parameters at registration:

```elixir
# Valid: placeholder matches signature
LLMTool.new(
  prompt: "Hello {{name}}",
  signature: "(name :string) -> {greeting :string}"
)

# Error: placeholder not in signature
LLMTool.new(
  prompt: "Hello {{unknown}}",
  signature: "(name :string) -> {greeting :string}"
)
#=> {:error, {:template_error, "placeholder {{unknown}} not found in signature"}}
```

### ~PROMPT Sigil

Compile-time placeholder extraction:

```elixir
import PtcRunner.SubAgent.Sigils

~PROMPT"Hello {{name}}, you have {{count}} items"
#=> %PtcRunner.Prompt{
#=>   template: "Hello {{name}}, you have {{count}} items",
#=>   placeholders: [%{path: ["name"], type: :simple}, %{path: ["count"], type: :simple}]
#=> }
```

---

## LLM Callback

### Signature

```elixir
@type llm :: (llm_input() -> {:ok, String.t()} | {:error, term()})

@type llm_input :: %{
  required(:system) => String.t(),
  required(:messages) => [%{role: :user | :assistant, content: String.t()}],
  optional(:turn) => pos_integer(),
  optional(:prompt) => String.t(),
  optional(:tool_names) => [String.t()],
  optional(:llm_opts) => map()
}
```

### System Prompt Contents

Generated by `PtcRunner.SubAgent.Prompt`:

1. Core PTC-Lisp instructions
2. Language reference (Clojure subset, `call`, `ctx/`, `memory/`)
3. Error recovery (`ctx/fail` for previous turn errors)
4. Data inventory (typed view of `ctx/` variables)
5. Tool schemas
6. Output format (` ```clojure ` blocks)

### Response Parsing

1. **Code blocks:** Searches for ` ```clojure ` or ` ```lisp `
2. **Plain code:** If no blocks, text starting with `(` parsed as code
3. **Multiple blocks:** Executed sequentially in `do` block
4. **No code:** Boundary reminder sent, prompting for code

---

## Memory Operations

Per-agent scoped memory via PTC-Lisp:

```clojure
(memory/put :key value)    ; store
(memory/get :key)          ; retrieve
memory/key                 ; shorthand access
```

### Limits

| Limit | Default | Description |
|-------|---------|-------------|
| Memory size | 1MB | Per-agent memory map size |
| Nesting depth | 3 | SubAgent spawn depth |
| Turn budget | 20 | Total turns across mission tree |

Exceeding limits returns `{:error, step}` with appropriate reason.

---

## Configuration

### LLM Registry

Use atoms to reference configured models:

```elixir
# config/config.exs
config :ptc_runner, :models, %{
  haiku: [module: PtcRunner.SubAgent.LLM.Anthropic, model: "claude-3-haiku-..."],
  gpt4: [module: PtcRunner.SubAgent.LLM.OpenAI, model: "gpt-4-turbo"]
}

# Usage
SubAgent.run(agent, llm: :haiku)
```

### Retry Configuration

```elixir
llm_retry: %{
  max_attempts: 3,
  backoff: :exponential,  # or :linear
  retryable_errors: [:rate_limit, :timeout]  # optional filter
}
```

**Retry scope:** Only LLM callback failures consume retry budget. Logic errors (syntax, validation) are fed back to LLM as next turn.

---

## Design Decisions

### DD-1: Optional Field Syntax (`?` suffix)

Use `:type?` for optional fields. `[:type]` is reserved for lists.

```
{:email :string?}   ; optional field
{:tags [:string]}   ; list of strings
```

### DD-2: Reserved Names Error at Registration

Fail early at `run/2` if user registers `return` or `fail` tools.

### DD-3: Lenient Extra Fields by Default

`:enabled` mode allows extra fields in return data. Use `:strict` for exact matching.

### DD-4: Soft Failures Don't Consume Retry Budget

Logic errors (bad syntax, validation) use turn budget. Infrastructure errors (timeouts, rate limits) use retry budget.

### DD-5: Auto-Chaining with Step Detection

Passing `Step` to `:context` auto-extracts `return` and `signature`.

### DD-6: Agents as Data

SubAgents are defined as structs via `new/1`, separating definition from execution. This enables:
- Delayed execution
- Reusable agent definitions
- Composition patterns (chaining, parallel)
- Serialization/inspection

### DD-7: LLM Inheritance

Child SubAgents can inherit the parent's LLM. Resolution order:
1. Agent struct `llm` field (override)
2. `as_tool(..., llm: x)` bound LLM
3. Parent's LLM (inherited)
4. `run(..., llm: x)` (required at top level)

### DD-8: Compile Only Works with Pure Tools

`SubAgent.compile/2` generates deterministic PTC-Lisp functions. It can include calls to pure Elixir tools (which execute at runtime), but cannot include LLMTool or SubAgent tools (which would require LLM at execution time).

---

## Appendix: CompiledAgent Struct

```elixir
defmodule PtcRunner.SubAgent.CompiledAgent do
  @type metadata :: %{
    compiled_at: DateTime.t(),
    tokens_used: non_neg_integer(),
    turns: pos_integer(),
    llm_model: String.t() | nil
  }

  defstruct [
    :source,      # Inspectable PTC-Lisp source code
    :signature,   # Functional contract (String)
    :execute,     # Pre-bound (fn(args) -> result) executor
    :metadata     # t:metadata()
  ]
end
```

The `execute` function handles arguments based on the signature's input count:

- **Single parameter** (e.g., `(item :map) -> ...`):
  `compiled.execute(item_data)` calls the function with the item directly.
- **Multiple parameters** (e.g., `(item :map, threshold :float) -> ...`):
  `compiled.execute(%{item: ..., threshold: ...})` uses a map of named arguments.

---

## Related Documents

- [step.md](step.md) - Step struct specification
- [signature-syntax.md](signature-syntax.md) - Signature syntax specification
- [lisp-api-updates.md](lisp-api-updates.md) - Changes to Lisp API
- [tutorial.md](tutorial.md) - Usage examples
