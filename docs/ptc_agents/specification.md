# PtcRunner.SubAgent Specification

> **Status:** Draft specification based on spike validation (branch: `spike-subagent`)

This document specifies the core SubAgent API for inclusion in the PtcRunner library.

## Overview

A SubAgent is an isolated worker that executes missions using PTC-Lisp programs generated by an LLM. The core library provides:

> **Design Decisions:** Key API decisions and their rationale are documented in the [Design Decisions](#design-decisions) section at the end of this document.
 
- **`PtcRunner.SubAgent`** - Main API for mission delegation
- **`PtcRunner.SubAgent.Loop`** - Multi-turn agentic execution
- **`PtcRunner.SubAgent.Signature`** - Functional contracts and validation

The LLM integration is callback-based with no external dependencies.

## Module Structure

```
lib/ptc_runner/
├── sub_agent.ex                 # Main API
└── sub_agent/
    ├── loop.ex                  # Agentic loop implementation
    ├── step.ex                  # Standard result structure
    ├── prompt.ex                # System prompt generation
    ├── signature.ex             # Signature parsing and validation
    ├── schema_extractor.ex      # Tool type extraction from @spec
    └── llm_tool.ex              # LLM-powered tool wrapper
```

---

## Architecture Overview

### Execution Flow (Step-wise Agentic Loop)

The Agentic Loop treats every LLM turn as a **Step**. The output of Turn N becomes the input (Context) for Turn N+1.

```
delegate/2
    │
    ├─► Prompt.generate/1 ──► Extract schemas from context + tools + tool_catalog
    │                         Generate system prompt with "Data Inventory"
    │
    └─► Loop.run/2
            │
            ├─► LLM callback ──► Returns program or text-reasoning
            │
            ├─► PtcRunner.Lisp.run/2 ──► Execute turn-program
            │       │
            │       └─► Result wrapped into a PtcRunner.Step
            │
            ├─► Turn Termination Check:
            │       ├─► (call "return" ...) ──► Stop, Return {:ok, step}
            │       └─► (call "fail" ...)   ──► Stop, Return {:error, step}
            │
            └─► Feedback & Turn Merge:
                    ├─► LLM History: Append Step.return (Public) + Signature
                    ├─► Lisp Context: Merge Step.return (Full) into ctx/
                    └─► Next Turn: Goto LLM callback
```


### Tool Normalization & Schema Extraction

All tools are normalized into a internal `Tool` representation. This ensures consistency between different registration syntaxes.

1.  **Function references** (`&Fun/n`): Extract `@spec` to populate `ToolSpec`.
2.  **String shorthand** (`{fun, "(...) -> ..."}`): Parser converts string to `ToolSpec`.
3.  **Explicit structs**: Pass `ToolSpec` or `LLMTool` directly.
4.  **SubAgent-as-Tool**: The sub-agent's signature is used as the tool's schema.

Generated schemas follow the `name(params) -> returns` format:
```
search(query :string, limit :int) -> [{:id :int :title :string}]
email-agent(prompt :string) -> {summary :string, count :int, _email_ids [:int]}
```

### Signature Type Syntax

PtcRunner uses a **hybrid schema system** based on [Malli](https://github.com/metosin/malli) (the dominant Clojure validation library). See [malli-schema.md](malli-schema.md) for the full specification.

**Two input formats are supported:**

1. **Shorthand strings** (recommended) - Compact, LLM-friendly
2. **Malli data** (advanced) - Full expressiveness for enums, unions, refinements

#### Shorthand Syntax

```
Primitives:
  :string :int :float :bool :keyword :any

Lists (homogeneous collections):
  [:int]                            ; list of integers
  [:string]                         ; list of strings
  [{:id :int :name :string}]        ; list of maps

Maps (typed fields):
  {:id :int :name :string}          ; map with required fields
  :map                              ; any map (untyped)

Optional Fields (use ? suffix):
  {:id :int :email :string?}        ; email is optional (nil allowed)
  {:count :int :items [:string]?}   ; items list is optional

Nested Structures:
  {:user {:id :int :profile {:bio :string}}}
```

**Important:** The `[:type]` syntax always means "list of type". For optional fields, use the `?` suffix on the type name.

#### Malli Data (Advanced)

For schemas that shorthand can't express, use Malli vectors directly:

```elixir
# Enum types
signature: [:=> [:cat :string] [:map
  [:status [:enum "pending" "active" "closed"]]
]]

# Union types
signature: [:=> [:cat :int] [:or :string :nil]]

# Constrained values
signature: [:=> [:cat] [:map
  [:score [:and :int [:> 0] [:< 100]]]
]]
```

The shorthand is transpiled to Malli data internally. Both formats use the same validation engine.

### Reserved Tool Names

The following tool names are reserved by the system and cannot be used in the `:tools` map:

- `return` - System tool for mission completion
- `fail` - System tool for mission failure

Attempting to register a tool with a reserved name will result in a `{:error, :reserved_tool_name}` error from `delegate/2`.


### tools vs tool_catalog

| Aspect | `tools` | `tool_catalog` |
|--------|---------|----------------|
| Schema in prompt | ✓ "Tools you can call" | ✓ "Tools for planning (do not call)" |
| Callable by agent | ✓ Yes | ✗ No |
| Use case | Execution tools | Planning visibility |

This separation enables planning agents to see what tools exist (with types) without being able to call them prematurely.

---

## API Specification

### PtcRunner.SubAgent

```elixir
defmodule PtcRunner.SubAgent do
  @moduledoc """
  Isolated mission execution with context efficiency.
 
  SubAgents execute missions using PTC-Lisp programs generated by an LLM.
  Each SubAgent runs in isolation with its own tools, context, and memory.

  ## Example

      llm = fn %{system: sys, messages: msgs} ->
        # Call your LLM provider
        {:ok, "```clojure\\n(call \\"get_data\\" {})\\n```"}
      end

      {:ok, step} = PtcRunner.SubAgent.delegate(
        "Find the top customer",
        llm: llm,
        tools: %{"get_customers" => &MyApp.get_customers/1}
      )
 
      step.return.summary  #=> "Top customer is Acme Corp with $1.2M revenue"
  """

  # ============================================================
  # Types
  # ============================================================

  @typedoc "LLM callback function"
  @type llm :: (llm_input() -> {:ok, String.t()} | {:error, term()})

  @typedoc "Input passed to LLM callback"
  @type llm_input :: %{
    required(:system) => String.t(),
    required(:messages) => [message()],
    optional(:turn) => pos_integer(),
    optional(:prompt) => String.t(),
    optional(:tool_names) => [String.t()],
    optional(:llm_opts) => map()
  }

  @typedoc "Conversation message"
  @type message :: %{
    required(:role) => :user | :assistant,
    required(:content) => String.t()
  }

  @typedoc "Tool function - receives args map, returns any term"
  @type tool :: (map() -> term())


  @typedoc "Successful Step result"
  @type result :: PtcRunner.Step.t()

  @typedoc "Error result"
  @type error :: PtcRunner.Step.t()

  # ============================================================
  # Main API
  # ============================================================

  @doc """
  Delegate a prompt to an isolated sub-agent.
 
  The sub-agent generates PTC-Lisp programs to accomplish the mission,
  executing them in a sandboxed environment with access to the
  provided tools.
 
  ## Required Options
 
  - `:llm` - Callback function for LLM calls (see `t:llm/0`)
 
  ## Options
 
  - `:signature` - Desired return structure: `"() -> {field :type}"`.
  - `:tools` - Map of callable tools (default: `%{}`)
  - `:tool_catalog` - Non-callable tools for planning (default: `%{}`)
  - `:context` - Values available as `ctx/` in PTC-Lisp (default: `%{}`)
  - `:context_signature` - Signature of the provided context for type propagation.
  - `:max_turns` - Maximum LLM calls before failing (default: `5`)
  - `:timeout` - Per-program execution timeout in ms (default: `5000`)
  - `:prompt_limit` - Max items/bytes shown in LLM prompt for Large Data. (default: `%{list: 5, string: 1000}`)
    - `:list` - Number of items shown from the start of a list. Truncated lists show total count and a system note.
    - `:string` - Number of bytes shown. Truncated strings show an ellipsis and a system note.
  - `:llm_retry` - Configuration for retrying LLM callback failures. (default: `%{max_attempts: 3, backoff: :exponential}`)
    - `:max_attempts` - Total attempts including the first one.
    - `:backoff` - `:exponential` or `:linear`.
    - `:retryable_errors` - List of error reasons to retry (e.g., `[:rate_limit, :timeout]`). If not provided, all `{:error, reason}` are retried.
 
  ## Prompt Placeholder Validation
 
  For `delegate/2`, the provided `prompt` string may contain `{{template}}` placeholders.
  These placeholders are validated against the `context` map before execution starts.
  If a placeholder is missing from the context, `delegate/2` returns an error early.
 
  ## Usability Improvements
 
  - **Shorthand Signatures**: You can omit the `() -> ` prefix if a mission has no inputs.
    `signature: "{count :int}"` is equivalent to `signature: "() -> {count :int}"`.
  - **Auto-Chaining**: Passing a `PtcRunner.Step` struct directly to `:context` automatically
    populates both `:context` (with `step.return`) and `:context_signature` (with `step.signature`).
 
  ## Return Value
 
  On success, returns `{:ok, %PtcRunner.Step{}}`.
  On failure, returns `{:error, %PtcRunner.Step{}}`.
 
  ## Examples
 
      # Basic usage
      {:ok, step} = PtcRunner.SubAgent.delegate(
        "List all products",
        llm: my_llm,
        tools: %{"get_products" => &Shop.list_products/1}
      )
 
      # With signature for chaining
      {:ok, step1} = PtcRunner.SubAgent.delegate(
        "Find urgent emails",
        signature: "() -> {count :int, _email_ids [:int]}",
        llm: my_llm,
        tools: email_tools
      )
 
      # Pass results to next step via context_signature
      {:ok, step2} = PtcRunner.SubAgent.delegate(
        "Draft replies",
        llm: my_llm,
        tools: draft_tools,
        context: step1.return,
        context_signature: step1.signature
      )
  """
  @spec delegate(String.t(), keyword()) :: {:ok, result()} | {:error, error()}
  def delegate(prompt, opts)

  @doc """
  Wrap a SubAgent or Prompt configuration as a callable tool.
 
  Tools are either "Judgment Tools" (single-turn) or "Agent Tools" (multi-turn).
  The distinction is implicit: if `tools:` is provided, it's an Agent Tool.
 
  ## Configuration
 
  - `:prompt` - Required. Templated string mission (e.g., `"Summarize {{text}}"`).
  - `:signature` - Required. Input and Output contract. Inputs must match placeholders.
  - `:llm` - Required. LLM callback.
  - `:tools` - Optional. If provided, the tool executes as a multi-turn SubAgent.
 
  ## Example
 
      email_tool = PtcRunner.SubAgent.as_tool(
        prompt: "Find emails matching: {{query}}",
        signature: "(query :string) -> {count :int, _email_ids [:int]}",
        llm: my_llm,
        tools: email_tools
      )
 
  `email_tool(query :string) -> {count :int, _email_ids [:int]}`
 
  ## Tool Definition Syntaxes
 
  Tools can be registered in three ways:
 
  3. **Function References**: Supported for existing Elixir code. Type info is
     extracted via `@spec`.

  ### Execution Behavior

  When an `as_tool` wrapped function is called:
  - **On Success**: Returns the `return` value from the `Step` struct. Firewalled fields are included in the return value (as it's the execution layer) but are hidden if the tool is itself called by another LLM.
  - **On Failure**: Raises a `PtcRunner.SubAgent.Error` containing the `Step` struct. This allows PTC-Lisp to catch the error or for it to be reported back to a parent LLM as a `tool_error`.
  """
  @spec as_tool(keyword() | map()) :: tool()
  def as_tool(opts_or_map)

end
```

---

### PtcRunner.SubAgent.Loop

```elixir
defmodule PtcRunner.SubAgent.Loop do
  @moduledoc """
  Multi-turn agentic execution loop.

  Manages the conversation between LLM and PTC-Lisp interpreter:
 
  1. LLM generates a program (Turn Turn)
  2. Program is executed and wrapped in a `PtcRunner.Step`.
  3. Step results (Public) are fed back to LLM history.
  4. Step results (Full) are merged into `ctx/` for the next Turn.
  5. Repeat until the LLM calls `return` or `fail` tools.
 
  ## Features
 
  - **Implicit Chaining**: Every turn's results are merged into context.
  - **Strict Termination**: Mission only ends on explicit `return`/`fail`.
  - **Built-in System Tools**: See [System Tools](#system-tools) for schemas.
  - **Data Privacy**: Firewalled data (`_`) is hidden in history but available in Lisp.
  - **Boundary Reminders**: Auto-prompts if the LLM provides text without a program.
  """

  @doc """
  Run the agentic loop until completion or failure.

  ## Options
 
  - `:llm` - Required. LLM callback function
  - `:tools` - Tool functions (default: `%{}`)
  - `:context` - Initial context values (default: `%{}`)
  - `:memory` - Initial memory state (default: `%{}`)
  - `:max_turns` - Maximum iterations (default: `5`)
  - `:timeout` - Per-program timeout (default: `5000`)
  - `:system_prompt` - Override default prompt
  - `:prompt_limit` - Truncation limits for Large Data.
 
  ## Return Value
  
      {:ok, %PtcRunner.Step{}}
      {:error, %PtcRunner.Step{}}
  """
  @spec run(String.t(), keyword()) ::
    {:ok, PtcRunner.Step.t()} |
    {:error, PtcRunner.Step.t()}
  def run(prompt, opts)
end
```
 
---
 
## System Tools

These tools are injected into every SubAgent loop and are used for mission termination.

### `return(data :any)`

Fulfills the mission contract.
- **Arguments**: Any value matching the output portion of the mission's signature.
- **Effect**: Terminates the loop and returns `{:ok, step}`.
- **Validation**: If `data` doesn't match the mission's `:signature`, the error is fed back to the LLM for self-correction. This does NOT consume the retry budget (see [LLM Retry Scope](#llm-retry-scope)).

### `fail(params {reason :keyword, message :string, op :string?, details :map?})`

Terminates the mission with an error.
- **Arguments**: A map with:
  - `reason` (required): Machine-readable error keyword (e.g., `:not_found`, `:permission_denied`)
  - `message` (required): Human-readable error description
  - `op` (optional): Name of the operation/tool that failed
  - `details` (optional): Additional context map
- **Effect**: Terminates the loop and returns `{:error, step}` with `step.fail` populated.

---

### PtcRunner.SubAgent.Signature
 
```elixir
defmodule PtcRunner.SubAgent.Signature do
  @moduledoc """
  Functional contracts for Agents and Tools.
  """
 
  @doc """
  Parses a signature string into a structured spec.
  Handles '->' extraction for context propagation.
  """
  @spec parse(String.t()) :: {:ok, map()} | {:error, term()}
  def parse(sig_string)
 
  @doc """
  Extracts ONLY the return part of a signature.
  Used by 'context_signature' to propagate types from Step 1 to Step 2.
 
  If a full signature `(args) -> returns` is provided, it extracts the `returns` portion.
  If a partial signature `{field :type}` is provided, it is used as-is.
  """
  @spec extract_return_spec(String.t()) :: String.t()
  def extract_return_spec(full_signature)
end
```


---

### PtcRunner.SubAgent.LLMTool

```elixir
defmodule PtcRunner.SubAgent.LLMTool do
  @moduledoc """
  LLM-powered tool wrapper for classification, evaluation, and judgment.

  Creates tools that call an LLM with a templated prompt and parse
  structured responses. Useful when a tool needs reasoning rather
  than deterministic computation.

  ## Example

      tools = %{
        "evaluate" => LLMTool.new(
          prompt: "Is this email urgent? Subject: {{subject}}",
          signature: "(subject :string) -> {urgent :bool, reason :string}"
        )
      }

  The tool can then be called like any other:

      (call "evaluate" {:subject "Server down!"})
      ;; => {:urgent true :reason "Production issue"}
  """

  @type llm_ref :: :caller | atom() | (map() -> {:ok, String.t()} | {:error, term()})

  @type t :: %__MODULE__{
    prompt: String.t(),
    signature: String.t(),
    llm: llm_ref(),
    description: String.t() | nil,
    tools: map() | nil
  }

  defstruct [:prompt, :signature, :llm, :description, :tools]

  @doc """
  Create a new LLM-powered tool.
 
  ## Schema Generation
 
  LLMTool automatically generates a typed schema from:
  - **Inputs**: Extracted from `{{var}}` template placeholders
  - **Outputs**: From the `:signature` specification
 
  Example:
      LLMTool.new(
        prompt: "Is {{email.subject}} urgent for {{customer_tier}} customer?",
        signature: "(email {subject :string}, customer_tier :string) -> {urgent :bool, reason :string}"
      )
 
  Generates schema:
      evaluate(email {:subject :string}, customer_tier :string) -> {urgent :bool, reason :string}
 
  ## Options
 
  - `:prompt` - Required. Template string with `{{var}}` placeholders.
  - `:signature` - Required. The functional contract string.
  - `:llm` - Optional. LLM to use:
    - `:caller` (default) - Use the SubAgent's LLM
    - Atom (e.g., `:haiku`) - Look up from model registry
    - Function - Use directly as LLM callback
  - `:description` - Optional. Description for schema generation.
  - `:tools` - Optional. If provided, the tool executes as a multi-turn SubAgent.

  ## Examples

      # Simple classification (uses caller's LLM)
      LLMTool.new(
        prompt: "Is {{text}} positive or negative?",
        signature: "(text :string) -> {sentiment :string, confidence :float}"
      )

      # Batch processing with cheaper model
      LLMTool.new(
        prompt: "Classify urgency for each: {{#items}}{{subject}}{{/items}}",
        signature: "(items [{subject :string}]) -> [{id :int, urgency :string}]",
        llm: :haiku
      )

      # With explicit LLM callback
      LLMTool.new(
        prompt: "...",
        signature: "...",
        llm: fn input -> MyLLM.call(input) end
      )
  """
  @spec new(keyword()) :: t()
  def new(opts)
end
```

---

### Tool Configuration (Unified Model)
 
Tools are defined as maps. The system automatically promotes them to "Judgment Tools" or "Agent Tools" based on the presence of `tools:`.
 
```elixir
# Single-turn Judgment Tool
"classifier" => %{
  prompt: "Is {{text}} positive?",
  signature: "(text :string) -> {is_positive :bool}"
}
 
# Multi-turn Agent Tool
"researcher" => %{
  prompt: "Conduct research on {{topic}}",
  signature: "(topic :string) -> {summary :string, _refs [:map]}",
  tools: web_search_tools,
  llm: high_res_model
}
```
 
### Nested Data & Expansion
 
Signatures support nesting, and prompts can use dot-notation for expansion.
 
```elixir
"profile-agent" => %{
  prompt: "Analyze profile for {{user.name}} (ID: {{user.id}})",
  signature: "(user {name :string, id :int}) -> {summary :string}"
}
```
 
4.  **Tool Call Format**: Tools must be called with a map for arguments: `(call "tool" {:arg1 val1})`. Positional arguments `(call "tool" val1 val2)` are not supported and will trigger a `:validation_error`.
5.  **Implicit Conversion**: PTC-Lisp `(call "tool" {...})` arguments are converted to the signature types (e.g., string to int) if possible.

### Template Syntax

The `prompt` and `LLMTool` prompts use a Mustache-style template syntax:

- `{{var}}`: Interpolates value from context.
- `{{#list}}...{{/list}}`: Iterates over a list.
  - **Empty Lists**: If the list is empty, the entire block renders as an **empty string**.
- `{{a.b}}`: Accesses nested map keys.

---

## LLM Callback Contract

The LLM callback is the integration point for any LLM provider.

### Signature

```elixir
@spec llm_callback(input :: map()) :: {:ok, String.t()} | {:error, term()}
```

### The System Prompt

The system prompt is generated by `PtcRunner.SubAgent.Prompt` and includes:

1.  **Core Instructions**: Defining the agent's role as a PTC-Lisp generator.
2.  **PTC-Lisp documentation**: A concise reference of the available language features (Clojure-subset, `call`, `ctx/`, `memory/`, `do`, `let`, etc.) to ensure the LLM uses valid syntax.
3.  **Data Inventory**: Typed view of the current `ctx/` variables (omitting firewalled values).
4.  **Tool Definitions**: Typed schemas of available tools.
5.  **Output Requirements**: Strict instructions to use ` ```clojure ` blocks for programs.

### LLM Input Structure

```elixir
%{
  system: "You are a PTC-Lisp agent. [PTC-Lisp instructions...] [Data Inventory...] [Tools...]",
  messages: [
    %{role: :user, content: "Find urgent emails"},
    # ...
  ]
}
```

### Output

- **Success:** `{:ok, "LLM response text"}` - May contain code blocks or final answer
- **Error:** `{:error, reason}` - Any error term

### Example Implementation

```elixir
# Minimal example (for testing)
fn %{system: _system, messages: messages} ->
  # Echo back a simple program
  {:ok, ~s'```clojure\n(+ 1 2)\n```'}
end

# With an HTTP-based LLM
fn %{system: system, messages: messages} ->
  body = %{
    model: "gpt-4",
    messages: [
      %{"role" => "system", "content" => system}
      | Enum.map(messages, fn %{role: r, content: c} ->
          %{"role" => to_string(r), "content" => c}
        end)
    ]
  }

  case Req.post("https://api.openai.com/v1/chat/completions",
         json: body,
         headers: [{"Authorization", "Bearer #{api_key}"}]) do
    {:ok, %{status: 200, body: %{"choices" => [%{"message" => %{"content" => text}} | _]}}} ->
      {:ok, text}
    {:ok, %{status: status, body: body}} ->
      {:error, {:api_error, status, body}}
    {:error, reason} ->
      {:error, reason}
  end
end
```

## Memory Operations
 
Per-agent scoped memory via PTC-Lisp:
 
```clojure
(memory/put :key value)    ; Store value
(memory/get :key)          ; Retrieve value
memory/key                 ; Shorthand access
```

### Memory & Resource Limits

To prevent resource exhaustion, the following default limits are enforced:

- **Memory Size**: A single SubAgent's memory map is limited to **1MB** (Erlang external term format serialized size). Attempting to `put` a value that exceeds this limit results in a `:memory_exceeded` error.
- **Nested Depth**: SubAgents can spawn other SubAgents (via `as_tool` or `delegate`). The maximum nesting depth is **3 levels** (root agent → child → grandchild → great-grandchild). Exceeding this returns `{:error, :max_depth_exceeded}`.
- **Total Turn Budget**: A mission tree (including all nested agents) shares a total budget of **20 turns**. The budget is passed down and decremented by each nested agent. When exhausted, returns `{:error, :turn_budget_exhausted}`.

### Tool Error Handling Convention

Tools can signal errors in three ways:

1. **Raise an exception** (recommended for bugs):
   ```elixir
   "get_user" => fn args ->
     case MyApp.get_user(args["id"]) do
       nil -> raise "User not found"  # Becomes :eval_error, fed back to LLM
       user -> user
     end
   end
   ```

2. **Return an error map** (recommended for expected failures):
   ```elixir
   "get_user" => fn args ->
     case MyApp.get_user(args["id"]) do
       nil -> %{error: :not_found, message: "User does not exist"}
       user -> user
     end
   end
   ```
   The LLM can inspect the result and handle accordingly.

3. **Return `{:error, reason}` tuple** (treated as regular return value):
   ```elixir
   "get_user" => fn args ->
     MyApp.get_user(args["id"])  # Returns {:ok, user} or {:error, reason}
   end
   ```
   The tuple is returned as-is to the Lisp context. The LLM must destructure it.

**Recommendation:** Use error maps for expected failures (user not found, validation failed) so the LLM can reason about them. Use exceptions for unexpected bugs that should halt execution.

---

## Configuration & Registry

### LLM Registry

When using `llm: :atom` (e.g., `llm: :haiku`), the system looks up the model in the `PtcRunner.Config` model registry.

```elixir
# Configuration in config/config.exs
config :ptc_runner, :models, %{
  haiku: [
    module: PtcRunner.SubAgent.LLM.Anthropic,
    model: "claude-3-haiku-20240307",
    max_tokens: 1000
  ],
  gpt4: [
    module: PtcRunner.SubAgent.LLM.OpenAI,
    model: "gpt-4-turbo"
  ]
}
```

If a requested model is not in the registry, `delegate/2` returns a `{:error, :model_not_found}` error.

---

## Observability & Telemetry

### Telemetry Events

The following events are emitted via the `:telemetry` library:

- `[:ptc, :subagent, :mission_start]` - Base mission started.
- `[:ptc, :subagent, :turn_start]` - Single turn execution started.
- `[:ptc, :subagent, :turn_stop]` - Turn completed (with usage and success/fail).
- `[:ptc, :subagent, :mission_stop]` - Total mission completed.

### Tracing

Each `Step` struct contains a `:trace` field, which is a list of all turns executed, including the generated programs, tool calls, and results. This trace is essential for debugging multi-turn agent behavior.

---

## Concurrency & Safety

SubAgents are designed for safe concurrent execution:

- **Isolation**: Each `delegate/2` call runs in its own process (or task). Memory and context are not shared between concurrent missions.
- **Thread-Safety**: The Tool registry and Signature parser are read-only at runtime and are thread-safe.
- **Side Effects**: Tools may have side effects (e.g., database writes). It is the developer's responsibility to ensure these side effects are idempotent or handled via transactions if multiple SubAgents are running concurrently against the same data.

---

## Validation Options

Validation options control how strictly the SubAgent enforces type and signature checks.

```elixir
PtcRunner.SubAgent.delegate(prompt,
  tools: tools,
  signature_validation: :enabled  # default
)
```

| Option | Behavior |
|--------|----------|
| `:enabled` | Validate inputs and outputs, fail on errors (default) |
| `:warn_only` | Validate, log warnings but continue execution |
| `:disabled` | Skip all validation |
| `:strict` | Like `:enabled`, plus: fail if any tool lacks a spec, or if context is missing required signature keys |

### Signature Validation Strictness

When validating return data against a signature:

- **Required fields**: Must be present and match type
- **Optional fields** (`:type?`): May be `nil` or absent
- **Extra fields**: Allowed by default (lenient). Use `:strict` mode to reject extra fields.

Example:
```elixir
# Signature: () -> {:count :int}
# LLM returns: {:count 5 :extra "bonus"}

# :enabled mode  -> {:ok, step}  (extra fields allowed)
# :strict mode   -> {:error, step} with :validation_error (extra fields rejected)
```

### LLM Retry Scope

The `:llm_retry` option controls retry behavior for LLM callback failures:

```elixir
llm_retry: %{
  max_attempts: 3,           # Total attempts including first
  backoff: :exponential,     # :exponential or :linear
  retryable_errors: [:rate_limit, :timeout, :server_error]  # Optional filter
}
```

**What counts as a retry:**
- LLM callback returns `{:error, reason}` → Retries (if reason matches filter)
- LLM callback raises exception → Retries
- Network timeout → Retries

**What does NOT consume retry budget:**
- Signature validation failure (LLM returned bad data) → Error fed back to LLM as next turn
- Lisp syntax error → Error fed back to LLM as next turn
- Tool execution error → Error fed back to LLM as next turn

These are "soft failures" that the LLM can self-correct. They consume the `:max_turns` budget instead.

### Zero-Argument Tool Calls

Tools with no arguments can be called with or without an empty map:

```clojure
(call "get_time" {})   ; Explicit empty map
(call "get_time")      ; Shorthand (equivalent)
```

Both forms are valid. The tool function receives an empty map `%{}` in either case.

---

## Quick Reference: Delegation Options

| Option | Type | Default | Description |
| :--- | :--- | :--- | :--- |
| `:llm` | `(map -> result)` | **Required** | LLM callback or registry atom. |
| `:prompt` | `string` | N/A | Mission description (with `{{templates}}`). |
| `:signature` | `string` | `"() -> :any"` | Functional contract. |
| `:tools` | `map` | `%{}` | Collection of callable tools. |
| `:context` | `map` | `%{}` | Data available in `ctx/`. |
| `:context_signature` | `string` | `nil` | Type propagation for context. |
| `:max_turns` | `integer` | `5` | Stop if mission doesn't end. |
| `:timeout` | `integer` | `5000` | Max ms per PTC-Lisp program. |
| `:mission_timeout`| `integer` | `60000` | Max total duration of mission. |
| `:prompt_limit` | `map` | `%{list: 5...}`| Truncation limits for prompt. |
| `:llm_retry` | `map` | `%{...}` | Retry configuration for LLM calls. |

---

### LLM Response Parsing Rules

The SubAgent loop accepts LLM responses in several formats:

1.  **Code Blocks**: Recommended. The loop searches for ` ```clojure ` or ` ```lisp ` blocks. If multiple blocks exist, they are executed sequentially in a `do` block.
2.  **Plain Code**: If no code blocks are found but the text looks like a PTC-Lisp program (starts with `(`), it's parsed as code.
3.  **Reasoning + Code**: Text before or after code blocks is allowed and ignored by the evaluator (though it may be stored in the trace).
4.  **No Code**: If no program is found, the system triggers a **Boundary Reminder**, asking the LLM to Provide its next steps in a code block.

---

### Chaining & Failures

#### Auto-Chaining with Step Structs

When a `PtcRunner.Step` struct is passed directly to `:context`, the system automatically extracts:
- `context: step.return` - The return data becomes the context
- `context_signature: step.signature` - Type information is propagated

```elixir
# These are equivalent:
delegate(prompt, context: step1.return, context_signature: step1.signature)
delegate(prompt, context: step1)  # Auto-extracts from Step struct
```

#### Auto-Chaining with Failed Steps

If a failed step (`{:error, step}`) is passed to `:context`, `delegate/2` fails immediately:
- Returns `{:error, %Step{fail: %{reason: :chained_failure, ...}}}`
- The original failure is preserved in `step.fail.details.original_failure`

This prevents accidentally chaining onto failed states. To explicitly handle failures:
```elixir
case step1 do
  {:ok, step} -> delegate(prompt, context: step)
  {:error, step} -> handle_failure(step)
end
```

### Error Reasons Reference

Complete list of error reasons returned in `step.fail.reason`:

| Reason | Source | Description |
|--------|--------|-------------|
| `:parse_error` | Lisp | Invalid PTC-Lisp syntax |
| `:analysis_error` | Lisp | Semantic error (undefined variable, etc.) |
| `:eval_error` | Lisp | Runtime error (division by zero, etc.) |
| `:timeout` | Both | Execution exceeded time limit |
| `:memory_exceeded` | Both | Process exceeded heap limit |
| `:validation_error` | Both | Input or output doesn't match signature |
| `:tool_error` | SubAgent | Tool raised an exception |
| `:tool_not_found` | SubAgent | Calling non-existent tool |
| `:reserved_tool_name` | SubAgent | Attempted to register `return` or `fail` |
| `:max_turns_exceeded` | SubAgent | Turn limit reached without termination |
| `:max_depth_exceeded` | SubAgent | Nested agent depth limit exceeded |
| `:turn_budget_exhausted` | SubAgent | Total turn budget (20) exhausted across mission tree |
| `:mission_timeout` | SubAgent | Total mission duration exceeded |
| `:llm_error` | SubAgent | LLM callback failed after all retries |
| `:model_not_found` | SubAgent | LLM registry lookup failed for atom reference |
| `:chained_failure` | SubAgent | Attempted to chain onto a failed step |
| `:template_error` | SubAgent | Template placeholder missing from context |
| Custom atoms | SubAgent | From `(call "fail" {:reason :custom ...})` |

---

## Test Strategy
 
### Unit Tests
 
```elixir
# Signature
test "parses signature string"
test "validates prompt placeholders match signature inputs"
test "extracts return part for context_signature"
test "handles nested signature types"
 
# Loop
test "single-turn completion via return tool"
test "multi-turn with tool calls and context merging"
test "feedback loop with public vs private visibility"
test "oversion/truncation of large results in prompt"
test "boundary reminder on plain text response"
test "max_turns terminates loop"
 
# SubAgent
test "delegate with prompt and signature"
test "implicit promotion of map to tool"
test "nested SubAgents (tools in tool config)"
 
# Prompt
test "generates tools section with schemas"
test "extracts @spec from function references"
```
```

### Integration Tests

```elixir
# With real LLM (optional, behind flag)
test "end-to-end mission delegation"
test "chained SubAgents pass data"
test "plan generation via create_plan tool"
test "tool_catalog schemas visible but not callable"
test "multi-turn ReAct pattern with memory"
test "LLMTool classification in agentic loop"
```

### Known LLM Behavior Issues

From spike testing with Gemini 2.5 Flash:

1. **Missing functions**: LLM tries `(str ...)` and `(conj ...)` which are currently missing
2. **Data Path Confusion**: Uses `[:result :id]` instead of `[:result 0 :id]` for list-wrapped results
3. **Invalid comparators**: Uses `(sort-by :total >)` but `>` isn't a valid comparator function

**Mitigations:**
- Add `str` and `conj` to `PtcRunner.Lisp.Runtime`
- Add numeric safety (handling `nil` in arithmetic)
- Add custom comparator support to `sort-by`

---

## Migration from Spike
 
The spike code in `demo/lib/ptc_demo/` should be:
 
1. **Moved to core:** `AgenticLoop` → `PtcRunner.SubAgent.Loop`
2. **Standardized:** Replace `RefExtractor` with `PtcRunner.SubAgent.Signature`
3. **Adapted:** `SubAgent` → `PtcRunner.SubAgent` (remove ReqLLM dependency)

---

## Open Questions

1. **Usage extraction:** How to extract token counts from LLM callback?
   - Option A: Callback returns `{:ok, text, usage}`
   - Option B: Separate `:usage_callback` option
   - Option C: Don't track (demo concern only)

2. **Streaming:** Should the callback support streaming?
   - Probably out of scope for v1

3. **System prompt customization:** Full override or composable parts?

---

## Future Work

### CLI Commands

Interactive SubAgent commands for the demo CLI:

```
> /subagent "Find the employee with highest expenses"
[SubAgent] Executing: (-> (call "get_expenses") ...)
[SubAgent] Result: "John Smith - $12,450"

> /subagent:verbose "Find top 3 products"
[SubAgent] Shows full trace with programs and tool calls
```

### Tool Discovery

For large tool registries (50+ tools), let SubAgents discover relevant tools:

```elixir
{:ok, result} = PtcRunner.ToolDiscovery.run(
  "Analyze travel expenses for Q3",
  llm: llm,
  registry: all_company_tools  # 100+ tools
)

# Discovery agent finds and uses only: get_expenses, get_categories, sum_by
```

### Plan Persistence

Save and resume plans:

```elixir
# File-based
Plan.save(plan, "plans/workflow-001.json")
{:ok, plan} = Plan.load("plans/workflow-001.json")

# GitHub Issues (collaborative, auditable)
{:ok, plan} = Plan.from_github_issue("owner/repo", 275)
Plan.sync_to_github(plan)  # Updates issue with execution history
```

### Parallel SubAgents

Run multiple SubAgents concurrently:

```elixir
prompts = [
  {"Jira", "Summarize sprint status", jira_tools},
  {"Slack", "Check urgent mentions", slack_tools},
  {"GitHub", "List PRs needing review", github_tools}
]

results =
  prompts
  |> Task.async_stream(fn {name, prompt, tools} ->
    {:ok, step} = PtcRunner.SubAgent.delegate(prompt, llm: llm, tools: tools)
    {name, step.summary}
  end, max_concurrency: 3)
  |> Enum.map(fn {:ok, result} -> result end)
```

**Note:** Memory isolation (scoped scratchpad) enables safe parallel execution.

---

## Planned Features

The following features are planned for future versions:

### Dry Run Mode

Validate configuration without execution:

```elixir
{:ok, _} = SubAgent.validate(prompt,
  signature: sig,
  tools: tools,
  context: ctx
)
```

Catches errors early:
- Missing template placeholders
- Invalid signatures
- Reserved tool name conflicts
- Type mismatches in context vs signature

### Cost Budget Option

Limit maximum spend per mission:

```elixir
delegate(prompt,
  llm: llm,
  max_cost_usd: 0.50  # Fail if estimated cost exceeds
)
```

Requires LLM callback to return usage information.

### Consecutive Failure Limit

Fail fast when LLM keeps generating errors:

```elixir
delegate(prompt,
  max_turns: 10,
  max_consecutive_failures: 3  # Stop after 3 failures in a row
)
```

Distinguishes between "making progress with occasional errors" and "stuck in error loop".

### Per-Tool Validation Mode

Allow different validation strictness per tool:

```elixir
tools = %{
  "strict_api" => {&func/1, signature, validation: :strict},
  "lenient_tool" => {&func/1, signature, validation: :warn_only}
}
```

### Checkpoint/Resume

Save mission state for long-running tasks:

```elixir
{:ok, step} = delegate(prompt,
  checkpoint_dir: "/tmp/missions/",
  resume_from: "checkpoint-5.etf"
)
```

Enables:
- Resume after crash
- Inspection of intermediate states
- Long-running mission persistence

---

## Design Decisions

This section documents key design decisions and their rationale.

### DD-1: Optional Field Syntax (`?` suffix)

**Decision:** Use `:type?` suffix for optional fields instead of overloading `[:type]`.

**Rationale:** The `[:type]` syntax is already used for "list of type". Using it for optionals creates ambiguity:
```
# Ambiguous: is this "optional string" or "list of strings"?
{:email [:string]}
```

The `?` suffix is explicit and common in other languages:
```
{:email :string?}   # Clearly optional
{:tags [:string]}   # Clearly a list
```

### DD-2: Reserved Tool Names Error at Registration

**Decision:** Fail at registration time if user tries to register `return` or `fail` tools.

**Rationale:** Failing early (at `delegate/2` call) is better than runtime surprises. The error message can clearly explain why these names are reserved.

### DD-3: Lenient Extra Fields by Default

**Decision:** Allow extra fields in return data by default (`:enabled` mode).

**Rationale:** Strict rejection of extra fields would cause frequent failures when LLMs add helpful metadata. Lenient validation focuses on "did we get what we needed?" rather than "did we get exactly what we expected?". Use `:strict` mode when exact compliance is required.

### DD-4: Soft Failures Don't Consume Retry Budget

**Decision:** LLM retries are only for callback failures, not for logic errors.

**Rationale:** There are two types of failures:
1. **Infrastructure failures** (rate limits, timeouts) - These should retry automatically
2. **Logic failures** (bad syntax, wrong output) - These should be fed back to LLM for self-correction

Conflating them would waste retries on issues the LLM can fix itself, or exhaust turn budget on issues outside LLM control.

### DD-5: Tool Error Handling via Conventions

**Decision:** Document conventions for tool error handling rather than enforcing a specific pattern.

**Rationale:** Different use cases need different patterns:
- Quick scripts: Let exceptions propagate
- Production: Return error maps for LLM reasoning
- Elixir idioms: Return `{:ok, _} | {:error, _}` tuples

Enforcing one pattern would conflict with existing code patterns.

### DD-6: Auto-Chaining with Step Detection

**Decision:** Automatically extract `return` and `signature` when a `Step` struct is passed to `:context`.

**Rationale:** The common pattern of chaining steps requires repetitive code:
```elixir
delegate(prompt, context: step1.return, context_signature: step1.signature)
```

Auto-detection reduces boilerplate while remaining explicit (you're passing a Step, not a plain map).

### DD-7: Erlang Term Format for Memory Size Limit

**Decision:** Use Erlang external term format (`:erlang.term_to_binary/1`) for measuring memory size.

**Rationale:**
- Consistent with BEAM process heap measurement
- More accurate than JSON for Elixir data structures
- Handles all Elixir types (tuples, atoms, binaries)

---

### DD-8: Malli-based Schema System

**Decision:** Use Malli-subset as the internal schema representation, with shorthand syntax as the primary API.

**Rationale:**
- **Ecosystem fit**: PTC-Lisp is Clojure-like; Malli is the dominant Clojure validation library
- **Schema-as-data**: Malli schemas are vectors/maps - native PTC-Lisp data structures that agents can manipulate
- **Expressiveness**: Supports enums, unions, refinements that shorthand can't express cleanly
- **Token efficiency**: Shorthand `{count :int}` is 50% fewer tokens than Malli `[:map [:count :int]]`

The hybrid approach gives 90% of users a clean, simple API while providing an escape hatch for advanced schemas. See [malli-schema.md](malli-schema.md) for implementation details.

---

## Related Documents

- [malli-schema.md](malli-schema.md) - Malli-lite schema system specification
- [tutorial.md](tutorial.md) - Planned SubAgent API and usage examples
- [api-unification.md](api-unification.md) - Planned changes to unify Lisp and SubAgent APIs
- [spike-summary.md](spike-summary.md) - Spike validation results and learnings

[PtcRunner Guide](../guide.md) - Core PTC-Lisp documentation
