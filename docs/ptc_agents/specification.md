# PtcRunner.SubAgent Specification

> **Status:** Draft (branch: `spike-subagent`)

This document specifies the SubAgent API for the PtcRunner library.

---

## Table of Contents

1. [Overview](#overview)
2. [Module Structure](#module-structure)
3. [Core API](#core-api)
   - [SubAgent.new/1](#subagentnew1)
   - [SubAgent.run/2](#subagentrun2)
   - [SubAgent.run!/2 and then!/2](#subagentrun2-and-then2)
   - [SubAgent.as_tool/2](#subagentas_tool2)
   - [SubAgent.compile/2](#subagentcompile2)
4. [Chaining Patterns](#chaining-patterns)
5. [LLM Inheritance](#llm-inheritance)
6. [Execution Loop](#execution-loop)
   - [Loop.run/2](#looprun2)
   - [System Tools](#system-tools)
7. [Tool Registration](#tool-registration)
   - [Tool Formats](#tool-formats)
   - [LLMTool](#llmtool)
   - [Reserved Names](#reserved-names)
8. [Signatures & Validation](#signatures--validation)
9. [Templates](#templates)
10. [LLM Callback](#llm-callback)
11. [Memory Operations](#memory-operations)
12. [Debugging & Introspection](#debugging--introspection)
   - [Step.trace Structure](#steptrace-structure)
   - [Debug Mode](#debug-mode)
   - [Prompt Preview](#prompt-preview)
   - [Telemetry Hooks](#telemetry-hooks)
13. [Configuration](#configuration)
14. [Design Decisions](#design-decisions)

---

## Overview

A SubAgent is an isolated worker that executes tasks using PTC-Lisp programs generated by an LLM.

**Key concepts:**
- **Prompt:** A template describing what to accomplish (supports `{{placeholder}}` expansion)
- **Signature:** Contract defining expected inputs and outputs
- **Tools:** Functions the agent can call
- **Step:** Result struct containing return value, metrics, and trace

**Design philosophy:**
- **Agents as data:** SubAgents are defined as structs, enabling composition and delayed execution
- **Separation of definition and execution:** Static config (prompt, signature, tools) vs runtime params (llm, context)
- **LLM inheritance:** Child agents can inherit the parent's LLM unless overridden

**Module structure:**
```
lib/ptc_runner/
├── sub_agent.ex              # Main API
├── step.ex                   # Shared result struct
└── sub_agent/
    ├── loop.ex               # Agentic loop
    ├── prompt.ex             # System prompt generation
    ├── signature.ex          # Signature parsing
    └── llm_tool.ex           # LLM-powered tools
```

---

## Core API

The SubAgent API consists of functions for definition, execution, and composition.

---

### SubAgent.new/1

Creates a SubAgent struct (agent as data). No LLM is called - this just defines the agent.

```elixir
@spec new(keyword()) :: SubAgent.t()
def new(opts)
```

**Struct fields (static definition):**

| Field | Type | Description |
|-------|------|-------------|
| `prompt` | `String.t()` | Template with `{{placeholder}}` support |
| `signature` | `String.t()` | Contract for inputs/outputs |
| `tools` | `map()` | Callable tools |
| `max_turns` | `pos_integer()` | Maximum LLM calls (default: 5) |
| `tool_catalog` | `map()` | Schemas for planning (not callable) |
| `prompt_limit` | `map()` | Truncation config for LLM view |
| `mission_timeout` | `pos_integer()` | Max ms for entire execution |
| `llm_retry` | `map()` | Retry config for LLM failures |
| `llm` | `atom() \| function()` | Optional LLM override (for inheritance) |

**Example:**
```elixir
# Define a reusable agent
email_finder = SubAgent.new(
  prompt: "Find urgent emails for {{user}}",
  signature: "(user :string) -> {count :int, _ids [:int]}",
  tools: email_tools,
  max_turns: 5
)

# Execute later with runtime params
{:ok, step} = SubAgent.run(email_finder, llm: llm, context: %{user: "alice"})
```

---

### SubAgent.run/2

Executes a SubAgent. Always takes a SubAgent struct (or string for convenience).

```elixir
@spec run(SubAgent.t() | String.t(), keyword()) :: {:ok, Step.t()} | {:error, Step.t()}
def run(agent, opts \\ [])
```

**Runtime options:**

| Option | Type | Description |
|--------|------|-------------|
| `llm` | `atom() \| function()` | Required unless agent has `llm` set |
| `context` | `map() \| Step.t()` | Input data available as `ctx/` |
| `llm_opts` | `map()` | Per-call LLM options (temperature, etc.) |
| `context_signature` | `String.t()` | Type info for context (auto-set if `Step` passed) |

**Convenience form:** When first argument is a string, struct fields can be passed in opts:
```elixir
# These are equivalent:
SubAgent.run(SubAgent.new(prompt: "Find {{x}}", signature: "..."), llm: llm)
SubAgent.run("Find {{x}}", signature: "...", llm: llm)
```

**Execution Modes:**

| Mode | Trigger | Behavior |
|------|---------|----------|
| **Judgment** | `max_turns: 1`, no tools | Single turn, expression result returned directly |
| **Agent** | `max_turns > 1` or `tools` | Multi-turn, requires explicit `(call "return" ...)` |

**Mode State Machine:**

```
┌─────────────────────────────────────────────────────────────────┐
│                    MODE DETERMINATION                            │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  run/2 called                                                    │
│       │                                                          │
│       ▼                                                          │
│  ┌─────────────────┐                                            │
│  │ Check: tools    │                                            │
│  │ provided?       │                                            │
│  └────────┬────────┘                                            │
│           │                                                      │
│     ┌─────┴─────┐                                               │
│     │           │                                               │
│    YES         NO                                                │
│     │           │                                                │
│     ▼           ▼                                                │
│  ┌──────┐  ┌─────────────────┐                                  │
│  │AGENT │  │ Check: max_turns│                                  │
│  │ MODE │  │ > 1?            │                                  │
│  └──────┘  └────────┬────────┘                                  │
│                     │                                            │
│               ┌─────┴─────┐                                     │
│               │           │                                     │
│              YES         NO                                      │
│               │           │                                     │
│               ▼           ▼                                      │
│            ┌──────┐  ┌─────────┐                                │
│            │AGENT │  │JUDGMENT │                                │
│            │ MODE │  │  MODE   │                                │
│            └──────┘  └─────────┘                                │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

**Mode Determination Logic:**
```elixir
mode = cond do
  map_size(tools) > 0 -> :agent
  max_turns > 1 -> :agent
  true -> :judgment
end
```

**Key Behavioral Differences:**

| Aspect | Judgment Mode | Agent Mode |
|--------|---------------|------------|
| **Termination** | Expression result returned | Must call `return` or `fail` |
| **Turn count** | Exactly 1 | 1 to `max_turns` |
| **Tool access** | None (error if attempted) | Full tool registry |
| **Error recovery** | No retry | LLM can retry in next turn |
| **ctx/ access** | Yes | Yes |
| **memory/ access** | Yes | Yes |

**Edge Cases:**

1. **`max_turns: 1` with tools** → Agent Mode (tools take precedence)
2. **Judgment Mode calls tool** → Error: "Unknown tool" (no mode transition)
3. **Agent Mode without explicit return** → Loop continues until timeout or max_turns

**Example: Simple Eval (Judgment Mode)**
```elixir
{:ok, step} = SubAgent.run("{{x}} + {{y}}", context: %{x: 10, y: 5}, llm: llm)
step.return #=> 15
```

**Example: Multi-turn Agent**
```elixir
{:ok, step} = SubAgent.run(email_finder,
  llm: :sonnet,
  context: %{user: "alice@example.com"}
)
```

---

### SubAgent.run!/2 and then!/2

Bang variants for pipe-style chaining. Raise `SubAgentError` on failure.

```elixir
@spec run!(SubAgent.t() | String.t(), keyword()) :: Step.t()
def run!(agent, opts)

@spec then!(Step.t(), String.t() | SubAgent.t(), keyword()) :: Step.t()
def then!(step, agent, opts \\ [])
```

**`run!/2`** - Returns `Step` directly (raises on error):
```elixir
step = SubAgent.run!(agent, llm: llm, context: %{...})
```

**`then!/2`** - Chains steps, auto-sets `context`:
```elixir
SubAgent.run!(finder_agent, llm: llm)
|> SubAgent.then!(drafter_agent, llm: llm)
|> SubAgent.then!(sender_agent, llm: llm)
```

Implementation:
```elixir
def run!(agent, opts) do
  case run(agent, opts) do
    {:ok, step} -> step
    {:error, step} -> raise SubAgentError, step: step
  end
end

def then!(step, agent, opts \\ []) do
  run!(agent, Keyword.put(opts, :context, step))
end
```

---

### SubAgent.as_tool/2

Wraps a SubAgent as a tool callable by other agents.

```elixir
@spec as_tool(SubAgent.t(), keyword()) :: SubAgentTool.t()
def as_tool(agent, opts \\ [])
```

Returns a `SubAgentTool` struct that the execution loop recognizes. When called:
1. Resolves LLM (agent.llm → bound llm → parent's llm)
2. Executes `run(agent, llm: resolved_llm, context: args)`
3. Returns `step.return` on success, raises on failure

**Example:**
```elixir
# Define agent
finder = SubAgent.new(
  prompt: "Find customer by {{description}}",
  signature: "(description :string) -> {id :int, name :string}",
  tools: crm_tools
)

# Wrap as tool (llm can be bound or inherited)
finder_tool = SubAgent.as_tool(finder)

# Use in parent agent
parent_tools = %{
  "find_customer" => finder_tool,
  "get_orders" => &MyApp.get_orders/1
}

{:ok, step} = SubAgent.run(orchestrator, llm: llm, tools: parent_tools)
# When parent calls "find_customer", it inherits parent's llm
```

---

### SubAgent.compile/2

Generates a reusable PTC-Lisp function from an agent. The LLM is called once to derive the logic; subsequent executions require no LLM.

```elixir
@spec compile(SubAgent.t(), keyword()) :: {:ok, CompiledAgent.t()} | {:error, Step.t()}
def compile(agent, opts)
```

**Options:**
- `llm` - Required. Used once during compilation.
- `sample` - Sample data to help LLM understand structure.

**What can be compiled:**

| Tool Type | Compilable? | Reason |
|-----------|-------------|--------|
| Pure Elixir functions | ✓ | Deterministic |
| LLMTool | ✗ | Needs LLM at execution |
| SubAgent as tool | ✗ | Needs LLM at execution |

**Example:**
```elixir
# Define agent with pure tools
scorer = SubAgent.new(
  prompt: "Calculate anomaly score for {{report}}",
  signature: "(report :map) -> {score :float, reason :string}",
  tools: %{"lookup_threshold" => &MyApp.lookup_threshold/1}
)

# Compile - LLM derives the logic once
{:ok, compiled} = SubAgent.compile(scorer, llm: llm, sample: sample_reports)

# Execute many times - no LLM calls, but tools still run
results = Enum.map(all_reports, fn r -> compiled.execute(%{report: r}) end)
```

**What compile produces:**
- `compiled.source` - Inspectable PTC-Lisp function
- `compiled.execute` - Callable that runs the function
- `compiled.metadata` - Compilation stats (tokens, model, timestamp)

---

## Chaining Patterns

### Using `with` (Recommended)

The idiomatic Elixir pattern for sequential agent chains with error handling:

```elixir
with {:ok, step1} <- SubAgent.run(finder, llm: llm),
     {:ok, step2} <- SubAgent.run(drafter, llm: llm, context: step1),
     {:ok, step3} <- SubAgent.run(sender, llm: llm, context: step2) do
  {:ok, step3}
else
  {:error, %{fail: %{reason: :not_found}}} -> {:error, :no_data}
  {:error, step} -> {:error, step.fail}
end
```

**Benefits:**
- Pattern matches on happy path
- Short-circuits on first `{:error, _}`
- Explicit error handling via `else`
- Auto-chaining: passing `Step` to `:context` extracts both `return` and `signature`

### Using Pipes (for crash-on-error)

When you want to crash on failure, use bang variants:

```elixir
SubAgent.run!(finder, llm: llm)
|> SubAgent.then!(drafter, llm: llm)
|> SubAgent.then!(sender, llm: llm)
```

### Parallel Execution (DIY)

For concurrent agent execution, use standard Elixir patterns:

```elixir
agents = [email_agent, calendar_agent, crm_agent]

results =
  agents
  |> Task.async_stream(fn agent -> SubAgent.run(agent, llm: llm) end)
  |> Enum.map(fn {:ok, result} -> result end)
```

---

## LLM Inheritance

SubAgents can inherit their LLM from the parent, allowing flexible model selection.

**Resolution order (first non-nil wins):**

1. `agent.llm` - Struct override: "this agent always uses haiku"
2. `as_tool(..., llm: x)` - Bound at tool creation
3. Parent's llm - Inherited at call time
4. `run(..., llm: x)` - Required at top level

**Example:**
```elixir
# Agent that always uses haiku (set in struct)
classifier = SubAgent.new(
  prompt: "Classify {{text}}",
  signature: "(text :string) -> {category :string}",
  llm: :haiku  # Always uses haiku
)

# Agent that inherits LLM (no llm in struct)
finder = SubAgent.new(
  prompt: "Find {{item}}",
  signature: "(item :string) -> {id :int}",
  tools: search_tools
  # llm: nil - will inherit
)

# Tools with different inheritance
parent_tools = %{
  "classify" => SubAgent.as_tool(classifier),         # Uses haiku (struct override)
  "find" => SubAgent.as_tool(finder),                 # Inherits parent's llm
  "summarize" => SubAgent.as_tool(summarizer, llm: :haiku)  # Bound to haiku
}

# Parent uses sonnet; child tools inherit or override as configured
{:ok, step} = SubAgent.run(orchestrator, llm: :sonnet, tools: parent_tools)
```

**3+ Level Deep Inheritance Example:**

```
┌─────────────────────────────────────────────────────────────────┐
│                   LLM INHERITANCE (3 LEVELS)                     │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  Level 1: Orchestrator                                          │
│  └── run(..., llm: :sonnet)  ← Top-level LLM                    │
│       │                                                          │
│       ├── Tool: "analyzer"                                      │
│       │   └── SubAgent.as_tool(analyzer)                        │
│       │       └── agent.llm: nil → inherits :sonnet             │
│       │           │                                              │
│       │           ├── Level 2: Analyzer calls tools              │
│       │           │   │                                          │
│       │           │   ├── Tool: "classifier"                    │
│       │           │   │   └── as_tool(classifier, llm: :haiku)  │
│       │           │   │       └── bound_llm: :haiku → uses :haiku│
│       │           │   │           │                              │
│       │           │   │           └── Level 3: Classifier        │
│       │           │   │               └── Uses :haiku (bound)    │
│       │           │   │                                          │
│       │           │   └── Tool: "scorer"                        │
│       │           │       └── as_tool(scorer)                   │
│       │           │           └── agent.llm: nil, bound: nil    │
│       │           │               → inherits :sonnet from L1    │
│       │           │               │                              │
│       │           │               └── Level 3: Scorer            │
│       │           │                   └── Uses :sonnet (inherited)│
│       │           │                                              │
│       │           └── Tool: "expert"                            │
│       │               └── as_tool(expert)                       │
│       │                   └── agent.llm: :opus                  │
│       │                       → Uses :opus (struct override)     │
│       │                       │                                  │
│       │                       └── Level 3: Expert                │
│       │                           └── Uses :opus (struct)        │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

```elixir
# Level 3 agents
classifier = SubAgent.new(prompt: "Classify", signature: "...")  # No llm
scorer = SubAgent.new(prompt: "Score", signature: "...")         # No llm
expert = SubAgent.new(prompt: "Expert analysis", signature: "...", llm: :opus)

# Level 2 analyzer with nested tools
analyzer = SubAgent.new(
  prompt: "Analyze {{data}}",
  signature: "(data :map) -> {analysis :map}",
  tools: %{
    "classifier" => SubAgent.as_tool(classifier, llm: :haiku),  # Bound
    "scorer" => SubAgent.as_tool(scorer),                       # Inherits
    "expert" => SubAgent.as_tool(expert)                        # Struct override
  }
)

# Level 1 orchestrator
{:ok, step} = SubAgent.run(
  "Analyze the data",
  llm: :sonnet,
  tools: %{
    "analyzer" => SubAgent.as_tool(analyzer)  # Inherits :sonnet
  }
)

# Resolution results:
# - Analyzer: uses :sonnet (inherited from run call)
# - Classifier: uses :haiku (bound at as_tool)
# - Scorer: uses :sonnet (inherited through analyzer)
# - Expert: uses :opus (struct override, ignores inheritance)
```

**Implementation in loop:**
```elixir
def execute_tool(%SubAgentTool{agent: agent, bound_llm: bound}, args, %{llm: parent_llm}) do
  # Resolution order: struct > bound > parent > error
  llm = agent.llm || bound || parent_llm || raise "llm required"

  case SubAgent.run(agent, llm: llm, context: args) do
    {:ok, step} -> step.return
    {:error, step} -> raise SubAgentError, step: step
  end
end
```

---

## Execution Loop

### Loop.run/2

Low-level agentic loop. Called internally by `run/2`.

```elixir
@spec run(String.t(), keyword()) :: {:ok, Step.t()} | {:error, Step.t()}
def run(prompt, opts)
```

**Loop behavior:**

1. LLM generates a PTC-Lisp program
2. Program executes in sandbox
3. Results merge into context for next turn
4. Repeat until `return` or `fail` is called

**Turn result handling:**
- Results are wrapped in a `Step` struct per turn
- Public fields added to LLM history
- Full results (including firewalled) merged into `ctx/`
- Previous turn's error available as `ctx/fail`

---

### System Tools

System tools are **implicitly injected** into every SubAgent's tool registry. They appear in the tool schema shown to the LLM and are called via the standard `(call ...)` syntax.

**Design Decision (DD-9):** System tools are real tools, not keywords. This ensures:
- Consistent `(call ...)` invocation pattern for everything
- LLM sees them in the tool schema alongside user tools
- Unified handling in the interpreter

#### `return`

Complete the mission successfully.

```
return(data :any) -> :exit-success
```

- **Argument:** Value matching the signature's output type
- **Effect:** Terminates loop, returns `{:ok, step}`
- **Validation:** If data doesn't match signature, error fed back for self-correction
- **Note:** The `:exit-success` return type indicates this tool terminates the loop

```clojure
(call "return" {:count 5 :items ["a" "b"]})
```

#### `fail`

Terminate with an error.

```
fail(error {:reason :keyword, :message :string, :op :string?, :details :map?}) -> :exit-error
```

- **Effect:** Terminates loop, returns `{:error, step}`
- **Note:** The `:exit-error` return type indicates this tool terminates the loop with failure

**Fail signature fields:**

| Field | Type | Required | Description |
|-------|------|----------|-------------|
| `reason` | `:keyword` | Yes | Machine-readable error code |
| `message` | `:string` | Yes | Human-readable description |
| `op` | `:string` | No | Operation/tool that failed |
| `details` | `:map` | No | Additional context |

```clojure
(call "fail" {:reason :not_found :message "User does not exist"})
```

#### System Tool Implementation

```elixir
# System tools are injected before user tools
defp inject_system_tools(user_tools) do
  system_tools = %{
    "return" => {:system, :return},
    "fail" => {:system, :fail}
  }
  Map.merge(system_tools, user_tools)
end
```

---

## Tool Registration

### Tool Formats

Tools in the `:tools` map can be:

**1. Function reference (extracts `@spec`):**
```elixir
"get_user" => &MyApp.get_user/1
```

**2. Function with explicit signature:**
```elixir
"search" => {&MyApp.search/2, "(query :string, limit :int) -> [{id :int}]"}
```

**3. Anonymous function:**
```elixir
"get_time" => fn _args -> DateTime.utc_now() end
```

**4. LLMTool struct:**
```elixir
"classify" => LLMTool.new(prompt: "...", signature: "...")
```

**5. SubAgent-as-tool:**
```elixir
"researcher" => SubAgent.as_tool(prompt: "...", signature: "...", tools: ...)
```

### tools vs tool_catalog

| Aspect | `tools` | `tool_catalog` |
|--------|---------|----------------|
| In prompt | "Tools you can call" | "Tools for planning (do not call)" |
| Callable | Yes | No |
| Use case | Execution | Planning visibility |

### LLMTool

Create tools that use LLM for classification, evaluation, or judgment.

```elixir
defmodule PtcRunner.SubAgent.LLMTool do
  defstruct [:prompt, :signature, :llm, :description, :tools]

  @spec new(keyword()) :: t()
  def new(opts)
end
```

**Options:**
- `:prompt` - Template with `{{placeholder}}` references
- `:signature` - Contract (inputs validated against placeholders)
- `:llm` - `:caller` (default), atom (registry lookup), or function
- `:description` - For schema generation
- `:tools` - If provided, runs as multi-turn agent

**Example:**

```elixir
LLMTool.new(
  prompt: "Is {{email.subject}} urgent for {{tier}} customer?",
  signature: "(email {:subject :string}, tier :string) -> {:urgent :bool, :reason :string}"
)
```

**Placeholder validation:** Every `{{placeholder}}` must match a signature parameter.

### Reserved Names

The following tool names cannot be used:
- `return` - System tool for completion
- `fail` - System tool for failure

Attempting to register reserved names returns `{:error, :reserved_tool_name}`.

---

## Signatures & Validation

See [signature-syntax.md](signature-syntax.md) for full signature syntax specification.

### Shorthand Syntax

```
Primitives:
  :string :int :float :bool :keyword :any

Lists:
  [:int]                          ; list of integers
  [{:id :int :name :string}]      ; list of maps

Maps:
  {:id :int :name :string}        ; required fields
  :map                            ; any map

Optional fields (? suffix):
  {:id :int :email :string?}      ; email is optional

Nested:
  {:user {:id :int :profile {:bio :string}}}
```

### Full Signature Format

```
(inputs) -> outputs
```

**Examples:**
```
() -> {count :int}                           ; no inputs
(query :string) -> [{id :int}]               ; one input
(user {:id :int}, limit :int) -> :any        ; nested input
```

**Shorthand:** Omit `() ->` when no inputs:
```elixir
signature: "{count :int}"  # equivalent to "() -> {count :int}"
```

### Validation Modes

```elixir
SubAgent.run(agent, signature_validation: :enabled, llm: llm)
```

| Mode | Behavior |
|------|----------|
| `:enabled` | Validate inputs/outputs, fail on errors (default) |
| `:warn_only` | Validate, log warnings, continue |
| `:disabled` | Skip validation |
| `:strict` | Reject extra fields, require all tools have specs |

---

## Templates

### Syntax

```
{{var}}              ; simple value
{{a.b}}              ; nested access
{{#list}}...{{/list}} ; iteration (empty list = empty string)
```

### Validation

Placeholders are validated against signature parameters at registration:

```elixir
# Valid: placeholder matches signature
LLMTool.new(
  prompt: "Hello {{name}}",
  signature: "(name :string) -> {greeting :string}"
)

# Error: placeholder not in signature
LLMTool.new(
  prompt: "Hello {{unknown}}",
  signature: "(name :string) -> {greeting :string}"
)
#=> {:error, {:template_error, "placeholder {{unknown}} not found in signature"}}
```

### ~PROMPT Sigil

Compile-time placeholder extraction:

```elixir
import PtcRunner.SubAgent.Sigils

~PROMPT"Hello {{name}}, you have {{count}} items"
#=> %PtcRunner.Prompt{
#=>   template: "Hello {{name}}, you have {{count}} items",
#=>   placeholders: [%{path: ["name"], type: :simple}, %{path: ["count"], type: :simple}]
#=> }
```

---

## LLM Callback

### Signature

```elixir
@type llm :: (llm_input() -> {:ok, String.t()} | {:error, term()})

@type llm_input :: %{
  required(:system) => String.t(),
  required(:messages) => [%{role: :user | :assistant, content: String.t()}],
  optional(:turn) => pos_integer(),
  optional(:prompt) => String.t(),
  optional(:tool_names) => [String.t()],
  optional(:llm_opts) => map()
}
```

### System Prompt Contents

Generated by `PtcRunner.SubAgent.Prompt`:

1. Core PTC-Lisp instructions
2. Language reference (Clojure subset, `call`, `ctx/`, `memory/`)
3. Error recovery (`ctx/fail` for previous turn errors)
4. Data inventory (typed view of `ctx/` variables)
5. Tool schemas
6. Output format (` ```clojure ` blocks)

### Response Parsing

1. **Code blocks:** Searches for ` ```clojure ` or ` ```lisp `
2. **Plain code:** If no blocks, text starting with `(` parsed as code
3. **Multiple blocks:** Executed sequentially in `do` block
4. **No code:** Boundary reminder sent, prompting for code

---

## Memory Operations

Per-agent scoped memory via PTC-Lisp:

```clojure
(memory/put :key value)    ; store
(memory/get :key)          ; retrieve
memory/key                 ; shorthand access
```

### Limits

| Limit | Default | Description |
|-------|---------|-------------|
| Memory size | 1MB | Per-agent memory map size |
| Nesting depth | 3 | SubAgent spawn depth |
| Turn budget | 20 | Total turns across mission tree |

Exceeding limits returns `{:error, step}` with appropriate reason.

---

## Debugging & Introspection

SubAgents provide comprehensive debugging capabilities for inspecting prompts, generated programs, and execution flow.

---

### Step.trace Structure

Every `Step` includes a `trace` field containing detailed per-turn execution history:

```elixir
@type trace :: %{
  turns: [turn_trace()],
  total_duration_ms: non_neg_integer(),
  total_tokens: token_counts()
}

@type turn_trace :: %{
  turn: pos_integer(),
  timestamp: DateTime.t(),
  duration_ms: non_neg_integer(),

  # LLM interaction
  prompt: %{
    system: String.t(),           # Full system prompt sent
    messages: [message()],        # Conversation history
    expanded_template: String.t() # User prompt with {{placeholders}} resolved
  },
  llm_response: String.t(),       # Raw LLM response

  # Parsed program
  program: %{
    source: String.t(),           # Extracted PTC-Lisp code
    ast: term(),                  # Parsed AST (optional, when debug: true)
    parse_error: String.t() | nil # If parsing failed
  },

  # Execution results
  execution: %{
    result: term(),               # Expression result or tool return
    tool_calls: [tool_call()],    # Tools invoked this turn
    error: error() | nil,         # Runtime error if any
    context_snapshot: map()       # ctx/ state after turn (when debug: true)
  },

  # Token usage
  tokens: token_counts()
}

@type tool_call :: %{
  name: String.t(),
  args: term(),
  result: term(),
  duration_ms: non_neg_integer(),
  error: error() | nil
}

@type token_counts :: %{
  input: non_neg_integer(),
  output: non_neg_integer()
}
```

**Accessing trace data:**

```elixir
{:ok, step} = SubAgent.run(agent, llm: llm)

# Inspect all turns
for turn <- step.trace.turns do
  IO.puts("Turn #{turn.turn}:")
  IO.puts("  Program: #{turn.program.source}")
  IO.puts("  Tools called: #{Enum.map(turn.execution.tool_calls, & &1.name)}")
end

# Find which turn called a specific tool
step.trace.turns
|> Enum.filter(fn t ->
  Enum.any?(t.execution.tool_calls, & &1.name == "search")
end)
```

---

### Debug Mode

Enable verbose tracing with the `:debug` option:

```elixir
{:ok, step} = SubAgent.run(agent,
  llm: llm,
  debug: true
)
```

**Debug mode enables:**

| Feature | Normal | Debug |
|---------|--------|-------|
| Turn traces | ✓ | ✓ |
| Full system prompt in trace | ✓ | ✓ |
| Parsed AST in trace | ✗ | ✓ |
| Context snapshots per turn | ✗ | ✓ |
| Tool argument/result logging | Summary | Full |
| Memory state per turn | ✗ | ✓ |

**Debug output helper:**

```elixir
# Pretty-print execution trace
SubAgent.Debug.print_trace(step)

# Output:
# ┌─ Turn 1 ─────────────────────────────────────
# │ Prompt: Find urgent emails for alice@example.com
# │ Program:
# │   (let [emails (call "list_emails" {:user ctx/user})]
# │     (call "return" {:count (count emails) :ids (map :id emails)}))
# │ Tools:
# │   → list_emails({user: "alice@example.com"})
# │     ← [{id: 1, subject: "Urgent"}, {id: 2, subject: "Hello"}]
# │ Result: {:count 2, :ids [1, 2]}
# │ Duration: 245ms | Tokens: 150 in / 89 out
# └──────────────────────────────────────────────
```

**Filtering traces:**

```elixir
# Only keep traces for failed runs (reduce memory in production)
SubAgent.run(agent, llm: llm, trace: :on_error)

# Disable tracing entirely
SubAgent.run(agent, llm: llm, trace: false)
```

| Trace Option | Behavior |
|--------------|----------|
| `true` (default) | Always capture traces |
| `:on_error` | Only keep trace if run fails |
| `false` | No trace (minimal memory) |

---

### Prompt Preview

Inspect the expanded prompt without executing:

```elixir
@spec preview_prompt(SubAgent.t(), keyword()) :: %{
  system: String.t(),
  user: String.t(),
  tool_schemas: [map()]
}
def preview_prompt(agent, opts \\ [])
```

**Example:**

```elixir
agent = SubAgent.new(
  prompt: "Find emails for {{user}} from {{sender}}",
  signature: "(user :string, sender :string) -> {count :int}",
  tools: %{"list_emails" => &MyApp.list_emails/1}
)

preview = SubAgent.preview_prompt(agent,
  context: %{user: "alice", sender: "bob@example.com"}
)

IO.puts(preview.system)
# Outputs the full system prompt with:
# - PTC-Lisp instructions
# - Tool schemas
# - Data inventory showing ctx/user and ctx/sender

IO.puts(preview.user)
# "Find emails for alice from bob@example.com"

IO.inspect(preview.tool_schemas)
# [%{name: "list_emails", signature: "...", description: "..."}]
```

**Use cases:**

- Verify template expansion before running
- Debug system prompt generation
- Test prompt changes without LLM calls
- Export prompts for external review

---

### Telemetry Hooks

SubAgent emits telemetry events for observability integration.

**Events:**

| Event | Measurements | Metadata |
|-------|--------------|----------|
| `[:ptc_runner, :sub_agent, :run, :start]` | - | agent, context |
| `[:ptc_runner, :sub_agent, :run, :stop]` | duration | agent, step, status |
| `[:ptc_runner, :sub_agent, :run, :exception]` | duration | agent, error |
| `[:ptc_runner, :sub_agent, :turn, :start]` | - | agent, turn |
| `[:ptc_runner, :sub_agent, :turn, :stop]` | duration, tokens | agent, turn, program |
| `[:ptc_runner, :sub_agent, :llm, :start]` | - | agent, turn, messages |
| `[:ptc_runner, :sub_agent, :llm, :stop]` | duration, tokens | agent, turn, response |
| `[:ptc_runner, :sub_agent, :tool, :start]` | - | agent, tool_name, args |
| `[:ptc_runner, :sub_agent, :tool, :stop]` | duration | agent, tool_name, result |
| `[:ptc_runner, :sub_agent, :tool, :exception]` | duration | agent, tool_name, error |

**Attaching handlers:**

```elixir
:telemetry.attach_many(
  "sub-agent-logger",
  [
    [:ptc_runner, :sub_agent, :run, :stop],
    [:ptc_runner, :sub_agent, :tool, :stop]
  ],
  &MyApp.Telemetry.handle_event/4,
  nil
)

defmodule MyApp.Telemetry do
  def handle_event([:ptc_runner, :sub_agent, :run, :stop], measurements, metadata, _config) do
    Logger.info("SubAgent completed",
      duration_ms: measurements.duration,
      status: metadata.status,
      turns: length(metadata.step.trace.turns)
    )
  end

  def handle_event([:ptc_runner, :sub_agent, :tool, :stop], measurements, metadata, _config) do
    Logger.debug("Tool called",
      tool: metadata.tool_name,
      duration_ms: measurements.duration
    )
  end
end
```

**Integration with common observability tools:**

```elixir
# OpenTelemetry integration
{:ok, _} = OpentelemetryTelemetry.attach_handlers(:ptc_runner)

# Prometheus metrics
PtcRunner.Telemetry.Prometheus.setup()
```

---

### Debugging Chained Agents

When debugging multi-agent chains, each Step contains its own trace:

```elixir
with {:ok, step1} <- SubAgent.run(finder, llm: llm),
     {:ok, step2} <- SubAgent.run(processor, llm: llm, context: step1),
     {:ok, step3} <- SubAgent.run(sender, llm: llm, context: step2) do

  # Each step has independent trace
  SubAgent.Debug.print_trace(step1)
  SubAgent.Debug.print_trace(step2)
  SubAgent.Debug.print_trace(step3)

  # Or combine for full pipeline view
  SubAgent.Debug.print_chain([step1, step2, step3])
end
```

**Debugging nested SubAgents (as_tool):**

When a SubAgent calls another SubAgent as a tool, the child's trace is captured in the tool call:

```elixir
parent_step.trace.turns
|> Enum.flat_map(& &1.execution.tool_calls)
|> Enum.filter(& &1.name == "child_agent")
|> Enum.map(fn call ->
  # Child's full Step is available
  call.result.trace
end)
```

---

### Debug Struct Options

For struct inspection during development:

```elixir
# Inspect agent definition
agent = SubAgent.new(prompt: "...", signature: "...", tools: tools)
IO.inspect(agent, label: "Agent config")

# Inspect with custom options
IO.inspect(step, limit: :infinity, printable_limit: :infinity)

# Derive Inspect protocol excludes sensitive fields by default
# Override with:
IO.inspect(step, custom_options: [show_llm_responses: true])
```

---

## Configuration

### LLM Registry

Use atoms to reference configured models:

```elixir
# config/config.exs
config :ptc_runner, :models, %{
  haiku: [module: PtcRunner.SubAgent.LLM.Anthropic, model: "claude-3-haiku-..."],
  gpt4: [module: PtcRunner.SubAgent.LLM.OpenAI, model: "gpt-4-turbo"]
}

# Usage
SubAgent.run(agent, llm: :haiku)
```

### Retry Configuration

```elixir
llm_retry: %{
  max_attempts: 3,
  backoff: :exponential,  # or :linear
  retryable_errors: [:rate_limit, :timeout]  # optional filter
}
```

**Retry scope:** Only LLM callback failures consume retry budget. Logic errors (syntax, validation) are fed back to LLM as next turn.

---

## Design Decisions

### DD-1: Optional Field Syntax (`?` suffix)

Use `:type?` for optional fields. `[:type]` is reserved for lists.

```
{:email :string?}   ; optional field
{:tags [:string]}   ; list of strings
```

### DD-2: Reserved Names Error at Registration

Fail early at `run/2` if user registers `return` or `fail` tools.

### DD-3: Lenient Extra Fields by Default

`:enabled` mode allows extra fields in return data. Use `:strict` for exact matching.

### DD-4: Soft Failures Don't Consume Retry Budget

Logic errors (bad syntax, validation) use turn budget. Infrastructure errors (timeouts, rate limits) use retry budget.

### DD-5: Auto-Chaining with Step Detection

Passing `Step` to `:context` auto-extracts `return` and `signature`.

### DD-6: Agents as Data

SubAgents are defined as structs via `new/1`, separating definition from execution. This enables:
- Delayed execution
- Reusable agent definitions
- Composition patterns (chaining, parallel)
- Serialization/inspection

### DD-7: LLM Inheritance

Child SubAgents can inherit the parent's LLM. Resolution order:
1. Agent struct `llm` field (override)
2. `as_tool(..., llm: x)` bound LLM
3. Parent's LLM (inherited)
4. `run(..., llm: x)` (required at top level)

### DD-8: Compile Only Works with Pure Tools

`SubAgent.compile/2` generates deterministic PTC-Lisp functions. It can include calls to pure Elixir tools (which execute at runtime), but cannot include LLMTool or SubAgent tools (which would require LLM at execution time).

### DD-9: System Tools Are Real Tools

`return` and `fail` are implemented as real tools injected into the tool registry, not special keywords. This ensures consistent `(call ...)` syntax and LLM visibility.

### DD-10: CompiledAgent.execute Always Uses Maps

The `execute` function always takes a map of named arguments, regardless of parameter count. This ensures:
- Consistent API across all compiled agents
- Adding parameters doesn't break existing callers
- Clear, self-documenting invocations

### DD-11: Tracing Always On by Default

Traces are captured by default (`trace: true`) because:
- Debugging agent behavior is inherently difficult without execution history
- Memory overhead is acceptable for typical agent runs (< 100 turns)
- Production optimization via `trace: :on_error` or `trace: false` is opt-in
- Failed runs are nearly impossible to debug without trace data

The `debug: true` option enables additional expensive captures (AST, context snapshots) that are off by default.

### DD-12: Telemetry for Observability, Not Control Flow

Telemetry events are fire-and-forget notifications, not callbacks that can modify execution. This ensures:
- Observability handlers cannot break agent execution
- No hidden control flow through telemetry
- Production monitoring doesn't affect behavior
- Clear separation between execution and observation

---

## Appendix: CompiledAgent Struct

```elixir
defmodule PtcRunner.SubAgent.CompiledAgent do
  @type metadata :: %{
    compiled_at: DateTime.t(),
    tokens_used: non_neg_integer(),
    turns: pos_integer(),
    llm_model: String.t() | nil
  }

  defstruct [
    :source,      # Inspectable PTC-Lisp source code
    :signature,   # Functional contract (String)
    :execute,     # Pre-bound (fn(map()) -> result) executor
    :metadata     # t:metadata()
  ]
end
```

**Execute Contract (DD-10):**

The `execute` function **always** takes a map of named arguments:

```elixir
# Single parameter signature: (item :map) -> {score :float}
compiled.execute(%{item: item_data})

# Multiple parameters: (item :map, threshold :float) -> {score :float}
compiled.execute(%{item: item_data, threshold: 0.5})

# No parameters: () -> {result :map}
compiled.execute(%{})
```

**CompiledAgent as Tool:**

Unlike `SubAgent.as_tool/2`, a compiled agent can be wrapped as a tool **without LLM**:

```elixir
# Compile once
{:ok, compiled} = SubAgent.compile(scorer, llm: llm, sample: data)

# Use as tool (no LLM needed at execution)
parent_tools = %{
  "score_item" => CompiledAgent.as_tool(compiled)
}

# Parent calls score_item → runs compiled.execute directly
```

**Implementation:**

```elixir
defmodule PtcRunner.SubAgent.CompiledAgent do
  @doc """
  Wrap a compiled agent as a callable tool.

  Unlike SubAgent.as_tool/2, this does NOT require an LLM at execution time.
  The compiled logic runs deterministically with only pure tool calls.
  """
  @spec as_tool(t()) :: tool()
  def as_tool(%__MODULE__{execute: execute, signature: signature}) do
    %{
      type: :compiled,
      execute: execute,
      signature: signature
    }
  end
end
```

---

## Related Documents

- [step.md](step.md) - Step struct specification
- [signature-syntax.md](signature-syntax.md) - Signature syntax specification
- [lisp-api-updates.md](lisp-api-updates.md) - Changes to Lisp API
- [guides/](guides/) - Tutorial and usage guides
