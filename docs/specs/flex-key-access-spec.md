# Specification: Flexible Key Access for PTC-Lisp

**Status:** Proposed
**Created:** 2024-12-10
**Updated:** 2024-12-10 (v2 - addressed nil vs missing key, get-in consistency)
**Issue:** String/atom key mismatch causes runtime failures in LLM-generated code

---

## Problem Statement

PTC-Lisp programs generated by LLMs frequently fail when map key types don't match between the code and the data. This occurs because:

1. LLMs generate code using atom keys (idiomatic Clojure style): `ctx/employees`, `(:name user)`
2. Runtime data often has string keys: `%{"employees" => [...], "name" => "Alice"}`
3. Several internal functions use `Map.get` which requires exact key type matching

### Failing Example

**E2E Test:** `test/ptc_runner/lisp/e2e_test.exs:155` - "top N with sorting"

```elixir
# Test data (string keys)
context = %{
  "employees" => [
    %{"name" => "Alice", "salary" => 70000},
    %{"name" => "Bob", "salary" => 95000},
    ...
  ]
}

# LLM generates (atom key access)
(->> ctx/employees
     (sort-by :salary >)
     (take 3)
     (pluck :name))
```

**Error:**
```
** (FunctionClauseError) no function clause matching in PtcRunner.Lisp.Runtime.sort_by/3
    # 3: nil   <- ctx/employees returned nil because :employees ≠ "employees"
```

---

## Root Cause Analysis

The codebase has a `flex_get` helper function that provides bidirectional key matching (atom ↔ string), but it's not used consistently:

| Location | Current Code | Problem |
|----------|--------------|---------|
| `eval.ex:117` | `Map.get(ctx, key)` | `ctx/foo` fails with string keys |
| `eval.ex:122` | `Map.get(memory, key)` | `memory/foo` fails with string keys |
| `eval.ex:347-350` | `Map.get(m, k)` | `(:key map)` fails with string keys |
| `eval.ex:310` | `Map.get(value, key, default)` | Map destructuring fails |
| `runtime.ex:210` | `Map.take(m, ks)` | `select-keys` fails with mixed keys |
| `runtime.ex:195-201` | `Kernel.get_in(m, path)` | `get-in` fails with mixed keys |

### Existing Solutions (Partial)

1. **`flex_get`** in `runtime.ex:14-39` - private, handles single key lookup
2. **`get_in_flexible`** in `eval.ex:478-489` - private, handles nested path lookup (used by `where`)

---

## Design Considerations

### Critical Issue: `nil` vs Missing Key

The original approach using only `flex_get` (which returns `nil` for missing keys) would introduce bugs:

| Scenario | Map | Key | `flex_get` returns | Expected behavior |
|----------|-----|-----|-------------------|-------------------|
| Missing key | `%{}` | `:a` | `nil` | Use default |
| Nil value | `%{a: nil}` | `:a` | `nil` | Keep `nil`, NOT default |

**Affected operations:**

1. **Destructuring with defaults:**
   ```clojure
   (let [{:keys [a] :or {a 100}} {:a nil}]
     a)  ; Should be nil, not 100
   ```

2. **select-keys with nil values:**
   ```clojure
   (select-keys {:a nil :b 2} [:a :b])
   ; Should be {:a nil, :b 2}, not {:b 2}
   ```

**Solution:** Implement `flex_fetch/2` returning `{:ok, val} | :error` for operations that must distinguish between missing keys and nil values.

### Consistency Issue: `get-in` Path Access

Currently there are two implementations:
- `eval.ex:478-489`: Private `get_in_flexible` used by `where` clauses
- `runtime.ex:195-201`: Public `get_in` using strict `Kernel.get_in`

This causes inconsistency:
```clojure
(where [:user :name] = "Bob")     ; Works (uses flexible helper)
(get-in data [:user :name])       ; Fails with string keys
```

**Solution:** Consolidate into public `flex_get_in/2` in Runtime, used by both.

---

## Proposed Solution

### New Public Functions in Runtime

| Function | Signature | Returns | Use Case |
|----------|-----------|---------|----------|
| `flex_get/2` | `(map, key)` | `value \| nil` | Simple access (ctx/, memory/, keyword-as-function) |
| `flex_fetch/2` | `(map, key)` | `{:ok, val} \| :error` | When nil values must be preserved |
| `flex_get_in/2` | `(map, path)` | `value \| nil` | Nested path access |

---

## Implementation Plan

### Phase 1: Runtime Module Changes

#### 1.1 Make `flex_get` Public

**File:** `lib/ptc_runner/lisp/runtime.ex`
**Lines:** 14-42

Change `defp` to `def` for all `flex_get` clauses (already done).

#### 1.2 Add `flex_fetch/2`

**File:** `lib/ptc_runner/lisp/runtime.ex`
**Location:** After `flex_get` definitions

```elixir
@doc """
Flexible key fetch: try both atom and string versions of the key.
Returns {:ok, value} if found, :error if missing.
Use this when you need to distinguish between nil values and missing keys.
"""
def flex_fetch(%MapSet{}, _key), do: :error

def flex_fetch(map, key) when is_map(map) and is_atom(key) do
  case Map.fetch(map, key) do
    {:ok, _} = ok -> ok
    :error -> Map.fetch(map, to_string(key))
  end
end

def flex_fetch(map, key) when is_map(map) and is_binary(key) do
  case Map.fetch(map, key) do
    {:ok, _} = ok ->
      ok

    :error ->
      try do
        Map.fetch(map, String.to_existing_atom(key))
      rescue
        ArgumentError -> :error
      end
  end
end

def flex_fetch(map, key) when is_map(map), do: Map.fetch(map, key)
def flex_fetch(nil, _key), do: :error
```

#### 1.3 Add `flex_get_in/2`

**File:** `lib/ptc_runner/lisp/runtime.ex`
**Location:** After `flex_fetch` definitions

Move and adapt from `eval.ex:478-489`:

```elixir
@doc """
Flexible nested key access: try both atom and string versions at each level.
"""
def flex_get_in(data, []), do: data
def flex_get_in(nil, _path), do: nil

def flex_get_in(data, [key | rest]) when is_map(data) do
  case flex_fetch(data, key) do
    {:ok, value} -> flex_get_in(value, rest)
    :error -> nil
  end
end

def flex_get_in(_data, _path), do: nil
```

#### 1.4 Fix `select_keys`

**File:** `lib/ptc_runner/lisp/runtime.ex`
**Line:** 210

**Current:**
```elixir
def select_keys(m, ks), do: Map.take(m, ks)
```

**Proposed:**
```elixir
def select_keys(m, ks) do
  Enum.reduce(ks, %{}, fn k, acc ->
    case flex_fetch(m, k) do
      {:ok, val} -> Map.put(acc, k, val)
      :error -> acc
    end
  end)
end
```

#### 1.5 Fix `get_in`

**File:** `lib/ptc_runner/lisp/runtime.ex`
**Lines:** 195-201

**Current:**
```elixir
def get_in(m, path) when is_map(m), do: Kernel.get_in(m, path)

def get_in(m, path, default) when is_map(m) do
  case Kernel.get_in(m, path) do
    nil -> default
    val -> val
  end
end
```

**Proposed:**
```elixir
def get_in(m, path) when is_map(m), do: flex_get_in(m, path)

def get_in(m, path, default) when is_map(m) do
  case flex_get_in(m, path) do
    nil -> default
    val -> val
  end
end
```

---

### Phase 2: Evaluator Module Changes

#### 2.1 Import Flexible Functions

**File:** `lib/ptc_runner/lisp/eval.ex`
**Location:** Top of module, after `@moduledoc`

```elixir
import PtcRunner.Lisp.Runtime, only: [flex_get: 2, flex_fetch: 2, flex_get_in: 2]
```

#### 2.2 Fix Context Access

**File:** `lib/ptc_runner/lisp/eval.ex`
**Line:** 117

**Current:**
```elixir
defp do_eval({:ctx, key}, ctx, memory, _env, _tool_exec) do
  {:ok, Map.get(ctx, key), memory}
end
```

**Proposed:**
```elixir
defp do_eval({:ctx, key}, ctx, memory, _env, _tool_exec) do
  {:ok, flex_get(ctx, key), memory}
end
```

#### 2.3 Fix Memory Access

**File:** `lib/ptc_runner/lisp/eval.ex`
**Line:** 122

**Current:**
```elixir
defp do_eval({:memory, key}, _ctx, memory, _env, _tool_exec) do
  {:ok, Map.get(memory, key), memory}
end
```

**Proposed:**
```elixir
defp do_eval({:memory, key}, _ctx, memory, _env, _tool_exec) do
  {:ok, flex_get(memory, key), memory}
end
```

#### 2.4 Fix Keyword-as-Function

**File:** `lib/ptc_runner/lisp/eval.ex`
**Lines:** 347-350

**Current:**
```elixir
defp apply_fun(k, args, _ctx, memory, _tool_exec) when is_atom(k) do
  case args do
    [m] when is_map(m) ->
      {:ok, Map.get(m, k), memory}

    [m, default] when is_map(m) ->
      {:ok, Map.get(m, k, default), memory}
    ...
```

**Proposed:**
```elixir
defp apply_fun(k, args, _ctx, memory, _tool_exec) when is_atom(k) do
  case args do
    [m] when is_map(m) ->
      {:ok, flex_get(m, k), memory}

    [m, default] when is_map(m) ->
      case flex_fetch(m, k) do
        {:ok, val} -> {:ok, val, memory}
        :error -> {:ok, default, memory}
      end
    ...
```

#### 2.5 Fix Map Destructuring

**File:** `lib/ptc_runner/lisp/eval.ex`
**Line:** 310

**Current:**
```elixir
defp match_pattern({:destructure, {:keys, keys, defaults}}, value) when is_map(value) do
  Enum.reduce(keys, %{}, fn key, acc ->
    default = Keyword.get(defaults, key)
    Map.put(acc, key, Map.get(value, key, default))
  end)
end
```

**Proposed:**
```elixir
defp match_pattern({:destructure, {:keys, keys, defaults}}, value) when is_map(value) do
  Enum.reduce(keys, %{}, fn key, acc ->
    default = Keyword.get(defaults, key)
    val = case flex_fetch(value, key) do
      {:ok, v} -> v
      :error -> default
    end
    Map.put(acc, key, val)
  end)
end
```

#### 2.6 Remove Duplicated `get_in_flexible`

**File:** `lib/ptc_runner/lisp/eval.ex`
**Lines:** 478-489

**Current:**
```elixir
defp get_in_flexible(data, []), do: data
defp get_in_flexible(nil, _), do: nil

defp get_in_flexible(data, [key | rest]) when is_map(data) do
  case Map.fetch(data, key) do
    {:ok, value} -> get_in_flexible(value, rest)
    :error -> get_in_flexible(Map.get(data, to_string(key)), rest)
  end
end

defp get_in_flexible(_, _), do: nil
```

**Proposed:** Replace with call to Runtime:
```elixir
# Remove the private function entirely and update build_field_accessor:
defp build_field_accessor(path) when is_list(path) do
  fn row -> flex_get_in(row, path) end
end
```

**Location of `build_field_accessor`:** `eval.ex:473-476`

---

## Test Plan

### Verification Tests

1. **E2E test should pass:**
   ```bash
   mix test test/ptc_runner/lisp/e2e_test.exs:155
   ```

2. **Full test suite passes:**
   ```bash
   mix test
   ```

### New Test Cases Required

#### Nil Value Preservation Tests

```elixir
# test/ptc_runner/lisp/flex_access_test.exs

describe "flex_fetch preserves nil values" do
  test "select-keys includes nil values" do
    program = ~s/(select-keys ctx/data [:a :b])/
    context = %{"data" => %{"a" => nil, "b" => 2}}

    assert {:ok, %{a: nil, b: 2}, _} = PtcRunner.Lisp.run(program, context: context)
  end

  test "destructuring with :or does not replace nil" do
    program = ~s/(let [{:keys [a] :or {a 100}} ctx/data] a)/
    context = %{"data" => %{"a" => nil}}

    assert {:ok, nil, _} = PtcRunner.Lisp.run(program, context: context)
  end

  test "destructuring with :or uses default for missing key" do
    program = ~s/(let [{:keys [a] :or {a 100}} ctx/data] a)/
    context = %{"data" => %{}}

    assert {:ok, 100, _} = PtcRunner.Lisp.run(program, context: context)
  end

  test "keyword-as-function with default returns nil value" do
    program = ~s/(:a ctx/data "default")/
    context = %{"data" => %{"a" => nil}}

    assert {:ok, nil, _} = PtcRunner.Lisp.run(program, context: context)
  end

  test "keyword-as-function with default uses default for missing" do
    program = ~s/(:a ctx/data "default")/
    context = %{"data" => %{}}

    assert {:ok, "default", _} = PtcRunner.Lisp.run(program, context: context)
  end
end

describe "flex_get_in consistency" do
  test "get-in works with string keys" do
    program = ~s/(get-in ctx/data [:user :name])/
    context = %{"data" => %{"user" => %{"name" => "Alice"}}}

    assert {:ok, "Alice", _} = PtcRunner.Lisp.run(program, context: context)
  end

  test "where clause path works with string keys" do
    program = ~s/(->> ctx/items (filter (where [:meta :active] = true)))/
    context = %{"items" => [
      %{"meta" => %{"active" => true}, "name" => "A"},
      %{"meta" => %{"active" => false}, "name" => "B"}
    ]}

    assert {:ok, [%{"meta" => %{"active" => true}, "name" => "A"}], _} =
      PtcRunner.Lisp.run(program, context: context)
  end
end
```

---

## Impact Assessment

### Risk: Low

- All changes build on existing, well-tested patterns
- No changes to parsing, AST, or core evaluation logic
- Backwards compatible (existing code continues to work)
- `flex_fetch` mirrors standard `Map.fetch` semantics

### Files Modified

| File | Changes |
|------|---------|
| `lib/ptc_runner/lisp/runtime.ex` | Add `flex_fetch`, `flex_get_in`; fix `select_keys`, `get_in` |
| `lib/ptc_runner/lisp/eval.ex` | Import helpers; update 5 call sites; remove duplicate code |

### Lines of Code

- **Added:** ~40 lines (new functions)
- **Changed:** ~25 lines (call sites)
- **Removed:** ~12 lines (duplicate `get_in_flexible`)

---

## Implementation Checklist

### Phase 1: Runtime
- [x] Make `flex_get` public in `runtime.ex` (already done)
- [ ] Add `flex_fetch/2` to `runtime.ex`
- [ ] Add `flex_get_in/2` to `runtime.ex`
- [ ] Fix `select_keys` using `flex_fetch`
- [ ] Fix `get_in` using `flex_get_in`

### Phase 2: Evaluator
- [ ] Import `flex_get`, `flex_fetch`, `flex_get_in` in `eval.ex`
- [ ] Fix `ctx/` access in `eval.ex:117`
- [ ] Fix `memory/` access in `eval.ex:122`
- [ ] Fix keyword-as-function in `eval.ex:347-350` using `flex_fetch`
- [ ] Fix map destructuring in `eval.ex:310` using `flex_fetch`
- [ ] Remove `get_in_flexible` and update `build_field_accessor`

### Phase 3: Testing
- [ ] Add nil value preservation tests
- [ ] Add `get-in` consistency tests
- [ ] Verify e2e test passes
- [ ] Run full test suite

### Phase 4: Documentation
- [ ] Update `docs/ptc-lisp-overview.md` (remove from "Future Improvements")

---

## References

- **Overview doc:** `docs/ptc-lisp-overview.md` (Future Improvements section)
- **Failing test:** `test/ptc_runner/lisp/e2e_test.exs:155`
- **Existing flex_get:** `lib/ptc_runner/lisp/runtime.ex:14-42`
- **Existing get_in_flexible:** `lib/ptc_runner/lisp/eval.ex:478-489`
