<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>PTC Trace Viewer</title>
  <style>
    :root {
      --bg: #1e1e1e;
      --bg-light: #252526;
      --bg-hover: #2d2d2d;
      --fg: #d4d4d4;
      --accent: #569cd6;
      --success: #4ec9b0;
      --error: #f44747;
      --warning: #dcdcaa;
      --string: #ce9178;
      --keyword: #c586c0;
      --comment: #6a9955;
      --muted: #808080;
      --border: #3c3c3c;
    }

    * { box-sizing: border-box; }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      font-size: 13px;
      background: var(--bg);
      color: var(--fg);
      margin: 0;
      padding: 20px;
      line-height: 1.5;
    }

    h1 {
      font-size: 18px;
      font-weight: 500;
      margin: 0 0 20px 0;
      color: var(--accent);
    }

    .drop-zone {
      border: 2px dashed var(--border);
      border-radius: 8px;
      padding: 40px;
      text-align: center;
      margin-bottom: 20px;
      transition: all 0.2s;
    }

    .drop-zone.dragover {
      border-color: var(--accent);
      background: rgba(86, 156, 214, 0.1);
    }

    .drop-zone p { margin: 0 0 10px 0; color: var(--muted); }
    input[type="file"] { display: none; }

    .btn {
      background: var(--accent);
      color: #fff;
      border: none;
      padding: 8px 16px;
      border-radius: 4px;
      cursor: pointer;
      font-family: inherit;
      font-size: 13px;
    }
    .btn:hover { opacity: 0.9; }

    .summary {
      background: var(--bg-light);
      border-radius: 8px;
      padding: 16px;
      margin-bottom: 20px;
      display: none;
    }
    .summary.visible { display: block; }

    .summary-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
      gap: 16px;
    }

    .summary-item { text-align: center; }
    .summary-value { font-size: 24px; font-weight: 600; color: var(--accent); }
    .summary-label { font-size: 11px; color: var(--muted); text-transform: uppercase; }

    /* Timeline */
    .timeline {
      background: var(--bg-light);
      border-radius: 8px;
      padding: 16px;
      margin-bottom: 20px;
      display: none;
      overflow-x: auto;
    }
    .timeline.visible { display: block; }
    .timeline h3 { margin: 0 0 12px 0; font-size: 14px; color: var(--muted); }

    .timeline-bar {
      height: 24px;
      background: var(--bg);
      border-radius: 4px;
      position: relative;
      margin-bottom: 8px;
      min-width: 600px;
    }

    .timeline-segment {
      position: absolute;
      height: 100%;
      border-radius: 3px;
      cursor: pointer;
      transition: opacity 0.2s;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 10px;
      color: #fff;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
      padding: 0 4px;
    }
    .timeline-segment:hover { opacity: 0.8; }
    .timeline-segment.llm { background: var(--accent); }
    .timeline-segment.tool { background: var(--warning); }
    .timeline-segment.pmap { background: var(--keyword); }
    .timeline-segment.task { background: var(--success); }

    /* Event cards */
    .events { display: none; }
    .events.visible { display: block; }

    .event-card {
      background: var(--bg-light);
      border-radius: 8px;
      margin-bottom: 12px;
      overflow: hidden;
      border-left: 3px solid var(--border);
    }
    .event-card.llm { border-left-color: var(--accent); }
    .event-card.tool { border-left-color: var(--warning); }
    .event-card.pmap { border-left-color: var(--keyword); }
    .event-card.task { border-left-color: var(--success); }
    .event-card.error { border-left-color: var(--error); }

    .event-header {
      padding: 12px 16px;
      display: flex;
      align-items: center;
      gap: 12px;
      cursor: pointer;
      user-select: none;
    }
    .event-header:hover { background: var(--bg-hover); }

    .event-toggle {
      width: 20px;
      height: 20px;
      display: flex;
      align-items: center;
      justify-content: center;
      color: var(--muted);
      font-size: 16px;
    }

    .event-icon {
      width: 28px;
      height: 28px;
      border-radius: 6px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 14px;
    }
    .event-icon.llm { background: rgba(86, 156, 214, 0.2); color: var(--accent); }
    .event-icon.tool { background: rgba(220, 220, 170, 0.2); color: var(--warning); }
    .event-icon.pmap { background: rgba(197, 134, 192, 0.2); color: var(--keyword); }
    .event-icon.task { background: rgba(78, 201, 176, 0.2); color: var(--success); }

    .event-title { flex: 1; font-weight: 500; }
    .event-meta { color: var(--muted); font-size: 12px; display: flex; gap: 16px; }
    .event-meta span { display: flex; align-items: center; gap: 4px; }

    .event-body {
      display: none;
      border-top: 1px solid var(--border);
    }
    .event-card.expanded .event-body { display: block; }
    .event-card.expanded .event-toggle { transform: rotate(90deg); }

    .event-section {
      padding: 12px 16px;
      border-bottom: 1px solid var(--border);
    }
    .event-section:last-child { border-bottom: none; }
    .event-section-title {
      font-size: 11px;
      text-transform: uppercase;
      color: var(--muted);
      margin-bottom: 8px;
      font-weight: 600;
    }

    /* Code blocks */
    .code-block {
      background: var(--bg);
      border-radius: 6px;
      padding: 12px;
      font-family: 'SF Mono', 'Consolas', 'Monaco', monospace;
      font-size: 12px;
      line-height: 1.6;
      overflow-x: auto;
      white-space: pre-wrap;
      word-break: break-word;
    }

    /* Syntax highlighting for Lisp */
    .code-block .keyword { color: var(--keyword); }
    .code-block .builtin { color: var(--accent); }
    .code-block .string { color: var(--string); }
    .code-block .comment { color: var(--comment); font-style: italic; }
    .code-block .number { color: var(--success); }
    .code-block .symbol { color: var(--warning); }

    /* Thinking block */
    .thinking-block {
      background: rgba(106, 153, 85, 0.1);
      border-left: 3px solid var(--comment);
      padding: 12px;
      border-radius: 0 6px 6px 0;
      margin-bottom: 12px;
      font-size: 12px;
      color: var(--comment);
      white-space: pre-wrap;
    }

    /* Child traces */
    .child-traces {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
      gap: 8px;
    }

    .child-trace-item {
      background: var(--bg);
      border-radius: 6px;
      padding: 10px 12px;
      cursor: pointer;
      display: flex;
      justify-content: space-between;
      align-items: center;
      transition: background 0.2s;
    }
    .child-trace-item:hover { background: var(--bg-hover); }
    .child-trace-item .id { font-family: monospace; color: var(--accent); }
    .child-trace-item .status { font-size: 11px; color: var(--success); }

    /* File list */
    .file-list {
      margin-top: 20px;
      padding-top: 20px;
      border-top: 1px solid var(--border);
      display: none;
    }
    .file-list.visible { display: block; }
    .file-list h2 { font-size: 14px; margin: 0 0 10px 0; color: var(--muted); }

    .file-item {
      padding: 8px 12px;
      margin: 4px 0;
      background: var(--bg-light);
      border-radius: 4px;
      cursor: pointer;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    .file-item:hover { background: var(--bg-hover); }
    .file-item.active { border-left: 3px solid var(--accent); background: var(--bg-hover); }

    .instructions {
      background: var(--bg-light);
      border-radius: 8px;
      padding: 16px;
      margin-top: 20px;
      font-size: 12px;
      color: var(--muted);
    }
    .instructions code {
      background: var(--bg);
      padding: 2px 6px;
      border-radius: 3px;
      color: var(--warning);
      font-family: monospace;
    }

    /* Agent tree */
    .agent-tree {
      background: var(--bg-light);
      border-radius: 8px;
      padding: 16px;
      margin-bottom: 20px;
      display: none;
      max-height: 260px;
      overflow-y: auto;
    }
    .agent-tree.visible { display: block; }
    .agent-tree h3 { margin: 0 0 12px 0; font-size: 14px; color: var(--muted); }

    .agent-tree ul {
      list-style: none;
      padding-left: 20px;
      margin: 0;
    }
    .agent-tree > ul { padding-left: 0; }

    .agent-tree li { margin: 2px 0; }

    .agent-tree-node {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      padding: 4px 8px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 13px;
      user-select: none;
    }
    .agent-tree-node:hover { background: var(--bg-hover); }
    .agent-tree-node.active { background: rgba(86, 156, 214, 0.2); color: var(--accent); }

    .agent-tree-node .name { font-weight: 500; }
    .agent-tree-node .badge {
      font-size: 11px;
      color: var(--muted);
      background: var(--bg);
      padding: 1px 6px;
      border-radius: 3px;
    }
    .agent-tree-node .toggle {
      font-size: 10px;
      color: var(--muted);
      width: 12px;
      text-align: center;
    }

    /* Tabs */
    .tabs {
      display: flex;
      gap: 4px;
      margin-bottom: 16px;
      border-bottom: 1px solid var(--border);
      padding-bottom: 8px;
    }
    .tab {
      padding: 8px 16px;
      background: transparent;
      border: none;
      color: var(--muted);
      cursor: pointer;
      border-radius: 4px;
      font-size: 13px;
    }
    .tab:hover { background: var(--bg-hover); color: var(--fg); }
    .tab.active { background: var(--accent); color: #fff; }

    /* Plan Card */
    .plan-card {
      background: var(--bg-light);
      border-radius: 8px;
      margin-bottom: 20px;
      display: none;
      border: 1px solid var(--border);
      overflow: hidden;
    }
    .plan-card.visible { display: block; }

    .plan-header {
      padding: 16px;
      display: flex;
      align-items: center;
      gap: 12px;
      cursor: pointer;
      user-select: none;
      background: linear-gradient(135deg, rgba(86, 156, 214, 0.1), rgba(197, 134, 192, 0.1));
      border-bottom: 1px solid var(--border);
    }
    .plan-header:hover { background: linear-gradient(135deg, rgba(86, 156, 214, 0.15), rgba(197, 134, 192, 0.15)); }
    .plan-header h3 { margin: 0; font-size: 15px; flex: 1; display: flex; align-items: center; gap: 8px; }
    .plan-header .toggle { color: var(--muted); font-size: 14px; transition: transform 0.2s; }
    .plan-card.expanded .plan-header .toggle { transform: rotate(90deg); }

    .plan-body { display: none; }
    .plan-card.expanded .plan-body { display: block; }

    .plan-section {
      padding: 16px;
      border-bottom: 1px solid var(--border);
    }
    .plan-section:last-child { border-bottom: none; }

    .plan-section-title {
      font-size: 12px;
      text-transform: uppercase;
      color: var(--muted);
      margin-bottom: 12px;
      font-weight: 600;
      display: flex;
      align-items: center;
      gap: 8px;
    }
    .plan-section-title .count {
      background: var(--accent);
      color: #fff;
      padding: 2px 8px;
      border-radius: 10px;
      font-size: 11px;
    }

    /* Agent cards in plan */
    .agent-cards {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
      gap: 12px;
    }
    .agent-card {
      background: var(--bg);
      border-radius: 6px;
      padding: 12px;
      border-left: 3px solid var(--keyword);
    }
    .agent-card-header {
      display: flex;
      align-items: center;
      gap: 8px;
      margin-bottom: 8px;
    }
    .agent-card-name {
      font-weight: 600;
      color: var(--keyword);
      font-family: monospace;
    }
    .agent-card-tools {
      display: flex;
      flex-wrap: wrap;
      gap: 4px;
      margin-top: 8px;
    }
    .agent-tool-tag {
      background: rgba(220, 220, 170, 0.2);
      color: var(--warning);
      padding: 2px 8px;
      border-radius: 4px;
      font-size: 11px;
      font-family: monospace;
    }
    .agent-card-prompt {
      font-size: 12px;
      color: var(--muted);
      white-space: pre-wrap;
      max-height: 60px;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    /* Task flow in plan */
    .task-flow {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }
    .task-item {
      background: var(--bg);
      border-radius: 6px;
      padding: 12px;
      border-left: 3px solid var(--success);
      position: relative;
    }
    .task-item.synthesis { border-left-color: var(--accent); }
    .task-item.human_review { border-left-color: var(--warning); }

    .task-item-header {
      display: flex;
      align-items: center;
      gap: 8px;
      margin-bottom: 6px;
    }
    .task-id {
      font-weight: 600;
      color: var(--success);
      font-family: monospace;
    }
    .task-item.synthesis .task-id { color: var(--accent); }
    .task-type-badge {
      font-size: 10px;
      padding: 2px 6px;
      border-radius: 3px;
      background: rgba(78, 201, 176, 0.2);
      color: var(--success);
      text-transform: uppercase;
    }
    .task-item.synthesis .task-type-badge { background: rgba(86, 156, 214, 0.2); color: var(--accent); }
    .task-item.human_review .task-type-badge { background: rgba(220, 220, 170, 0.2); color: var(--warning); }

    .task-agent-ref {
      font-size: 11px;
      color: var(--keyword);
      font-family: monospace;
    }
    .task-input {
      font-size: 12px;
      color: var(--fg);
      margin: 8px 0;
      white-space: pre-wrap;
      max-height: 80px;
      overflow: hidden;
    }
    .task-deps {
      display: flex;
      gap: 4px;
      flex-wrap: wrap;
      margin-top: 8px;
    }
    .task-dep-tag {
      background: var(--bg-light);
      color: var(--muted);
      padding: 2px 6px;
      border-radius: 3px;
      font-size: 10px;
      font-family: monospace;
    }
    .task-verification {
      margin-top: 8px;
      padding-top: 8px;
      border-top: 1px solid var(--border);
      font-size: 11px;
    }
    .task-verification code {
      background: var(--bg-light);
      padding: 4px 8px;
      border-radius: 4px;
      font-family: monospace;
      color: var(--comment);
      display: block;
      margin-top: 4px;
      white-space: pre-wrap;
    }

    /* Mission display */
    .mission-text {
      background: var(--bg);
      border-radius: 6px;
      padding: 12px;
      font-size: 13px;
      white-space: pre-wrap;
      border-left: 3px solid var(--accent);
      max-height: 200px;
      overflow-y: auto;
    }

    /* DAG Graph */
    .dag-graph {
      background: var(--bg-light);
      border-radius: 8px;
      padding: 16px;
      margin-bottom: 20px;
      display: none;
      border: 1px solid var(--border);
    }
    .dag-graph.visible { display: block; }
    .dag-header {
      display: flex;
      align-items: center;
      gap: 8px;
      cursor: pointer;
      user-select: none;
      padding-bottom: 4px;
    }
    .dag-header:hover { opacity: 0.8; }
    .dag-header h3 {
      margin: 0;
      font-size: 14px;
      color: var(--muted);
      flex: 1;
      display: flex;
      align-items: center;
      gap: 8px;
    }
    .dag-header .toggle {
      color: var(--muted);
      font-size: 14px;
      transition: transform 0.2s;
    }
    .dag-graph.expanded .dag-header .toggle { transform: rotate(90deg); }
    .dag-body { display: none; }
    .dag-graph.expanded .dag-body { display: block; }
    .dag-container {
      overflow-x: auto;
      overflow-y: auto;
      max-height: 500px;
    }
    .dag-phase-label {
      font-size: 11px;
      text-transform: uppercase;
      fill: var(--muted);
      font-weight: 600;
    }
    .dag-node { cursor: pointer; }
    .dag-node rect {
      rx: 8;
      ry: 8;
      stroke-width: 2;
      transition: stroke-width 0.15s, filter 0.15s;
    }
    .dag-node:hover rect {
      stroke-width: 3;
      filter: brightness(1.2);
    }
    .dag-node text { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; }
    .dag-node .node-id { font-size: 12px; font-weight: 600; }
    .dag-node .node-agent { font-size: 10px; }
    .dag-node .node-badge { font-size: 9px; font-weight: 600; }
    .dag-node .node-duration { font-size: 10px; }
    .dag-edge {
      fill: none;
      stroke: var(--border);
      stroke-width: 1.5;
      transition: stroke 0.15s, stroke-width 0.15s;
    }
    .dag-edge.highlighted {
      stroke: var(--accent);
      stroke-width: 2.5;
    }
    .dag-arrowhead { fill: var(--border); }
    .dag-arrowhead.highlighted { fill: var(--accent); }

    .dag-tooltip {
      position: fixed;
      background: var(--bg);
      border: 1px solid var(--border);
      border-radius: 6px;
      padding: 10px 12px;
      font-size: 12px;
      color: var(--fg);
      pointer-events: none;
      z-index: 100;
      max-width: 300px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.4);
      display: none;
    }
    .dag-tooltip .tt-label { color: var(--muted); font-size: 10px; text-transform: uppercase; margin-bottom: 2px; }
    .dag-tooltip .tt-value { margin-bottom: 6px; }

    /* DAG tabs for replan attempts */
    .dag-tabs {
      display: flex;
      gap: 4px;
      margin-bottom: 12px;
      border-bottom: 1px solid var(--border);
      padding-bottom: 8px;
    }
    .dag-tab {
      padding: 6px 14px;
      background: transparent;
      border: 1px solid transparent;
      border-radius: 4px;
      color: var(--muted);
      cursor: pointer;
      font-size: 12px;
      font-family: inherit;
    }
    .dag-tab:hover { background: var(--bg-hover); color: var(--fg); }
    .dag-tab.active { background: var(--accent); color: #fff; }
    .dag-tab.replan { border-color: var(--warning); }
    .dag-tab.replan.active { background: var(--warning); color: var(--bg); }

    .dag-replan-info {
      background: rgba(220, 220, 170, 0.1);
      border-left: 3px solid var(--warning);
      border-radius: 0 6px 6px 0;
      padding: 8px 12px;
      margin-bottom: 12px;
      font-size: 12px;
      color: var(--warning);
    }
    .dag-replan-info .trigger { color: var(--error); font-family: monospace; font-weight: 600; }

    /* Flash animation for clicked event card */
    .event-card.dag-highlight {
      animation: dagFlash 1.5s ease-out;
    }
    @keyframes dagFlash {
      0% { box-shadow: 0 0 0 3px var(--accent); }
      100% { box-shadow: 0 0 0 0 transparent; }
    }
  </style>
</head>
<body>
  <h1>üîç PTC Trace Viewer</h1>

  <div class="drop-zone" id="dropZone">
    <p>Drop .jsonl trace files here or click to select</p>
    <p style="font-size: 11px;">Select the main trace + child traces to view the full hierarchy</p>
    <button class="btn" onclick="document.getElementById('fileInput').click()">Select Files</button>
    <input type="file" id="fileInput" accept=".jsonl" multiple>
  </div>

  <div class="summary" id="summary">
    <div class="summary-grid">
      <div class="summary-item">
        <div class="summary-value" id="summaryDuration">-</div>
        <div class="summary-label">Duration</div>
      </div>
      <div class="summary-item">
        <div class="summary-value" id="summaryTurns">-</div>
        <div class="summary-label">Turns</div>
      </div>
      <div class="summary-item">
        <div class="summary-value" id="summaryLLM">-</div>
        <div class="summary-label">LLM Calls</div>
      </div>
      <div class="summary-item">
        <div class="summary-value" id="summaryTokens">-</div>
        <div class="summary-label">Tokens</div>
        <div id="summaryTokenBreakdown" style="font-size: 10px; color: var(--muted); margin-top: 2px;"></div>
      </div>
      <div class="summary-item" style="display: none;">
        <div class="summary-value" id="summaryTasks">-</div>
        <div class="summary-label">Tasks</div>
      </div>
      <div class="summary-item">
        <div class="summary-value" id="summaryChildren">-</div>
        <div class="summary-label">Children</div>
      </div>
    </div>
    <div id="aggregateStats" style="margin-top: 16px; padding-top: 16px; border-top: 1px solid var(--border); display: none;">
      <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 12px;">
        <span style="color: var(--muted); font-size: 12px; text-transform: uppercase;">Total (including children)</span>
        <button class="btn" id="loadChildrenBtn" style="font-size: 11px; padding: 4px 10px;">Load All Children</button>
      </div>
      <div class="summary-grid">
        <div class="summary-item">
          <div class="summary-value" id="totalTurns">-</div>
          <div class="summary-label">Total Turns</div>
        </div>
        <div class="summary-item">
          <div class="summary-value" id="totalLLM">-</div>
          <div class="summary-label">Total LLM Calls</div>
        </div>
        <div class="summary-item">
          <div class="summary-value" id="totalTokens">-</div>
          <div class="summary-label">Total Tokens</div>
        </div>
        <div class="summary-item">
          <div class="summary-value" id="loadedChildren">-</div>
          <div class="summary-label">Loaded</div>
        </div>
      </div>
    </div>
  </div>

  <div class="plan-card" id="planCard">
    <div class="plan-header" onclick="document.getElementById('planCard').classList.toggle('expanded')">
      <span class="toggle">‚ñ∂</span>
      <h3>üìã Execution Plan</h3>
      <span id="planMeta" style="color: var(--muted); font-size: 12px;"></span>
    </div>
    <div class="plan-body" id="planBody"></div>
  </div>

  <div class="dag-graph" id="dagGraph">
    <div class="dag-header" onclick="document.getElementById('dagGraph').classList.toggle('expanded')">
      <span class="toggle">‚ñ∂</span>
      <h3>üìä Task Execution Graph</h3>
      <span id="dagMeta" style="color: var(--muted); font-size: 12px;"></span>
    </div>
    <div class="dag-body">
      <div class="dag-container" id="dagGraphContainer"></div>
    </div>
  </div>
  <div class="dag-tooltip" id="dagTooltip"></div>

  <div class="agent-tree" id="agentTree">
    <h3>Agent Hierarchy</h3>
    <div id="agentTreeContent"></div>
  </div>

  <div class="timeline" id="timeline">
    <h3>Timeline</h3>
    <div class="timeline-bar" id="timelineBar"></div>
  </div>

  <div class="tabs" id="tabs" style="display: none;">
    <button class="tab active" data-filter="all">All Events</button>
    <button class="tab" data-filter="llm">LLM Calls</button>
    <button class="tab" data-filter="tool">Tools</button>
    <button class="tab" data-filter="pmap">Parallel</button>
    <button class="tab" data-filter="task">Tasks</button>
  </div>

  <div class="events" id="events"></div>

  <div class="file-list" id="fileList">
    <h2>Loaded Files</h2>
    <div id="fileListItems"></div>
  </div>

  <div class="instructions">
    <strong>Usage:</strong><br>
    1. Run with tracing: <code>mix parallel_workers --trace</code><br>
    2. Drop all .jsonl files from <code>examples/parallel_workers/traces/</code> here<br>
    3. Click on events to expand details, click child traces to navigate
  </div>

  <script>
    const dropZone = document.getElementById('dropZone');
    const fileInput = document.getElementById('fileInput');
    const summary = document.getElementById('summary');
    const timeline = document.getElementById('timeline');
    const timelineBar = document.getElementById('timelineBar');
    const tabs = document.getElementById('tabs');
    const eventsContainer = document.getElementById('events');
    const fileList = document.getElementById('fileList');
    const fileListItems = document.getElementById('fileListItems');

    let loadedFiles = new Map();
    let currentFile = null;
    let currentFilter = 'all';

    // Drag and drop
    dropZone.addEventListener('dragover', (e) => { e.preventDefault(); dropZone.classList.add('dragover'); });
    dropZone.addEventListener('dragleave', () => { dropZone.classList.remove('dragover'); });
    dropZone.addEventListener('drop', (e) => { e.preventDefault(); dropZone.classList.remove('dragover'); handleFiles(e.dataTransfer.files); });
    fileInput.addEventListener('change', (e) => { handleFiles(e.target.files); });

    // Tab filtering
    document.querySelectorAll('.tab').forEach(tab => {
      tab.addEventListener('click', () => {
        document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
        tab.classList.add('active');
        currentFilter = tab.dataset.filter;
        if (currentFile) displayTrace(currentFile);
      });
    });

    async function handleFiles(files) {
      for (const file of files) {
        const text = await file.text();
        const events = parseJsonl(text);
        const traceId = extractTraceId(events);
        loadedFiles.set(file.name, { events, traceId, filename: file.name });
      }
      updateFileList();
      if (!currentFile && loadedFiles.size > 0) {
        const mainTrace = [...loadedFiles.entries()].find(([name]) => name.includes('rlm_trace') || !name.startsWith('trace_'));
        currentFile = mainTrace ? mainTrace[0] : [...loadedFiles.keys()][0];
      }
      if (currentFile) displayTrace(currentFile);
    }

    function parseJsonl(text) {
      return text.trim().split('\n').filter(l => l.trim()).map(line => {
        try { return JSON.parse(line); } catch { return null; }
      }).filter(Boolean);
    }

    function extractTraceId(events) {
      return events.find(e => e.event === 'trace.start')?.trace_id || 'unknown';
    }

    function updateFileList() {
      fileList.classList.toggle('visible', loadedFiles.size > 0);
      fileListItems.innerHTML = '';
      for (const [name, data] of loadedFiles) {
        const item = document.createElement('div');
        item.className = 'file-item' + (name === currentFile ? ' active' : '');
        item.innerHTML = `<span>${name}</span><span style="color: var(--muted); font-size: 11px;">${data.traceId.slice(0, 8)}...</span>`;
        item.onclick = () => { currentFile = name; displayTrace(name); updateFileList(); };
        fileListItems.appendChild(item);
      }
    }

    function displayTrace(filename) {
      const data = loadedFiles.get(filename);
      if (!data) return;

      const events = data.events;
      const paired = pairEvents(events);

      // Summary
      summary.classList.add('visible');
      const llmEvents = paired.filter(e => e.type === 'llm');
      // Duration: prefer execution.stop (plan executor), then run.stop (subagent), then trace.stop (fallback)
      const execStop = events.find(e => e.event === 'execution.stop');
      const runStop = events.find(e => e.event === 'run.stop');
      const traceStop = events.find(e => e.event === 'trace.stop');
      const totalDuration = execStop?.duration_ms || runStop?.duration_ms || traceStop?.duration_ms || 0;
      const totalTokens = llmEvents.reduce((sum, e) => sum + (e.stop?.measurements?.tokens || 0), 0);
      const totalInputTokens = llmEvents.reduce((sum, e) => sum + (e.stop?.measurements?.input_tokens || 0), 0);
      const totalOutputTokens = llmEvents.reduce((sum, e) => sum + (e.stop?.measurements?.output_tokens || 0), 0);
      const totalCacheRead = llmEvents.reduce((sum, e) => sum + (e.stop?.measurements?.cache_read_tokens || 0), 0);
      const childIds = extractChildTraceIds(events);

      document.getElementById('summaryDuration').textContent = formatDuration(totalDuration);
      // Count turns from LLM events (max turn number)
      const maxTurn = llmEvents.reduce((max, e) => Math.max(max, e.stop?.metadata?.turn || 0), 0);
      document.getElementById('summaryTurns').textContent = maxTurn;
      document.getElementById('summaryLLM').textContent = llmEvents.length;
      document.getElementById('summaryTokens').textContent = totalTokens.toLocaleString();
      // Token breakdown subtitle
      const breakdownEl = document.getElementById('summaryTokenBreakdown');
      if (totalInputTokens || totalOutputTokens) {
        let bd = `${formatTokens(totalInputTokens)} in / ${formatTokens(totalOutputTokens)} out`;
        if (totalCacheRead > 0) bd += ` (${formatTokens(totalCacheRead)} cached)`;
        breakdownEl.textContent = bd;
      } else {
        breakdownEl.textContent = '';
      }
      // Task count from paired task events
      const taskEvents = paired.filter(e => e.type === 'task');
      const taskCountEl = document.getElementById('summaryTasks');
      if (taskEvents.length > 0) {
        taskCountEl.textContent = taskEvents.length;
        taskCountEl.closest('.summary-item').style.display = '';
      } else {
        taskCountEl.closest('.summary-item').style.display = 'none';
      }
      document.getElementById('summaryChildren').textContent = childIds.length;

      // Show aggregate stats section if there are children
      const aggregateSection = document.getElementById('aggregateStats');
      if (childIds.length > 0) {
        aggregateSection.style.display = 'block';
        updateAggregateStats();
      } else {
        aggregateSection.style.display = 'none';
      }

      // Timeline
      timeline.classList.add('visible');
      renderTimeline(paired, totalDuration);

      // Events
      tabs.style.display = 'flex';
      eventsContainer.classList.add('visible');
      renderEvents(paired);

      // Update tree active state
      document.querySelectorAll('.agent-tree-node').forEach(el => {
        el.classList.toggle('active', el.dataset.filename === filename);
      });
    }

    function pairEvents(events) {
      const pairs = [];
      const pending = {};

      for (const event of events) {
        if (!event.event) continue;
        const [type, action] = event.event.split('.');

        // Use span_id for pairing (most reliable), fallback to type+turn/tool_name
        const spanId = event.span_id;
        const key = spanId ? `${type}-${spanId}` :
          `${type}-${event.metadata?.task_id || event.metadata?.turn || event.metadata?.tool_name || ''}`;

        if (action === 'start') {
          pending[key] = event;
        } else if (action === 'stop') {
          const startEvent = pending[key];
          if (startEvent) {
            pairs.push({ type, start: startEvent, stop: event });
            delete pending[key];
          } else {
            // No matching start - create a stop-only pair for display
            pairs.push({ type, start: null, stop: event });
          }
        }
      }

      // Surface unpaired start events (e.g., from truncated/crashed traces)
      for (const [key, startEvent] of Object.entries(pending)) {
        const type = key.split('-')[0];
        pairs.push({ type, start: startEvent, stop: null });
      }

      return pairs;
    }

    function extractChildTraceIds(events) {
      const ids = new Set();
      for (const e of events) {
        (e.child_trace_ids || []).forEach(id => ids.add(id));
        if (e.child_trace_id) ids.add(e.child_trace_id);
        (e.metadata?.child_trace_ids || []).forEach(id => ids.add(id));
      }
      return [...ids];
    }

    function renderTimeline(pairs, totalDuration) {
      timelineBar.innerHTML = '';
      if (!totalDuration) return;

      // Get the start timestamp as reference
      const startTs = getEarliestTimestamp(pairs);

      for (const pair of pairs) {
        if (!['llm', 'tool', 'pmap', 'pcalls', 'task'].includes(pair.type)) continue;
        const duration = pair.stop?.duration_ms || 0;
        if (duration === 0) continue;

        // Calculate position based on timestamps if available
        let left = 0;
        if (pair.start?.timestamp && startTs) {
          const eventStart = new Date(pair.start.timestamp).getTime();
          const offsetMs = eventStart - startTs;
          left = (offsetMs / totalDuration) * 100;
        }

        const width = (duration / totalDuration) * 100;

        const segment = document.createElement('div');
        segment.className = `timeline-segment ${pair.type}`;
        segment.style.left = `${Math.max(0, left)}%`;
        segment.style.width = `${Math.max(width, 1)}%`;
        segment.textContent = pair.type === 'llm' ? `T${pair.stop?.metadata?.turn || '?'}` :
          pair.type === 'task' ? (pair.stop?.metadata?.task_id || pair.start?.metadata?.task_id || 'task') : pair.type;
        segment.title = `${pair.type}: ${formatDuration(duration)}`;
        timelineBar.appendChild(segment);
      }
    }

    function getEarliestTimestamp(pairs) {
      let earliest = null;
      for (const pair of pairs) {
        if (pair.start?.timestamp) {
          const ts = new Date(pair.start.timestamp).getTime();
          if (!earliest || ts < earliest) earliest = ts;
        }
      }
      return earliest;
    }

    function renderEvents(pairs) {
      const displayableTypes = ['llm', 'tool', 'pmap', 'pcalls', 'task'];
      // Build turn lookup: turn number -> turn pair (for merging into LLM cards)
      const turnByNum = {};
      pairs.filter(p => p.type === 'turn').forEach(p => {
        const num = p.stop?.metadata?.turn || p.start?.metadata?.turn;
        if (num) turnByNum[num] = p;
      });
      let filtered = pairs.filter(p => displayableTypes.includes(p.type));
      if (currentFilter !== 'all') {
        filtered = filtered.filter(p => p.type === currentFilter);
      }
      eventsContainer.innerHTML = filtered.map(pair => renderEventCard(pair, turnByNum)).join('');

      // Add click handlers
      eventsContainer.querySelectorAll('.event-header').forEach(header => {
        header.onclick = () => header.closest('.event-card').classList.toggle('expanded');
      });

      // Child trace navigation
      eventsContainer.querySelectorAll('.child-trace-item').forEach(item => {
        item.onclick = () => {
          const traceId = item.dataset.traceid;
          const file = findFileByTraceId(traceId);
          if (file) { currentFile = file; displayTrace(file); updateFileList(); }
        };
      });
    }

    function renderEventCard(pair, turnByNum) {
      const { type, start, stop } = pair;
      const duration = stop?.duration_ms || 0;
      const tokens = stop?.measurements?.tokens || stop?.metadata?.tokens || 0;
      const turn = stop?.metadata?.turn || start?.metadata?.turn;
      const hasError = stop?.metadata?.error;

      let title = type;
      let icon = 'üì¶';
      let meta = [];

      if (type === 'llm') {
        title = `LLM Call${turn ? ` (Turn ${turn})` : ''}`;
        icon = 'ü§ñ';
        meta.push(`<span>‚è± ${formatDuration(duration)}</span>`);
        meta.push(`<span>üìä ${formatTokenBreakdown(stop?.measurements)}</span>`);
      } else if (type === 'tool') {
        title = stop?.metadata?.tool_name || 'Tool';
        icon = 'üîß';
        meta.push(`<span>‚è± ${formatDuration(duration)}</span>`);
      } else if (type === 'pmap' || type === 'pcalls') {
        const count = stop?.metadata?.count || '?';
        title = `${type} (${count} tasks)`;
        icon = '‚ö°';
        meta.push(`<span>‚è± ${formatDuration(duration)}</span>`);
        meta.push(`<span>‚úì ${stop?.metadata?.success_count || 0} / ‚úó ${stop?.metadata?.error_count || 0}</span>`);
      } else if (type === 'task') {
        const taskId = stop?.metadata?.task_id || start?.metadata?.task_id || '?';
        const agentName = start?.metadata?.agent || stop?.metadata?.agent || '';
        const status = stop?.metadata?.status;
        title = `Task: ${taskId}${agentName ? ` ‚Üí ${agentName}` : ''}`;
        icon = 'üìã';
        meta.push(`<span>‚è± ${formatDuration(duration)}</span>`);
        if (status) {
          const statusColor = status === 'ok' ? 'var(--success)' : (status === 'error' ? 'var(--error)' : 'var(--warning)');
          meta.push(`<span style="color: ${statusColor}">${status}</span>`);
        }
        // Show output mode (PTC-Lisp vs JSON) from the task's run.start agent metadata
        const taskOutput = start?.metadata?.output || stop?.metadata?.output;
        if (taskOutput) {
          const label = taskOutput === 'ptc_lisp' ? 'PTC-Lisp' : 'JSON';
          meta.push(`<span style="color: var(--accent);">${label}</span>`);
        }
      }

      let bodyContent = '';

      // LLM specific content
      if (type === 'llm') {
        const response = stop?.metadata?.response || '';
        const thinking = extractThinking(response);
        const program = extractProgram(response);
        const prompt = getLastUserMessage(start?.metadata?.messages);
        const systemPrompt = start?.metadata?.system_prompt;

        if (systemPrompt) {
          const previewLen = 120;
          const preview = systemPrompt.length > previewLen
            ? escapeHtml(systemPrompt.slice(0, previewLen)) + '...'
            : escapeHtml(systemPrompt);
          bodyContent += `
            <div class="event-section">
              <details class="system-prompt-details">
                <summary class="event-section-title" style="cursor: pointer; list-style: none;">üîß System Prompt <span style="color: var(--muted); font-size: 11px;">(${(systemPrompt.length / 1024).toFixed(1)}KB ‚Äî click to expand)</span></summary>
                <div class="code-block" style="max-height: 600px; overflow-y: auto; border-left: 2px solid var(--accent); white-space: pre-wrap;">${escapeHtml(systemPrompt)}</div>
              </details>
            </div>`;
        }

        if (thinking) {
          bodyContent += `
            <div class="event-section">
              <div class="event-section-title">üí≠ Thinking</div>
              <div class="thinking-block">${escapeHtml(thinking)}</div>
            </div>`;
        }

        if (program) {
          bodyContent += `
            <div class="event-section">
              <div class="event-section-title">üìù Program</div>
              <div class="code-block">${highlightLisp(program)}</div>
            </div>`;
        }

        if (prompt) {
          const isStub = /^String\(\d+ bytes\)$/.test(prompt);
          if (isStub) {
            bodyContent += `
              <div class="event-section">
                <div class="event-section-title">üì® Prompt <span style="color: var(--muted); font-size: 11px;">(not captured ‚Äî re-run with updated tracer)</span></div>
                <div class="code-block"><span style="color: var(--muted)">${escapeHtml(prompt)}</span></div>
              </div>`;
          } else if (turn > 1) {
            // Turn 2+ prompts are error/result feedback ‚Äî show collapsed
            bodyContent += `
              <div class="event-section">
                <details>
                  <summary class="event-section-title" style="cursor: pointer; list-style: none;">üì® Feedback from Turn ${turn - 1} <span style="color: var(--muted); font-size: 11px;">(click to expand)</span></summary>
                  <div class="code-block" style="max-height: 300px; overflow-y: auto;">${escapeHtml(truncate(prompt, 2000))}</div>
                </details>
              </div>`;
          } else {
            bodyContent += `
              <div class="event-section">
                <div class="event-section-title">üì® Prompt</div>
                <div class="code-block" style="max-height: 300px; overflow-y: auto;">${escapeHtml(truncate(prompt, 2000))}</div>
              </div>`;
          }
        }

        // Merge matching turn data (result, prints) into LLM card
        const turnPair = turnByNum && turnByNum[turn];
        if (turnPair) {
          const turnStop = turnPair.stop?.metadata || {};

          const resultPreview = turnStop.result_preview;
          if (resultPreview && resultPreview !== 'nil') {
            const isError = resultPreview.includes('Error:') || resultPreview.includes(':error');
            const titleIcon = isError ? '‚ùå' : 'üì§';
            const titleText = isError ? 'Error' : 'Result';
            bodyContent += `
              <div class="event-section">
                <div class="event-section-title">${titleIcon} ${titleText}</div>
                <div class="code-block"${isError ? ' style="border-left: 2px solid var(--error);"' : ''}>${escapeHtml(resultPreview)}</div>
              </div>`;
          }

          const prints = turnStop.prints;
          if (Array.isArray(prints) && prints.length > 0) {
            bodyContent += `
              <div class="event-section">
                <div class="event-section-title">üñ® Output (${prints.length})</div>
                <div class="code-block" style="max-height: 300px; overflow-y: auto;">${prints.map(p => escapeHtml(p)).join('\n')}</div>
              </div>`;
          }
        }
      }

      // Child traces (support both plural child_trace_ids and singular child_trace_id)
      const childIds = stop?.metadata?.child_trace_ids ||
        (stop?.metadata?.child_trace_id ? [stop.metadata.child_trace_id] : []);
      if (childIds.length > 0) {
        bodyContent += `
          <div class="event-section">
            <div class="event-section-title">üë∂ Child Traces (${childIds.length})</div>
            <div class="child-traces">
              ${childIds.map(id => {
                const file = findFileByTraceId(id);
                return `<div class="child-trace-item" data-traceid="${id}">
                  <span class="id">${id.slice(0, 12)}...</span>
                  <span class="status">${file ? '‚Üí' : '(not loaded)'}</span>
                </div>`;
              }).join('')}
            </div>
          </div>`;
      }

      // Tool args (check both start and stop metadata)
      const toolArgs = start?.metadata?.args || stop?.metadata?.args;
      if (type === 'tool' && toolArgs) {
        bodyContent += `
          <div class="event-section">
            <div class="event-section-title">üì• Arguments</div>
            <div class="code-block" style="max-height: 300px; overflow-y: auto;">${escapeHtml(JSON.stringify(toolArgs, null, 2))}</div>
          </div>`;
      }

      // Tool result
      const toolResult = stop?.metadata?.result;
      if (type === 'tool' && toolResult != null) {
        const resultStr = typeof toolResult === 'string' ? toolResult : JSON.stringify(toolResult, null, 2);
        bodyContent += `
          <div class="event-section">
            <div class="event-section-title">üì§ Result</div>
            <div class="code-block" style="max-height: 300px; overflow-y: auto;">${escapeHtml(truncate(resultStr, 2000))}</div>
          </div>`;
      }

      // Task-specific content
      if (type === 'task') {
        const taskInput = start?.metadata?.input;
        if (taskInput) {
          const inputStr = typeof taskInput === 'string' ? taskInput : JSON.stringify(taskInput, null, 2);
          bodyContent += `
            <div class="event-section">
              <div class="event-section-title">üì• Task Input</div>
              <div class="code-block" style="max-height: 300px; overflow-y: auto;">${escapeHtml(truncate(inputStr, 2000))}</div>
            </div>`;
        }

        const taskDeps = start?.metadata?.task?.depends_on || [];
        if (taskDeps.length > 0) {
          bodyContent += `
            <div class="event-section">
              <div class="event-section-title">üîó Dependencies</div>
              <div class="task-deps">${taskDeps.map(d => `<span class="task-dep-tag">${escapeHtml(d)}</span>`).join('')}</div>
            </div>`;
        }

        // Find full turn data from LLM/turn events within this task's time range
        const taskTurns = findTaskTurns(start, stop);
        if (taskTurns.length > 0) {
          taskTurns.forEach((t, idx) => {
            const turnLabel = taskTurns.length > 1 ? ` (Turn ${t.turn || idx + 1})` : '';

            // System prompt (first turn only, collapsible)
            if (idx === 0 && t.systemPrompt) {
              const spLen = (t.systemPrompt.length / 1024).toFixed(1);
              bodyContent += `
                <div class="event-section">
                  <details>
                    <summary class="event-section-title" style="cursor: pointer; list-style: none;">üîß System Prompt <span style="color: var(--muted); font-size: 11px;">(${spLen}KB ‚Äî click to expand)</span></summary>
                    <div class="code-block" style="max-height: 600px; overflow-y: auto; border-left: 2px solid var(--accent); white-space: pre-wrap;">${escapeHtml(t.systemPrompt)}</div>
                  </details>
                </div>`;
            }

            // Prompt (turn 1: full, turn 2+: collapsed as feedback)
            if (t.prompt) {
              const isStub = /^String\(\d+ bytes\)$/.test(t.prompt);
              if (isStub) {
                // not captured
              } else if (idx > 0) {
                bodyContent += `
                  <div class="event-section">
                    <details>
                      <summary class="event-section-title" style="cursor: pointer; list-style: none;">üì® Feedback${turnLabel} <span style="color: var(--muted); font-size: 11px;">(click to expand)</span></summary>
                      <div class="code-block" style="max-height: 300px; overflow-y: auto;">${escapeHtml(truncate(t.prompt, 2000))}</div>
                    </details>
                  </div>`;
              } else {
                bodyContent += `
                  <div class="event-section">
                    <details>
                      <summary class="event-section-title" style="cursor: pointer; list-style: none;">üì® Prompt${turnLabel} <span style="color: var(--muted); font-size: 11px;">(click to expand)</span></summary>
                      <div class="code-block" style="max-height: 300px; overflow-y: auto;">${escapeHtml(truncate(t.prompt, 2000))}</div>
                    </details>
                  </div>`;
              }
            }

            // Thinking
            if (t.thinking) {
              bodyContent += `
                <div class="event-section">
                  <div class="event-section-title">üí≠ Thinking${turnLabel}</div>
                  <div class="thinking-block">${escapeHtml(t.thinking)}</div>
                </div>`;
            }

            // Program
            if (t.program) {
              bodyContent += `
                <div class="event-section">
                  <div class="event-section-title">üìù Program${turnLabel}${t.tokens ? ` <span style="color: var(--muted); font-size: 11px;">${formatTokenBreakdown(t.tokens)}</span>` : ''}</div>
                  <div class="code-block">${highlightLisp(t.program)}</div>
                </div>`;
            }

            // Per-turn result
            if (t.resultPreview && t.resultPreview !== 'nil') {
              const isError = t.resultPreview.includes('Error:') || t.resultPreview.includes(':error');
              const titleIcon = isError ? '‚ùå' : 'üì§';
              const titleText = isError ? 'Error' : 'Result';
              bodyContent += `
                <div class="event-section">
                  <div class="event-section-title">${titleIcon} ${titleText}${turnLabel}</div>
                  <div class="code-block"${isError ? ' style="border-left: 2px solid var(--error);"' : ''}>${escapeHtml(t.resultPreview)}</div>
                </div>`;
            }

            // Prints
            if (Array.isArray(t.prints) && t.prints.length > 0) {
              bodyContent += `
                <div class="event-section">
                  <div class="event-section-title">üñ® Output${turnLabel} (${t.prints.length})</div>
                  <div class="code-block" style="max-height: 300px; overflow-y: auto;">${t.prints.map(p => escapeHtml(p)).join('\n')}</div>
                </div>`;
            }
          });
        }

        // Final task result (from task.stop metadata ‚Äî the aggregated return value)
        const taskResult = stop?.metadata?.result;
        if (taskResult != null) {
          const resultStr = typeof taskResult === 'string' ? taskResult : JSON.stringify(taskResult, null, 2);
          bodyContent += `
            <div class="event-section">
              <div class="event-section-title">üì§ Final Result</div>
              <div class="code-block" style="max-height: 300px; overflow-y: auto;">${escapeHtml(truncate(resultStr, 2000))}</div>
            </div>`;
        }

        const verificationErr = stop?.metadata?.verification_error;
        if (verificationErr) {
          bodyContent += `
            <div class="event-section">
              <div class="event-section-title" style="color: var(--error);">‚ö† Verification Failed</div>
              <div class="code-block" style="border-left: 3px solid var(--error);">${escapeHtml(verificationErr)}</div>
            </div>`;
        }

        const validationErr = stop?.metadata?.validation_error;
        if (validationErr) {
          bodyContent += `
            <div class="event-section">
              <div class="event-section-title" style="color: var(--error);">‚ö† Synthesis Validation Failed</div>
              <div class="code-block" style="border-left: 3px solid var(--error);">${escapeHtml(validationErr)}</div>
            </div>`;
        }
      }

      const taskIdAttr = type === 'task' ? ` data-taskid="${escapeHtml(stop?.metadata?.task_id || start?.metadata?.task_id || '')}"` : '';
      return `
        <div class="event-card ${type}${hasError ? ' error' : ''}"${taskIdAttr}>
          <div class="event-header">
            <div class="event-toggle">‚ñ∂</div>
            <div class="event-icon ${type}">${icon}</div>
            <div class="event-title">${escapeHtml(title)}</div>
            <div class="event-meta">${meta.join('')}</div>
          </div>
          <div class="event-body">${bodyContent || '<div class="event-section" style="color: var(--muted);">No additional details</div>'}</div>
        </div>`;
    }

    function extractThinking(response) {
      if (!response) return '';
      const match = response.match(/thinking:\s*([\s\S]*?)(?=```|$)/i);
      return match ? match[1].trim() : '';
    }

    function extractProgram(response) {
      if (!response) return '';
      const match = response.match(/```clojure\n([\s\S]*?)```/);
      return match ? match[1].trim() : '';
    }

    // Find full turn data from LLM/turn events within a task's execution window
    function findTaskTurns(taskStart, taskStop) {
      if (!taskStart || !taskStop || !currentFile) return [];
      const data = loadedFiles.get(currentFile);
      if (!data) return [];

      const taskStartTime = new Date(taskStart.timestamp).getTime();
      const taskStopTime = new Date(taskStop.timestamp).getTime();

      // Collect LLM start/stop and turn stop events within the window
      const llmStarts = [];
      const llmStops = [];
      const turnStops = {};

      for (const event of data.events) {
        const eventTime = new Date(event.timestamp).getTime();
        if (eventTime < taskStartTime || eventTime > taskStopTime) continue;

        if (event.event === 'llm.start') llmStarts.push(event);
        else if (event.event === 'llm.stop') llmStops.push(event);
        else if (event.event === 'turn.stop') {
          const turn = event.metadata?.turn;
          if (turn) turnStops[turn] = event;
        }
      }

      // Pair llm.start with llm.stop by span_id, then by order
      const turns = [];
      const usedStops = new Set();

      for (const start of llmStarts) {
        let stop = null;
        if (start.span_id) {
          stop = llmStops.find(s => s.span_id === start.span_id);
        }
        if (!stop) {
          stop = llmStops.find(s => !usedStops.has(s) &&
            new Date(s.timestamp).getTime() >= new Date(start.timestamp).getTime());
        }
        if (stop) usedStops.add(stop);

        const turn = stop?.metadata?.turn || start?.metadata?.turn;
        const response = stop?.metadata?.response || '';
        const turnStop = turn ? turnStops[turn] : null;

        turns.push({
          turn,
          systemPrompt: start?.metadata?.system_prompt || null,
          prompt: getLastUserMessage(start?.metadata?.messages),
          thinking: extractThinking(response),
          program: extractProgram(response),
          tokens: stop?.measurements || null,
          duration: stop?.duration_ms || 0,
          resultPreview: turnStop?.metadata?.result_preview || null,
          prints: turnStop?.metadata?.prints || null
        });
      }

      // Handle orphan llm.stop events (no matching start)
      for (const stop of llmStops) {
        if (usedStops.has(stop)) continue;
        const turn = stop?.metadata?.turn;
        const response = stop?.metadata?.response || '';
        const turnStop = turn ? turnStops[turn] : null;

        turns.push({
          turn,
          systemPrompt: null,
          prompt: null,
          thinking: extractThinking(response),
          program: extractProgram(response),
          tokens: stop?.measurements || null,
          duration: stop?.duration_ms || 0,
          resultPreview: turnStop?.metadata?.result_preview || null,
          prints: turnStop?.metadata?.prints || null
        });
      }

      return turns;
    }

    function getLastUserMessage(messages) {
      if (!messages) return '';
      const userMsgs = messages.filter(m => m.role === 'user');
      return userMsgs.length > 0 ? userMsgs[userMsgs.length - 1].content : '';
    }

    function highlightLisp(code) {
      // Important: Use single quotes for HTML attributes to avoid conflict
      // with the double-quote string pattern in Lisp
      return escapeHtml(code)
        .replace(/;[^\n]*/g, "<span class='comment'>$&</span>")
        .replace(/\b(def|defn|let|if|cond|when|do|fn|loop|recur|return|fail|pmap|pcalls|doseq|for)\b/g, "<span class='keyword'>$1</span>")
        .replace(/\b(map|filter|reduce|first|rest|count|get|assoc|conj|into|take|drop|distinct|concat|str|println|inc|dec)\b/g, "<span class='builtin'>$1</span>")
        .replace(/"([^"\\]|\\.)*"/g, "<span class='string'>$&</span>")
        .replace(/\b(\d+\.?\d*)\b/g, "<span class='number'>$1</span>")
        .replace(/:([\w-]+)/g, "<span class='symbol'>:$1</span>")
        .replace(/data\/[\w-]+/g, "<span class='symbol'>$&</span>")
        .replace(/tool\/[\w-]+/g, "<span class='builtin'>$&</span>");
    }

    function findFileByTraceId(traceId) {
      for (const [name, data] of loadedFiles) {
        if (data.traceId === traceId) return name;
      }
      return null;
    }

    function formatTokens(n) {
      if (!n) return '0';
      if (n >= 1000000) return (n / 1000000).toFixed(1) + 'M';
      if (n >= 1000) return (n / 1000).toFixed(1) + 'K';
      return n.toString();
    }

    function formatTokenBreakdown(measurements) {
      if (!measurements) return '';
      const input = measurements.input_tokens;
      const output = measurements.output_tokens;
      const total = measurements.tokens || 0;
      if (input || output) {
        let s = `${formatTokens(input || 0)} in / ${formatTokens(output || 0)} out`;
        const cache = measurements.cache_read_tokens;
        if (cache > 0) s += ` (${formatTokens(cache)} cached)`;
        return s;
      }
      return total ? `${total.toLocaleString()} tk` : '';
    }

    function formatDuration(ms) {
      if (ms == null) return '-';
      if (ms < 1000) return `${ms}ms`;
      if (ms < 60000) return `${(ms / 1000).toFixed(1)}s`;
      return `${(ms / 60000).toFixed(1)}m`;
    }

    function truncate(str, len) {
      return str && str.length > len ? str.slice(0, len) + '...' : str || '';
    }

    function escapeHtml(text) {
      if (!text) return '';
      const div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML;
    }

    // Aggregate stats across all loaded traces
    function updateAggregateStats() {
      let totalTurns = 0;
      let totalLLM = 0;
      let totalTokens = 0;
      let loadedCount = 0;

      // Get child IDs from current trace
      const mainData = loadedFiles.get(currentFile);
      const childIds = mainData ? extractChildTraceIds(mainData.events) : [];

      for (const [name, data] of loadedFiles) {
        const paired = pairEvents(data.events);
        const llmEvents = paired.filter(e => e.type === 'llm');
        const maxTurn = llmEvents.reduce((max, e) => Math.max(max, e.stop?.metadata?.turn || 0), 0);

        totalTurns += maxTurn;
        totalLLM += llmEvents.length;
        totalTokens += llmEvents.reduce((sum, e) => sum + (e.stop?.measurements?.tokens || 0), 0);

        // Count how many children are loaded
        if (childIds.includes(data.traceId)) loadedCount++;
      }

      document.getElementById('totalTurns').textContent = totalTurns;
      document.getElementById('totalLLM').textContent = totalLLM;
      document.getElementById('totalTokens').textContent = totalTokens.toLocaleString();
      document.getElementById('loadedChildren').textContent = loadedCount + ' / ' + childIds.length;

      // Update button state
      const btn = document.getElementById('loadChildrenBtn');
      if (loadedCount >= childIds.length) {
        btn.textContent = 'All Loaded';
        btn.disabled = true;
        btn.style.opacity = '0.5';
      } else {
        btn.textContent = 'Load All Children';
        btn.disabled = false;
        btn.style.opacity = '1';
      }
    }

    // Load all child traces from the server
    async function loadAllChildren() {
      const mainData = loadedFiles.get(currentFile);
      if (!mainData) return;

      const childIds = extractChildTraceIds(mainData.events);
      const btn = document.getElementById('loadChildrenBtn');
      btn.textContent = 'Loading...';
      btn.disabled = true;

      let loaded = 0;
      for (const childId of childIds) {
        // Skip if already loaded
        if (findFileByTraceId(childId)) continue;

        // Try to fetch the child trace file
        const filename = 'trace_' + childId + '.jsonl';
        try {
          const response = await fetch('traces/' + filename);
          if (response.ok) {
            const text = await response.text();
            const events = parseJsonl(text);
            const traceId = extractTraceId(events);
            loadedFiles.set(filename, { events, traceId, filename });
            loaded++;
          }
        } catch (e) {
          console.log('Could not load ' + filename);
        }
      }

      updateFileList();
      updateAggregateStats();

      if (loaded > 0) {
        btn.textContent = 'Loaded ' + loaded + ' files';
      } else {
        btn.textContent = 'All Loaded';
      }
      setTimeout(() => updateAggregateStats(), 100);
    }

    // Wire up the load children button
    document.getElementById('loadChildrenBtn').addEventListener('click', loadAllChildren);

    // --- Agent Hierarchy Tree ---

    function buildAgentTree() {
      const nodes = new Map(); // traceId -> {traceId, name, duration, tokens, children, filename, timestamp}

      for (const [filename, data] of loadedFiles) {
        const events = data.events;
        const traceStart = events.find(e => e.event === 'trace.start');
        const execStop = events.find(e => e.event === 'execution.stop');
        const runStop = events.find(e => e.event === 'run.stop');
        const traceStop = events.find(e => e.event === 'trace.stop');
        const paired = pairEvents(events);
        const llmEvents = paired.filter(e => e.type === 'llm');
        const tokens = llmEvents.reduce((sum, e) => sum + (e.stop?.measurements?.tokens || 0), 0);
        const duration = execStop?.duration_ms || runStop?.duration_ms || traceStop?.duration_ms || 0;
        const parentId = traceStart?.metadata?.parent_trace_id || null;
        const name = traceStart?.metadata?.tool_name || traceStart?.metadata?.agent_name || filename.replace(/\.jsonl$/, '');

        nodes.set(data.traceId, {
          traceId: data.traceId,
          name,
          duration,
          tokens,
          children: [],
          filename,
          parentId,
          timestamp: traceStart?.timestamp || ''
        });
      }

      // Link children to parents
      const roots = [];
      for (const node of nodes.values()) {
        if (node.parentId && nodes.has(node.parentId)) {
          nodes.get(node.parentId).children.push(node);
        } else {
          roots.push(node);
        }
      }

      // Sort children by timestamp
      for (const node of nodes.values()) {
        node.children.sort((a, b) => a.timestamp.localeCompare(b.timestamp));
      }

      return roots;
    }

    function renderAgentTree() {
      const roots = buildAgentTree();
      const panel = document.getElementById('agentTree');
      const content = document.getElementById('agentTreeContent');

      if (roots.length <= 1 && roots[0]?.children.length === 0) {
        panel.classList.remove('visible');
        return;
      }

      panel.classList.add('visible');
      content.innerHTML = renderTreeUl(roots);

      // Click handlers
      content.querySelectorAll('.agent-tree-node').forEach(el => {
        el.addEventListener('click', () => {
          const fn = el.dataset.filename;
          if (fn && loadedFiles.has(fn)) {
            currentFile = fn;
            displayTrace(fn);
            updateFileList();
            // Highlight active node
            content.querySelectorAll('.agent-tree-node').forEach(n => n.classList.remove('active'));
            el.classList.add('active');
          }
        });
      });
    }

    function renderTreeUl(nodes) {
      if (!nodes.length) return '';
      let html = '<ul>';
      for (const node of nodes) {
        const hasChildren = node.children.length > 0;
        const toggle = hasChildren ? '‚ñº' : '‚Ä¢';
        const isActive = node.filename === currentFile;
        html += `<li>
          <span class="agent-tree-node${isActive ? ' active' : ''}" data-filename="${escapeHtml(node.filename)}">
            <span class="toggle">${toggle}</span>
            <span class="name">${escapeHtml(node.name)}</span>
            <span class="badge">${formatDuration(node.duration)}</span>
            ${node.tokens ? `<span class="badge">${node.tokens} tk</span>` : ''}
          </span>
          ${hasChildren ? renderTreeUl(node.children) : ''}
        </li>`;
      }
      html += '</ul>';
      return html;
    }

    // Rebuild tree whenever files change
    const origHandleFiles = handleFiles;
    handleFiles = async function(files) {
      await origHandleFiles(files);
      renderAgentTree();
    };

    // --- Plan Display ---

    function extractPlanData(events) {
      // Look for plan.generated event or run.start with plan metadata
      // Event name is "plan.generated" (after dropping [:ptc_runner, :plan_executor] prefix)
      const planGenerated = events.find(e => e.event === 'plan.generated');
      const runStart = events.find(e => e.event === 'run.start');

      // Try to find plan in various places
      let plan = null;
      let mission = null;
      let agents = null;

      // Primary source: plan.generated event from PlanExecutor
      if (planGenerated?.metadata) {
        plan = planGenerated.metadata.plan;
        mission = planGenerated.metadata.mission;
      }

      // Fallback: run.start metadata (for SubAgent runs)
      if (!mission && runStart?.metadata?.agent) {
        const agentMeta = runStart.metadata.agent;
        mission = agentMeta.prompt || agentMeta.mission;
        // Parse plan from agent metadata if present
        if (!plan && agentMeta.plan && typeof agentMeta.plan === 'object') {
          plan = agentMeta.plan;
        }
      }

      // Extract from trace.start meta
      const traceStart = events.find(e => e.event === 'trace.start');
      if (!mission && traceStart?.meta?.mission) {
        mission = traceStart.meta.mission;
      }

      // Last resort: scan all events for plan-like structures
      if (!plan) {
        for (const event of events) {
          const meta = event.metadata || {};
          if (meta.tasks && Array.isArray(meta.tasks)) {
            plan = { tasks: meta.tasks, agents: meta.agents };
            break;
          }
          if (meta.plan?.tasks) {
            plan = meta.plan;
            break;
          }
        }
      }

      return { plan, mission, agents };
    }

    function renderPlanCard(events) {
      const planCard = document.getElementById('planCard');
      const planMeta = document.getElementById('planMeta');
      const planBody = document.getElementById('planBody');

      const { plan, mission, agents } = extractPlanData(events);

      if (!plan && !mission) {
        planCard.classList.remove('visible');
        return;
      }

      planCard.classList.add('visible');
      planCard.classList.add('expanded'); // Start expanded

      let html = '';

      // Mission section
      if (mission) {
        html += `
          <div class="plan-section">
            <div class="plan-section-title">üéØ Mission</div>
            <div class="mission-text">${escapeHtml(truncatePlan(mission, 1500))}</div>
          </div>`;
      }

      // Agents section
      const planAgents = plan?.agents || agents;
      if (planAgents && typeof planAgents === 'object') {
        const agentNames = Object.keys(planAgents);
        html += `
          <div class="plan-section">
            <div class="plan-section-title">
              ü§ñ Agents
              <span class="count">${agentNames.length}</span>
            </div>
            <div class="agent-cards">
              ${agentNames.map(name => renderAgentCard(name, planAgents[name])).join('')}
            </div>
          </div>`;
      }

      // Tasks section
      if (plan?.tasks && Array.isArray(plan.tasks)) {
        html += `
          <div class="plan-section">
            <div class="plan-section-title">
              üìù Tasks
              <span class="count">${plan.tasks.length}</span>
            </div>
            <div class="task-flow">
              ${plan.tasks.map(task => renderTaskItem(task)).join('')}
            </div>
          </div>`;

        planMeta.textContent = `${plan.tasks.length} tasks`;
      }

      planBody.innerHTML = html || '<div class="plan-section" style="color: var(--muted);">No plan details available</div>';
    }

    function renderAgentCard(name, agent) {
      const tools = agent.tools || [];
      const prompt = agent.prompt || '';

      return `
        <div class="agent-card">
          <div class="agent-card-header">
            <span class="agent-card-name">${escapeHtml(name)}</span>
          </div>
          ${prompt ? `<div class="agent-card-prompt">${escapeHtml(truncatePlan(prompt, 150))}</div>` : ''}
          ${tools.length > 0 ? `
            <div class="agent-card-tools">
              ${tools.map(t => `<span class="agent-tool-tag">üîß ${escapeHtml(t)}</span>`).join('')}
            </div>
          ` : '<div style="font-size: 11px; color: var(--muted);">No tools</div>'}
        </div>`;
    }

    function renderTaskItem(task) {
      const taskType = task.type || 'task';
      const isSynthesis = taskType === 'synthesis_gate' || taskType === 'synthesis';
      const isHumanReview = taskType === 'human_review';
      const typeClass = isSynthesis ? 'synthesis' : (isHumanReview ? 'human_review' : '');

      const deps = task.depends_on || [];
      const verification = task.verification;
      const signature = task.signature;

      return `
        <div class="task-item ${typeClass}">
          <div class="task-item-header">
            <span class="task-id">${escapeHtml(task.id || 'unnamed')}</span>
            ${taskType !== 'task' ? `<span class="task-type-badge">${escapeHtml(taskType)}</span>` : ''}
            ${task.output ? `<span class="task-type-badge" style="background: ${task.output === 'ptc_lisp' ? 'var(--accent)' : 'var(--muted)'}; color: var(--bg);">${task.output === 'ptc_lisp' ? 'PTC-Lisp' : 'JSON'}</span>` : ''}
            ${task.agent ? `<span class="task-agent-ref">‚Üí ${escapeHtml(task.agent)}</span>` : ''}
          </div>
          ${task.input ? `<div class="task-input">${escapeHtml(truncatePlan(task.input, 200))}</div>` : ''}
          ${deps.length > 0 ? `
            <div class="task-deps">
              <span style="font-size: 10px; color: var(--muted);">depends on:</span>
              ${deps.map(d => `<span class="task-dep-tag">${escapeHtml(d)}</span>`).join('')}
            </div>
          ` : ''}
          ${signature ? `
            <div class="task-verification">
              <span style="color: var(--muted);">üì§ Output signature:</span>
              <code>${escapeHtml(signature)}</code>
            </div>
          ` : ''}
          ${verification ? `
            <div class="task-verification">
              <span style="color: var(--muted);">‚úì Verification:</span>
              <code>${escapeHtml(verification)}</code>
            </div>
          ` : ''}
        </div>`;
    }

    function truncatePlan(str, len) {
      if (!str) return '';
      // Handle truncated strings from tracer
      if (str.includes('[String truncated')) {
        // Extract the preview portion
        const match = str.match(/^([\s\S]*?)\.\.\.\s*\n?\n?\[String truncated/);
        if (match) {
          return match[1] + '... [truncated]';
        }
      }
      return str.length > len ? str.slice(0, len) + '...' : str;
    }

    // Patch displayTrace to also render plan and DAG
    const origDisplayTrace = displayTrace;
    displayTrace = function(filename) {
      origDisplayTrace(filename);
      const data = loadedFiles.get(filename);
      if (data) {
        renderPlanCard(data.events);
        renderDAGGraph(data.events);
        // Collapse plan card when DAG is visible (DAG replaces the task overview)
        const dagPanel = document.getElementById('dagGraph');
        const planCard = document.getElementById('planCard');
        if (dagPanel.classList.contains('visible') && planCard.classList.contains('expanded')) {
          planCard.classList.remove('expanded');
        }
      }
    };

    // --- DAG Execution Graph ---

    function buildExecutionModel(planTasks, phases, agents, taskStarts, taskStops) {
      // Compute phases from dependency graph if not provided
      let phaseMap = {};
      if (phases.length > 0) {
        for (const p of phases) {
          for (const tid of p.task_ids) phaseMap[tid] = p.phase;
        }
      } else {
        // Topological sort fallback
        const taskIds = new Set(planTasks.map(t => t.id));
        const resolved = new Set();
        let phase = 0;
        const remaining = [...planTasks];
        while (remaining.length > 0) {
          const batch = remaining.filter(t =>
            (t.depends_on || []).every(d => resolved.has(d) || !taskIds.has(d))
          );
          if (batch.length === 0) break;
          for (const t of batch) { phaseMap[t.id] = phase; resolved.add(t.id); }
          remaining.splice(0, remaining.length, ...remaining.filter(t => !resolved.has(t.id)));
          phase++;
        }
      }

      const tasks = planTasks.map(t => {
        const stopEvt = taskStops[t.id];
        const startEvt = taskStarts[t.id];
        return {
          id: t.id,
          agent: t.agent || '',
          phase: phaseMap[t.id] ?? 0,
          type: t.type || 'task',
          outputMode: startEvt?.metadata?.task?.output || t.output || null,
          status: stopEvt?.metadata?.status || (startEvt ? 'running' : 'pending'),
          durationMs: stopEvt?.duration_ms || stopEvt?.metadata?.duration_ms || 0,
          dependsOn: t.depends_on || [],
          input: t.input || '',
          signature: t.signature || ''
        };
      });

      const edges = [];
      for (const t of tasks) {
        for (const dep of t.dependsOn) {
          edges.push({ from: dep, to: t.id });
        }
      }

      // Build phases array
      const phaseGroups = {};
      for (const t of tasks) {
        if (!phaseGroups[t.phase]) phaseGroups[t.phase] = [];
        phaseGroups[t.phase].push(t.id);
      }
      const sortedPhases = Object.keys(phaseGroups).sort((a, b) => a - b).map(p => ({
        phase: parseInt(p),
        taskIds: phaseGroups[p]
      }));

      return { tasks, phases: sortedPhases, agents, edges };
    }

    function buildExecutionAttempts(events) {
      const planEvt = events.find(e => e.event === 'plan.generated');
      const execStart = events.find(e => e.event === 'execution.start');
      if (!planEvt?.metadata?.plan?.tasks) return [];

      const agents = planEvt.metadata.plan.agents || {};

      // Collect all replan boundaries
      const replanStarts = events.filter(e => e.event === 'replan.start');
      const replanStops = events.filter(e => e.event === 'replan.stop');

      // Collect all task.start / task.stop events with timestamps
      const allTaskStarts = events.filter(e => e.event === 'task.start');
      const allTaskStops = events.filter(e => e.event === 'task.stop');

      // Helper: group task events by time window
      function taskEventsInWindow(startTime, endTime) {
        const starts = {};
        const stops = {};
        for (const e of allTaskStarts) {
          const t = new Date(e.timestamp).getTime();
          if (t >= startTime && t < endTime && e.metadata?.task_id) {
            starts[e.metadata.task_id] = e;
          }
        }
        for (const e of allTaskStops) {
          const t = new Date(e.timestamp).getTime();
          if (t >= startTime && t < endTime && e.metadata?.task_id) {
            stops[e.metadata.task_id] = e;
          }
        }
        return { starts, stops };
      }

      const attempts = [];

      if (replanStarts.length === 0) {
        // Single attempt ‚Äî use plan.generated + execution.start directly
        const taskStarts = {};
        const taskStops = {};
        for (const e of allTaskStarts) if (e.metadata?.task_id) taskStarts[e.metadata.task_id] = e;
        for (const e of allTaskStops) if (e.metadata?.task_id) taskStops[e.metadata.task_id] = e;

        const model = buildExecutionModel(
          planEvt.metadata.plan.tasks,
          execStart?.metadata?.phases || [],
          agents,
          taskStarts,
          taskStops
        );
        if (model) attempts.push({ label: 'Plan', model });
        return attempts;
      }

      // Multiple attempts ‚Äî split at replan boundaries

      // Attempt 0: from execution.start to first replan.start
      const execStartTime = execStart ? new Date(execStart.timestamp).getTime() : 0;
      const firstReplanTime = new Date(replanStarts[0].timestamp).getTime();
      const a0Events = taskEventsInWindow(execStartTime, firstReplanTime);

      const initialModel = buildExecutionModel(
        planEvt.metadata.plan.tasks,
        execStart?.metadata?.phases || [],
        agents,
        a0Events.starts,
        a0Events.stops
      );
      if (initialModel) attempts.push({ label: 'Initial Plan', model: initialModel });

      // Replan attempts
      for (let i = 0; i < replanStarts.length; i++) {
        const rpStart = replanStarts[i];
        const rpStop = replanStops[i];
        if (!rpStop) continue;

        const triggerTaskId = rpStart.metadata?.task_id || '';
        const diagnosis = rpStart.metadata?.diagnosis || '';

        // Window: from replan.stop to next replan.start (or end)
        const windowStart = new Date(rpStop.timestamp).getTime();
        const windowEnd = replanStarts[i + 1]
          ? new Date(replanStarts[i + 1].timestamp).getTime()
          : Infinity;

        const segEvents = taskEventsInWindow(windowStart, windowEnd);

        // Reconstruct plan tasks from task.start metadata in this window
        const repairTasks = Object.values(segEvents.starts).map(e => {
          const taskDef = e.metadata?.task || {};
          return {
            id: e.metadata?.task_id || taskDef.id,
            agent: e.metadata?.agent || taskDef.agent || '',
            depends_on: taskDef.depends_on || [],
            type: taskDef.type || 'task',
            output: taskDef.output || null,
            input: e.metadata?.input || taskDef.input || '',
            signature: taskDef.signature || ''
          };
        });

        if (repairTasks.length === 0) continue;

        const model = buildExecutionModel(repairTasks, [], agents, segEvents.starts, segEvents.stops);
        if (model) {
          attempts.push({
            label: `Replan ${i + 1}`,
            model,
            triggerTaskId,
            diagnosis
          });
        }
      }

      return attempts;
    }

    function computeGraphLayout(model) {
      const nodeW = 180, nodeH = 72;
      const phaseGap = 60, nodeGap = 20;
      const padX = 40, padY = 50;
      const positions = {};

      const maxTasksInPhase = Math.max(...model.phases.map(p => p.taskIds.length), 1);
      const totalContentH = maxTasksInPhase * nodeH + (maxTasksInPhase - 1) * nodeGap;

      for (const phase of model.phases) {
        const x = padX + phase.phase * (nodeW + phaseGap);
        const phaseH = phase.taskIds.length * nodeH + (phase.taskIds.length - 1) * nodeGap;
        const offsetY = padY + 20 + (totalContentH - phaseH) / 2;
        for (let i = 0; i < phase.taskIds.length; i++) {
          positions[phase.taskIds[i]] = {
            x,
            y: offsetY + i * (nodeH + nodeGap),
            w: nodeW,
            h: nodeH
          };
        }
      }

      const maxPhase = model.phases.length > 0 ? model.phases[model.phases.length - 1].phase : 0;
      const svgW = padX * 2 + (maxPhase + 1) * (nodeW + phaseGap) - phaseGap;
      const svgH = padY + 20 + totalContentH + padX;

      return { positions, svgW, svgH, nodeW, nodeH, padX, padY };
    }

    function getNodeStroke(task) {
      if (task.type === 'synthesis_gate' || task.type === 'synthesis') return '#c586c0';
      if (task.status === 'ok') return '#4ec9b0';
      if (task.status === 'error' || task.status === 'failed') return '#f44747';
      if (task.status === 'running') return '#569cd6';
      return '#808080';
    }

    function getNodeFill(task) {
      if (task.type === 'synthesis_gate' || task.type === 'synthesis') return 'rgba(197, 134, 192, 0.15)';
      if (task.status === 'ok') return 'rgba(78, 201, 176, 0.12)';
      if (task.status === 'error' || task.status === 'failed') return 'rgba(244, 71, 71, 0.12)';
      if (task.status === 'running') return 'rgba(86, 156, 214, 0.15)';
      return 'rgba(128, 128, 128, 0.1)';
    }

    function computeEdgePath(fromPos, toPos, nodeW, nodeH) {
      const x1 = fromPos.x + nodeW;
      const y1 = fromPos.y + nodeH / 2;
      const x2 = toPos.x;
      const y2 = toPos.y + nodeH / 2;
      const cx = (x1 + x2) / 2;
      return `M ${x1} ${y1} C ${cx} ${y1}, ${cx} ${y2}, ${x2} ${y2}`;
    }

    function truncateId(id, maxLen) {
      return id.length > maxLen ? id.slice(0, maxLen - 1) + '\u2026' : id;
    }

    function renderDAGGraph(events) {
      const container = document.getElementById('dagGraphContainer');
      const panel = document.getElementById('dagGraph');
      const tooltip = document.getElementById('dagTooltip');

      const attempts = buildExecutionAttempts(events);
      if (attempts.length === 0) {
        panel.classList.remove('visible');
        return;
      }

      panel.classList.add('visible');
      panel.classList.add('expanded');

      // Set meta summary
      const totalTasks = attempts[0].model.tasks.length;
      const totalPhases = attempts[0].model.phases.length;
      const metaEl = document.getElementById('dagMeta');
      let metaText = `${totalTasks} tasks, ${totalPhases} phases`;
      if (attempts.length > 1) metaText += `, ${attempts.length - 1} replan(s)`;
      metaEl.textContent = metaText;

      // Build inner HTML: tabs (if >1 attempt) + SVG container
      let html = '';
      if (attempts.length > 1) {
        html += '<div class="dag-tabs">';
        attempts.forEach((attempt, idx) => {
          const isReplan = idx > 0;
          html += `<button class="dag-tab${idx === 0 ? ' active' : ''}${isReplan ? ' replan' : ''}" data-attempt="${idx}">${attempt.label}</button>`;
        });
        html += '</div>';
      }
      html += '<div id="dagReplanInfo"></div><div id="dagSvgContainer"></div>';
      container.innerHTML = html;

      const svgContainer = document.getElementById('dagSvgContainer');
      const replanInfo = document.getElementById('dagReplanInfo');

      // Render first attempt
      renderDAGForModel(attempts[0], svgContainer, tooltip, replanInfo);

      // Tab click handlers
      if (attempts.length > 1) {
        container.querySelectorAll('.dag-tab').forEach(tab => {
          tab.addEventListener('click', () => {
            container.querySelectorAll('.dag-tab').forEach(t => t.classList.remove('active'));
            tab.classList.add('active');
            const idx = parseInt(tab.dataset.attempt);
            renderDAGForModel(attempts[idx], svgContainer, tooltip, replanInfo);
          });
        });
      }
    }

    function renderDAGForModel(attempt, svgContainer, tooltip, replanInfoEl) {
      const model = attempt.model;

      // Show replan info banner if applicable
      if (attempt.triggerTaskId) {
        replanInfoEl.innerHTML = `<div class="dag-replan-info">
          Triggered by failed task <span class="trigger">${escapeHtml(attempt.triggerTaskId)}</span>
          ${attempt.diagnosis ? ` ‚Äî ${escapeHtml(truncate(attempt.diagnosis, 150))}` : ''}
        </div>`;
      } else {
        replanInfoEl.innerHTML = '';
      }

      const layout = computeGraphLayout(model);
      const { positions, svgW, svgH, nodeW, nodeH, padX, padY } = layout;
      const taskMap = {};
      for (const t of model.tasks) taskMap[t.id] = t;

      // Build SVG
      let svg = `<svg width="${svgW}" height="${svgH}" xmlns="http://www.w3.org/2000/svg" style="font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;">`;

      // Arrowhead markers
      svg += `<defs><marker id="dagArrow" viewBox="0 0 10 7" refX="10" refY="3.5" markerWidth="8" markerHeight="6" orient="auto-start-reverse"><polygon points="0 0, 10 3.5, 0 7" class="dag-arrowhead"/></marker>`;
      svg += `<marker id="dagArrowHL" viewBox="0 0 10 7" refX="10" refY="3.5" markerWidth="8" markerHeight="6" orient="auto-start-reverse"><polygon points="0 0, 10 3.5, 0 7" class="dag-arrowhead highlighted"/></marker></defs>`;

      // Phase labels
      for (const phase of model.phases) {
        const x = padX + phase.phase * (nodeW + 60) + nodeW / 2;
        svg += `<text x="${x}" y="${padY - 5}" text-anchor="middle" class="dag-phase-label">Phase ${phase.phase}</text>`;
      }

      // Edges
      for (const edge of model.edges) {
        const from = positions[edge.from];
        const to = positions[edge.to];
        if (!from || !to) continue;
        const path = computeEdgePath(from, to, nodeW, nodeH);
        svg += `<path d="${path}" class="dag-edge" data-from="${edge.from}" data-to="${edge.to}" marker-end="url(#dagArrow)"/>`;
      }

      // Nodes
      for (const task of model.tasks) {
        const pos = positions[task.id];
        if (!pos) continue;
        const stroke = getNodeStroke(task);
        const fill = getNodeFill(task);
        const displayId = truncateId(task.id, 22);

        let statusIcon = '';
        if (task.status === 'ok') statusIcon = '\u2713';
        else if (task.status === 'error' || task.status === 'failed') statusIcon = '\u2717';
        else if (task.status === 'running') statusIcon = '\u25cb';
        else statusIcon = '\u2022';

        let badgeSvg = '';
        if (task.outputMode === 'ptc_lisp') {
          badgeSvg = `<rect x="${pos.x + nodeW - 42}" y="${pos.y + 4}" width="36" height="16" rx="3" fill="#569cd6" opacity="0.8"/><text x="${pos.x + nodeW - 24}" y="${pos.y + 15}" text-anchor="middle" class="node-badge" fill="#fff">PTC</text>`;
        } else if (task.type === 'synthesis_gate' || task.type === 'synthesis') {
          badgeSvg = `<rect x="${pos.x + nodeW - 56}" y="${pos.y + 4}" width="50" height="16" rx="3" fill="#c586c0" opacity="0.8"/><text x="${pos.x + nodeW - 31}" y="${pos.y + 15}" text-anchor="middle" class="node-badge" fill="#fff">SYNTH</text>`;
        } else if (task.outputMode === 'json') {
          badgeSvg = `<rect x="${pos.x + nodeW - 46}" y="${pos.y + 4}" width="40" height="16" rx="3" fill="#808080" opacity="0.6"/><text x="${pos.x + nodeW - 26}" y="${pos.y + 15}" text-anchor="middle" class="node-badge" fill="#fff">JSON</text>`;
        }

        svg += `<g class="dag-node" data-taskid="${task.id}">`;
        svg += `<rect x="${pos.x}" y="${pos.y}" width="${nodeW}" height="${nodeH}" fill="${fill}" stroke="${stroke}"/>`;
        svg += badgeSvg;
        svg += `<text x="${pos.x + 10}" y="${pos.y + 26}" class="node-id" fill="${stroke}">${statusIcon} ${escapeHtml(displayId)}</text>`;
        svg += `<text x="${pos.x + 10}" y="${pos.y + 42}" class="node-agent" fill="#808080">\u2192 ${escapeHtml(task.agent)}</text>`;
        if (task.durationMs > 0) {
          svg += `<text x="${pos.x + 10}" y="${pos.y + 58}" class="node-duration" fill="#808080">${formatDuration(task.durationMs)}</text>`;
        }
        svg += `</g>`;
      }

      svg += `</svg>`;
      svgContainer.innerHTML = svg;

      // Attach interactions
      svgContainer.querySelectorAll('.dag-node').forEach(node => {
        const taskId = node.dataset.taskid;
        const task = taskMap[taskId];

        node.addEventListener('click', () => {
          const card = document.querySelector(`.event-card[data-taskid="${taskId}"]`);
          if (card) {
            card.scrollIntoView({ behavior: 'smooth', block: 'center' });
            card.classList.remove('dag-highlight');
            void card.offsetWidth;
            card.classList.add('dag-highlight');
            if (!card.classList.contains('expanded')) card.classList.add('expanded');
          }
        });

        node.addEventListener('mouseenter', () => {
          svgContainer.querySelectorAll('.dag-edge').forEach(edge => {
            if (edge.dataset.from === taskId || edge.dataset.to === taskId) {
              edge.classList.add('highlighted');
              edge.setAttribute('marker-end', 'url(#dagArrowHL)');
            }
          });
          if (task) {
            let html = `<div class="tt-label">Task</div><div class="tt-value" style="font-weight:600;">${escapeHtml(task.id)}</div>`;
            html += `<div class="tt-label">Agent</div><div class="tt-value">${escapeHtml(task.agent)}</div>`;
            html += `<div class="tt-label">Status</div><div class="tt-value" style="color:${getNodeStroke(task)}">${task.status}</div>`;
            if (task.durationMs > 0) html += `<div class="tt-label">Duration</div><div class="tt-value">${formatDuration(task.durationMs)}</div>`;
            if (task.input) html += `<div class="tt-label">Input</div><div class="tt-value" style="font-size:11px;">${escapeHtml(truncate(task.input, 120))}</div>`;
            tooltip.innerHTML = html;
            tooltip.style.display = 'block';
            const rect = node.getBoundingClientRect();
            tooltip.style.left = (rect.right + 8) + 'px';
            tooltip.style.top = rect.top + 'px';
          }
        });

        node.addEventListener('mouseleave', () => {
          svgContainer.querySelectorAll('.dag-edge.highlighted').forEach(edge => {
            edge.classList.remove('highlighted');
            edge.setAttribute('marker-end', 'url(#dagArrow)');
          });
          tooltip.style.display = 'none';
        });
      });
    }
  </script>
</body>
</html>
