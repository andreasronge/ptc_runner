<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>PTC Trace Viewer</title>
  <style>
    :root {
      --bg: #1e1e1e;
      --bg-light: #252526;
      --bg-hover: #2d2d2d;
      --fg: #d4d4d4;
      --accent: #569cd6;
      --success: #4ec9b0;
      --error: #f44747;
      --warning: #dcdcaa;
      --string: #ce9178;
      --keyword: #c586c0;
      --comment: #6a9955;
      --muted: #808080;
      --border: #3c3c3c;
    }

    * { box-sizing: border-box; }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      font-size: 13px;
      background: var(--bg);
      color: var(--fg);
      margin: 0;
      padding: 20px;
      line-height: 1.5;
    }

    h1 {
      font-size: 18px;
      font-weight: 500;
      margin: 0 0 20px 0;
      color: var(--accent);
    }

    .drop-zone {
      border: 2px dashed var(--border);
      border-radius: 8px;
      padding: 40px;
      text-align: center;
      margin-bottom: 20px;
      transition: all 0.2s;
    }

    .drop-zone.dragover {
      border-color: var(--accent);
      background: rgba(86, 156, 214, 0.1);
    }

    .drop-zone p { margin: 0 0 10px 0; color: var(--muted); }
    input[type="file"] { display: none; }

    .btn {
      background: var(--accent);
      color: #fff;
      border: none;
      padding: 8px 16px;
      border-radius: 4px;
      cursor: pointer;
      font-family: inherit;
      font-size: 13px;
    }
    .btn:hover { opacity: 0.9; }

    .summary {
      background: var(--bg-light);
      border-radius: 8px;
      padding: 16px;
      margin-bottom: 20px;
      display: none;
    }
    .summary.visible { display: block; }

    .summary-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
      gap: 16px;
    }

    .summary-item { text-align: center; }
    .summary-value { font-size: 24px; font-weight: 600; color: var(--accent); }
    .summary-label { font-size: 11px; color: var(--muted); text-transform: uppercase; }

    /* Timeline */
    .timeline {
      background: var(--bg-light);
      border-radius: 8px;
      padding: 16px;
      margin-bottom: 20px;
      display: none;
      overflow-x: auto;
    }
    .timeline.visible { display: block; }
    .timeline h3 { margin: 0 0 12px 0; font-size: 14px; color: var(--muted); }

    .timeline-bar {
      height: 24px;
      background: var(--bg);
      border-radius: 4px;
      position: relative;
      margin-bottom: 8px;
      min-width: 600px;
    }

    .timeline-segment {
      position: absolute;
      height: 100%;
      border-radius: 3px;
      cursor: pointer;
      transition: opacity 0.2s;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 10px;
      color: #fff;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
      padding: 0 4px;
    }
    .timeline-segment:hover { opacity: 0.8; }
    .timeline-segment.llm { background: var(--accent); }
    .timeline-segment.tool { background: var(--warning); }
    .timeline-segment.pmap { background: var(--keyword); }

    /* Event cards */
    .events { display: none; }
    .events.visible { display: block; }

    .event-card {
      background: var(--bg-light);
      border-radius: 8px;
      margin-bottom: 12px;
      overflow: hidden;
      border-left: 3px solid var(--border);
    }
    .event-card.llm { border-left-color: var(--accent); }
    .event-card.tool { border-left-color: var(--warning); }
    .event-card.pmap { border-left-color: var(--keyword); }
    .event-card.turn { border-left-color: var(--success); }
    .event-card.error { border-left-color: var(--error); }

    .event-header {
      padding: 12px 16px;
      display: flex;
      align-items: center;
      gap: 12px;
      cursor: pointer;
      user-select: none;
    }
    .event-header:hover { background: var(--bg-hover); }

    .event-toggle {
      width: 20px;
      height: 20px;
      display: flex;
      align-items: center;
      justify-content: center;
      color: var(--muted);
      font-size: 16px;
    }

    .event-icon {
      width: 28px;
      height: 28px;
      border-radius: 6px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 14px;
    }
    .event-icon.llm { background: rgba(86, 156, 214, 0.2); color: var(--accent); }
    .event-icon.tool { background: rgba(220, 220, 170, 0.2); color: var(--warning); }
    .event-icon.pmap { background: rgba(197, 134, 192, 0.2); color: var(--keyword); }
    .event-icon.turn { background: rgba(78, 201, 176, 0.2); color: var(--success); }

    .event-title { flex: 1; font-weight: 500; }
    .event-meta { color: var(--muted); font-size: 12px; display: flex; gap: 16px; }
    .event-meta span { display: flex; align-items: center; gap: 4px; }

    .event-body {
      display: none;
      border-top: 1px solid var(--border);
    }
    .event-card.expanded .event-body { display: block; }
    .event-card.expanded .event-toggle { transform: rotate(90deg); }

    .event-section {
      padding: 12px 16px;
      border-bottom: 1px solid var(--border);
    }
    .event-section:last-child { border-bottom: none; }
    .event-section-title {
      font-size: 11px;
      text-transform: uppercase;
      color: var(--muted);
      margin-bottom: 8px;
      font-weight: 600;
    }

    /* Code blocks */
    .code-block {
      background: var(--bg);
      border-radius: 6px;
      padding: 12px;
      font-family: 'SF Mono', 'Consolas', 'Monaco', monospace;
      font-size: 12px;
      line-height: 1.6;
      overflow-x: auto;
      white-space: pre-wrap;
      word-break: break-word;
    }

    /* Syntax highlighting for Lisp */
    .code-block .keyword { color: var(--keyword); }
    .code-block .builtin { color: var(--accent); }
    .code-block .string { color: var(--string); }
    .code-block .comment { color: var(--comment); font-style: italic; }
    .code-block .number { color: var(--success); }
    .code-block .symbol { color: var(--warning); }

    /* Thinking block */
    .thinking-block {
      background: rgba(106, 153, 85, 0.1);
      border-left: 3px solid var(--comment);
      padding: 12px;
      border-radius: 0 6px 6px 0;
      margin-bottom: 12px;
      font-size: 12px;
      color: var(--comment);
      white-space: pre-wrap;
    }

    /* Child traces */
    .child-traces {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
      gap: 8px;
    }

    .child-trace-item {
      background: var(--bg);
      border-radius: 6px;
      padding: 10px 12px;
      cursor: pointer;
      display: flex;
      justify-content: space-between;
      align-items: center;
      transition: background 0.2s;
    }
    .child-trace-item:hover { background: var(--bg-hover); }
    .child-trace-item .id { font-family: monospace; color: var(--accent); }
    .child-trace-item .status { font-size: 11px; color: var(--success); }

    /* File list */
    .file-list {
      margin-top: 20px;
      padding-top: 20px;
      border-top: 1px solid var(--border);
      display: none;
    }
    .file-list.visible { display: block; }
    .file-list h2 { font-size: 14px; margin: 0 0 10px 0; color: var(--muted); }

    .file-item {
      padding: 8px 12px;
      margin: 4px 0;
      background: var(--bg-light);
      border-radius: 4px;
      cursor: pointer;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    .file-item:hover { background: var(--bg-hover); }
    .file-item.active { border-left: 3px solid var(--accent); background: var(--bg-hover); }

    .instructions {
      background: var(--bg-light);
      border-radius: 8px;
      padding: 16px;
      margin-top: 20px;
      font-size: 12px;
      color: var(--muted);
    }
    .instructions code {
      background: var(--bg);
      padding: 2px 6px;
      border-radius: 3px;
      color: var(--warning);
      font-family: monospace;
    }

    /* Tabs */
    .tabs {
      display: flex;
      gap: 4px;
      margin-bottom: 16px;
      border-bottom: 1px solid var(--border);
      padding-bottom: 8px;
    }
    .tab {
      padding: 8px 16px;
      background: transparent;
      border: none;
      color: var(--muted);
      cursor: pointer;
      border-radius: 4px;
      font-size: 13px;
    }
    .tab:hover { background: var(--bg-hover); color: var(--fg); }
    .tab.active { background: var(--accent); color: #fff; }
  </style>
</head>
<body>
  <h1>üîç PTC Trace Viewer</h1>

  <div class="drop-zone" id="dropZone">
    <p>Drop .jsonl trace files here or click to select</p>
    <p style="font-size: 11px;">Select the main trace + child traces to view the full hierarchy</p>
    <button class="btn" onclick="document.getElementById('fileInput').click()">Select Files</button>
    <input type="file" id="fileInput" accept=".jsonl" multiple>
  </div>

  <div class="summary" id="summary">
    <div class="summary-grid">
      <div class="summary-item">
        <div class="summary-value" id="summaryDuration">-</div>
        <div class="summary-label">Duration</div>
      </div>
      <div class="summary-item">
        <div class="summary-value" id="summaryTurns">-</div>
        <div class="summary-label">Turns</div>
      </div>
      <div class="summary-item">
        <div class="summary-value" id="summaryLLM">-</div>
        <div class="summary-label">LLM Calls</div>
      </div>
      <div class="summary-item">
        <div class="summary-value" id="summaryTokens">-</div>
        <div class="summary-label">Tokens</div>
      </div>
      <div class="summary-item">
        <div class="summary-value" id="summaryChildren">-</div>
        <div class="summary-label">Children</div>
      </div>
    </div>
    <div id="aggregateStats" style="margin-top: 16px; padding-top: 16px; border-top: 1px solid var(--border); display: none;">
      <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 12px;">
        <span style="color: var(--muted); font-size: 12px; text-transform: uppercase;">Total (including children)</span>
        <button class="btn" id="loadChildrenBtn" style="font-size: 11px; padding: 4px 10px;">Load All Children</button>
      </div>
      <div class="summary-grid">
        <div class="summary-item">
          <div class="summary-value" id="totalTurns">-</div>
          <div class="summary-label">Total Turns</div>
        </div>
        <div class="summary-item">
          <div class="summary-value" id="totalLLM">-</div>
          <div class="summary-label">Total LLM Calls</div>
        </div>
        <div class="summary-item">
          <div class="summary-value" id="totalTokens">-</div>
          <div class="summary-label">Total Tokens</div>
        </div>
        <div class="summary-item">
          <div class="summary-value" id="loadedChildren">-</div>
          <div class="summary-label">Loaded</div>
        </div>
      </div>
    </div>
  </div>

  <div class="timeline" id="timeline">
    <h3>Timeline</h3>
    <div class="timeline-bar" id="timelineBar"></div>
  </div>

  <div class="tabs" id="tabs" style="display: none;">
    <button class="tab active" data-filter="all">All Events</button>
    <button class="tab" data-filter="llm">LLM Calls</button>
    <button class="tab" data-filter="tool">Tools</button>
    <button class="tab" data-filter="pmap">Parallel</button>
  </div>

  <div class="events" id="events"></div>

  <div class="file-list" id="fileList">
    <h2>Loaded Files</h2>
    <div id="fileListItems"></div>
  </div>

  <div class="instructions">
    <strong>Usage:</strong><br>
    1. Run with tracing: <code>mix parallel_workers --trace</code><br>
    2. Drop all .jsonl files from <code>examples/parallel_workers/traces/</code> here<br>
    3. Click on events to expand details, click child traces to navigate
  </div>

  <script>
    const dropZone = document.getElementById('dropZone');
    const fileInput = document.getElementById('fileInput');
    const summary = document.getElementById('summary');
    const timeline = document.getElementById('timeline');
    const timelineBar = document.getElementById('timelineBar');
    const tabs = document.getElementById('tabs');
    const eventsContainer = document.getElementById('events');
    const fileList = document.getElementById('fileList');
    const fileListItems = document.getElementById('fileListItems');

    let loadedFiles = new Map();
    let currentFile = null;
    let currentFilter = 'all';

    // Drag and drop
    dropZone.addEventListener('dragover', (e) => { e.preventDefault(); dropZone.classList.add('dragover'); });
    dropZone.addEventListener('dragleave', () => { dropZone.classList.remove('dragover'); });
    dropZone.addEventListener('drop', (e) => { e.preventDefault(); dropZone.classList.remove('dragover'); handleFiles(e.dataTransfer.files); });
    fileInput.addEventListener('change', (e) => { handleFiles(e.target.files); });

    // Tab filtering
    document.querySelectorAll('.tab').forEach(tab => {
      tab.addEventListener('click', () => {
        document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
        tab.classList.add('active');
        currentFilter = tab.dataset.filter;
        if (currentFile) displayTrace(currentFile);
      });
    });

    async function handleFiles(files) {
      for (const file of files) {
        const text = await file.text();
        const events = parseJsonl(text);
        const traceId = extractTraceId(events);
        loadedFiles.set(file.name, { events, traceId, filename: file.name });
      }
      updateFileList();
      if (!currentFile && loadedFiles.size > 0) {
        const mainTrace = [...loadedFiles.entries()].find(([name]) => name.includes('rlm_trace') || !name.startsWith('trace_'));
        currentFile = mainTrace ? mainTrace[0] : [...loadedFiles.keys()][0];
      }
      if (currentFile) displayTrace(currentFile);
    }

    function parseJsonl(text) {
      return text.trim().split('\n').filter(l => l.trim()).map(line => {
        try { return JSON.parse(line); } catch { return null; }
      }).filter(Boolean);
    }

    function extractTraceId(events) {
      return events.find(e => e.event === 'trace.start')?.trace_id || 'unknown';
    }

    function updateFileList() {
      fileList.classList.toggle('visible', loadedFiles.size > 0);
      fileListItems.innerHTML = '';
      for (const [name, data] of loadedFiles) {
        const item = document.createElement('div');
        item.className = 'file-item' + (name === currentFile ? ' active' : '');
        item.innerHTML = `<span>${name}</span><span style="color: var(--muted); font-size: 11px;">${data.traceId.slice(0, 8)}...</span>`;
        item.onclick = () => { currentFile = name; displayTrace(name); updateFileList(); };
        fileListItems.appendChild(item);
      }
    }

    function displayTrace(filename) {
      const data = loadedFiles.get(filename);
      if (!data) return;

      const events = data.events;
      const paired = pairEvents(events);

      // Summary
      summary.classList.add('visible');
      const llmEvents = paired.filter(e => e.type === 'llm');
      // Duration from run.stop (primary) or trace.stop (fallback)
      const runStop = events.find(e => e.event === 'run.stop');
      const traceStop = events.find(e => e.event === 'trace.stop');
      const totalDuration = runStop?.duration_ms || traceStop?.duration_ms || 0;
      const totalTokens = llmEvents.reduce((sum, e) => sum + (e.stop?.measurements?.tokens || 0), 0);
      const childIds = extractChildTraceIds(events);

      document.getElementById('summaryDuration').textContent = formatDuration(totalDuration);
      // Count turns from LLM events (max turn number)
      const maxTurn = llmEvents.reduce((max, e) => Math.max(max, e.stop?.metadata?.turn || 0), 0);
      document.getElementById('summaryTurns').textContent = maxTurn;
      document.getElementById('summaryLLM').textContent = llmEvents.length;
      document.getElementById('summaryTokens').textContent = totalTokens.toLocaleString();
      document.getElementById('summaryChildren').textContent = childIds.length;

      // Show aggregate stats section if there are children
      const aggregateSection = document.getElementById('aggregateStats');
      if (childIds.length > 0) {
        aggregateSection.style.display = 'block';
        updateAggregateStats();
      } else {
        aggregateSection.style.display = 'none';
      }

      // Timeline
      timeline.classList.add('visible');
      renderTimeline(paired, totalDuration);

      // Events
      tabs.style.display = 'flex';
      eventsContainer.classList.add('visible');
      renderEvents(paired);
    }

    function pairEvents(events) {
      const pairs = [];
      const pending = {};

      for (const event of events) {
        if (!event.event) continue;
        const [type, action] = event.event.split('.');

        // Use span_id for pairing (most reliable), fallback to type+turn/tool_name
        const spanId = event.span_id;
        const key = spanId ? `${type}-${spanId}` : `${type}-${event.metadata?.turn || event.metadata?.tool_name || ''}`;

        if (action === 'start') {
          pending[key] = event;
        } else if (action === 'stop') {
          const startEvent = pending[key];
          if (startEvent) {
            pairs.push({ type, start: startEvent, stop: event });
            delete pending[key];
          } else {
            // No matching start - create a stop-only pair for display
            pairs.push({ type, start: null, stop: event });
          }
        }
      }
      return pairs;
    }

    function extractChildTraceIds(events) {
      const ids = new Set();
      for (const e of events) {
        (e.child_trace_ids || []).forEach(id => ids.add(id));
        if (e.child_trace_id) ids.add(e.child_trace_id);
        (e.metadata?.child_trace_ids || []).forEach(id => ids.add(id));
      }
      return [...ids];
    }

    function renderTimeline(pairs, totalDuration) {
      timelineBar.innerHTML = '';
      if (!totalDuration) return;

      // Get the start timestamp as reference
      const startTs = getEarliestTimestamp(pairs);

      for (const pair of pairs) {
        if (!['llm', 'tool', 'pmap'].includes(pair.type)) continue;
        const duration = pair.stop?.duration_ms || 0;
        if (duration === 0) continue;

        // Calculate position based on timestamps if available
        let left = 0;
        if (pair.start?.timestamp && startTs) {
          const eventStart = new Date(pair.start.timestamp).getTime();
          const offsetMs = eventStart - startTs;
          left = (offsetMs / totalDuration) * 100;
        }

        const width = (duration / totalDuration) * 100;

        const segment = document.createElement('div');
        segment.className = `timeline-segment ${pair.type}`;
        segment.style.left = `${Math.max(0, left)}%`;
        segment.style.width = `${Math.max(width, 1)}%`;
        segment.textContent = pair.type === 'llm' ? `T${pair.stop?.metadata?.turn || '?'}` : pair.type;
        segment.title = `${pair.type}: ${formatDuration(duration)}`;
        timelineBar.appendChild(segment);
      }
    }

    function getEarliestTimestamp(pairs) {
      let earliest = null;
      for (const pair of pairs) {
        if (pair.start?.timestamp) {
          const ts = new Date(pair.start.timestamp).getTime();
          if (!earliest || ts < earliest) earliest = ts;
        }
      }
      return earliest;
    }

    function renderEvents(pairs) {
      // Filter out low-value structural events (turn, run) - their info is shown elsewhere
      const displayableTypes = ['llm', 'tool', 'pmap', 'pcalls'];
      let filtered = pairs.filter(p => displayableTypes.includes(p.type));
      if (currentFilter !== 'all') {
        filtered = filtered.filter(p => p.type === currentFilter);
      }
      eventsContainer.innerHTML = filtered.map(pair => renderEventCard(pair)).join('');

      // Add click handlers
      eventsContainer.querySelectorAll('.event-header').forEach(header => {
        header.onclick = () => header.closest('.event-card').classList.toggle('expanded');
      });

      // Child trace navigation
      eventsContainer.querySelectorAll('.child-trace-item').forEach(item => {
        item.onclick = () => {
          const traceId = item.dataset.traceid;
          const file = findFileByTraceId(traceId);
          if (file) { currentFile = file; displayTrace(file); updateFileList(); }
        };
      });
    }

    function renderEventCard(pair) {
      const { type, start, stop } = pair;
      const duration = stop?.duration_ms || 0;
      const tokens = stop?.measurements?.tokens || stop?.metadata?.tokens || 0;
      const turn = stop?.metadata?.turn || start?.metadata?.turn;
      const hasError = stop?.metadata?.error;

      let title = type;
      let icon = 'üì¶';
      let meta = [];

      if (type === 'llm') {
        title = `LLM Call${turn ? ` (Turn ${turn})` : ''}`;
        icon = 'ü§ñ';
        meta.push(`<span>‚è± ${formatDuration(duration)}</span>`);
        if (tokens) meta.push(`<span>üìä ${tokens} tokens</span>`);
      } else if (type === 'turn') {
        title = `Turn ${stop?.metadata?.turn_number || '?'}`;
        icon = 'üîÑ';
        meta.push(`<span>‚è± ${formatDuration(duration)}</span>`);
      } else if (type === 'tool') {
        title = stop?.metadata?.tool_name || 'Tool';
        icon = 'üîß';
        meta.push(`<span>‚è± ${formatDuration(duration)}</span>`);
      } else if (type === 'pmap' || type === 'pcalls') {
        const count = stop?.metadata?.count || '?';
        title = `${type} (${count} tasks)`;
        icon = '‚ö°';
        meta.push(`<span>‚è± ${formatDuration(duration)}</span>`);
        meta.push(`<span>‚úì ${stop?.metadata?.success_count || 0} / ‚úó ${stop?.metadata?.error_count || 0}</span>`);
      }

      let bodyContent = '';

      // LLM specific content
      if (type === 'llm') {
        const response = stop?.metadata?.response || '';
        const thinking = extractThinking(response);
        const program = extractProgram(response);
        const prompt = getLastUserMessage(start?.metadata?.messages);

        if (thinking) {
          bodyContent += `
            <div class="event-section">
              <div class="event-section-title">üí≠ Thinking</div>
              <div class="thinking-block">${escapeHtml(thinking)}</div>
            </div>`;
        }

        if (program) {
          bodyContent += `
            <div class="event-section">
              <div class="event-section-title">üìù Program</div>
              <div class="code-block">${highlightLisp(program)}</div>
            </div>`;
        }

        if (prompt) {
          const isStub = /^String\(\d+ bytes\)$/.test(prompt);
          const promptLabel = isStub ? 'üì® Prompt (not captured ‚Äî re-run with updated tracer)' : 'üì® Prompt';
          bodyContent += `
            <div class="event-section">
              <div class="event-section-title">${promptLabel}</div>
              <div class="code-block" style="max-height: 300px; overflow-y: auto;">${isStub ? `<span style="color: var(--muted)">${escapeHtml(prompt)}</span>` : escapeHtml(truncate(prompt, 2000))}</div>
            </div>`;
        }
      }

      // Child traces
      const childIds = stop?.metadata?.child_trace_ids || [];
      if (childIds.length > 0) {
        bodyContent += `
          <div class="event-section">
            <div class="event-section-title">üë∂ Child Traces (${childIds.length})</div>
            <div class="child-traces">
              ${childIds.map(id => {
                const file = findFileByTraceId(id);
                return `<div class="child-trace-item" data-traceid="${id}">
                  <span class="id">${id.slice(0, 12)}...</span>
                  <span class="status">${file ? '‚Üí' : '(not loaded)'}</span>
                </div>`;
              }).join('')}
            </div>
          </div>`;
      }

      // Tool args (check both start and stop metadata)
      const toolArgs = start?.metadata?.args || stop?.metadata?.args;
      if (type === 'tool' && toolArgs) {
        bodyContent += `
          <div class="event-section">
            <div class="event-section-title">üì• Arguments</div>
            <div class="code-block" style="max-height: 300px; overflow-y: auto;">${escapeHtml(JSON.stringify(toolArgs, null, 2))}</div>
          </div>`;
      }

      // Tool result
      const toolResult = stop?.metadata?.result;
      if (type === 'tool' && toolResult != null) {
        const resultStr = typeof toolResult === 'string' ? toolResult : JSON.stringify(toolResult, null, 2);
        bodyContent += `
          <div class="event-section">
            <div class="event-section-title">üì§ Result</div>
            <div class="code-block" style="max-height: 300px; overflow-y: auto;">${escapeHtml(truncate(resultStr, 2000))}</div>
          </div>`;
      }

      return `
        <div class="event-card ${type}${hasError ? ' error' : ''}">
          <div class="event-header">
            <div class="event-toggle">‚ñ∂</div>
            <div class="event-icon ${type}">${icon}</div>
            <div class="event-title">${escapeHtml(title)}</div>
            <div class="event-meta">${meta.join('')}</div>
          </div>
          <div class="event-body">${bodyContent || '<div class="event-section" style="color: var(--muted);">No additional details</div>'}</div>
        </div>`;
    }

    function extractThinking(response) {
      if (!response) return '';
      const match = response.match(/thinking:\s*([\s\S]*?)(?=```|$)/i);
      return match ? match[1].trim() : '';
    }

    function extractProgram(response) {
      if (!response) return '';
      const match = response.match(/```clojure\n([\s\S]*?)```/);
      return match ? match[1].trim() : '';
    }

    function getLastUserMessage(messages) {
      if (!messages) return '';
      const userMsgs = messages.filter(m => m.role === 'user');
      return userMsgs.length > 0 ? userMsgs[userMsgs.length - 1].content : '';
    }

    function highlightLisp(code) {
      // Important: Use single quotes for HTML attributes to avoid conflict
      // with the double-quote string pattern in Lisp
      return escapeHtml(code)
        .replace(/;[^\n]*/g, "<span class='comment'>$&</span>")
        .replace(/\b(def|defn|let|if|cond|when|do|fn|loop|recur|return|fail|pmap|pcalls|doseq|for)\b/g, "<span class='keyword'>$1</span>")
        .replace(/\b(map|filter|reduce|first|rest|count|get|assoc|conj|into|take|drop|distinct|concat|str|println|inc|dec)\b/g, "<span class='builtin'>$1</span>")
        .replace(/"([^"\\]|\\.)*"/g, "<span class='string'>$&</span>")
        .replace(/\b(\d+\.?\d*)\b/g, "<span class='number'>$1</span>")
        .replace(/:([\w-]+)/g, "<span class='symbol'>:$1</span>")
        .replace(/data\/[\w-]+/g, "<span class='symbol'>$&</span>")
        .replace(/tool\/[\w-]+/g, "<span class='builtin'>$&</span>");
    }

    function findFileByTraceId(traceId) {
      for (const [name, data] of loadedFiles) {
        if (data.traceId === traceId) return name;
      }
      return null;
    }

    function formatDuration(ms) {
      if (ms == null) return '-';
      if (ms < 1000) return `${ms}ms`;
      if (ms < 60000) return `${(ms / 1000).toFixed(1)}s`;
      return `${(ms / 60000).toFixed(1)}m`;
    }

    function truncate(str, len) {
      return str && str.length > len ? str.slice(0, len) + '...' : str || '';
    }

    function escapeHtml(text) {
      if (!text) return '';
      const div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML;
    }

    // Aggregate stats across all loaded traces
    function updateAggregateStats() {
      let totalTurns = 0;
      let totalLLM = 0;
      let totalTokens = 0;
      let loadedCount = 0;

      // Get child IDs from current trace
      const mainData = loadedFiles.get(currentFile);
      const childIds = mainData ? extractChildTraceIds(mainData.events) : [];

      for (const [name, data] of loadedFiles) {
        const paired = pairEvents(data.events);
        const llmEvents = paired.filter(e => e.type === 'llm');
        const maxTurn = llmEvents.reduce((max, e) => Math.max(max, e.stop?.metadata?.turn || 0), 0);

        totalTurns += maxTurn;
        totalLLM += llmEvents.length;
        totalTokens += llmEvents.reduce((sum, e) => sum + (e.stop?.measurements?.tokens || 0), 0);

        // Count how many children are loaded
        if (childIds.includes(data.traceId)) loadedCount++;
      }

      document.getElementById('totalTurns').textContent = totalTurns;
      document.getElementById('totalLLM').textContent = totalLLM;
      document.getElementById('totalTokens').textContent = totalTokens.toLocaleString();
      document.getElementById('loadedChildren').textContent = loadedCount + ' / ' + childIds.length;

      // Update button state
      const btn = document.getElementById('loadChildrenBtn');
      if (loadedCount >= childIds.length) {
        btn.textContent = 'All Loaded';
        btn.disabled = true;
        btn.style.opacity = '0.5';
      } else {
        btn.textContent = 'Load All Children';
        btn.disabled = false;
        btn.style.opacity = '1';
      }
    }

    // Load all child traces from the server
    async function loadAllChildren() {
      const mainData = loadedFiles.get(currentFile);
      if (!mainData) return;

      const childIds = extractChildTraceIds(mainData.events);
      const btn = document.getElementById('loadChildrenBtn');
      btn.textContent = 'Loading...';
      btn.disabled = true;

      let loaded = 0;
      for (const childId of childIds) {
        // Skip if already loaded
        if (findFileByTraceId(childId)) continue;

        // Try to fetch the child trace file
        const filename = 'trace_' + childId + '.jsonl';
        try {
          const response = await fetch('traces/' + filename);
          if (response.ok) {
            const text = await response.text();
            const events = parseJsonl(text);
            const traceId = extractTraceId(events);
            loadedFiles.set(filename, { events, traceId, filename });
            loaded++;
          }
        } catch (e) {
          console.log('Could not load ' + filename);
        }
      }

      updateFileList();
      updateAggregateStats();

      if (loaded > 0) {
        btn.textContent = 'Loaded ' + loaded + ' files';
      } else {
        btn.textContent = 'All Loaded';
      }
      setTimeout(() => updateAggregateStats(), 100);
    }

    // Wire up the load children button
    document.getElementById('loadChildrenBtn').addEventListener('click', loadAllChildren);
  </script>
</body>
</html>
