# PTC-Lisp Language Reference (for LLM prompts)

This file contains the PTC-Lisp language reference extracted for use in LLM system prompts.

**Do not edit this file directly.** The content between the markers is the single source of
truth for the PTC-Lisp LLM prompt. Access it via `PtcRunner.Lisp.Schema.to_prompt/0`.

<!-- PTC_PROMPT_START -->

### Language Overview

**PTC-Lisp** is a minimal Clojure subset for data transformation. Programs are **single expressions**.
**Only use functions documented below** - many Clojure functions (seq, vector, apply, rest, etc.) are not available.

### Data Types
```clojure
nil true false        ; nil and booleans
42 3.14               ; numbers
"hello"               ; strings
:keyword              ; keywords (NO namespaced keywords like :foo/bar)
[1 2 3]               ; vectors (NO lists '(1 2 3))
#{1 2 3}              ; sets (unordered, unique values)
{:a 1 :b 2}           ; maps
```

### Accessing Data
```clojure
ctx/input             ; read from request context
memory/results        ; read from persistent memory
; NOTE: ctx and memory are NOT accessible as whole maps, only via namespace prefix
```

### Special Forms
```clojure
(let [x 1, y 2] body)              ; local bindings
(let [{:keys [a b]} m] body)       ; map destructuring
(if cond then else)                ; conditional (else is REQUIRED)
(when cond body)                   ; single-branch returns nil if false
(if-let [x expr] then else)        ; bind x, eval then if truthy, else otherwise
(when-let [x expr] body)           ; bind x, eval body if truthy, else nil
(cond c1 r1 c2 r2 :else default)   ; multi-way conditional
(do expr1 expr2 ... exprN)         ; sequential eval, returns last
(fn [x] body)                      ; anonymous function
(fn [{:keys [x]}] body)            ; with destructuring
#(+ % 1)                           ; short syntax: % is arg, %1 %2 for multiple
(< a b)                            ; comparisons are 2-arity ONLY, NOT (<= a b c)
```

### Threading (chained transformations)
```clojure
(->> coll (filter pred) (map f) (take 5))   ; thread-last
(-> m (assoc :a 1) (dissoc :b))             ; thread-first
```

### Predicate Builders
```clojure
(where :field = value)             ; MUST include operator
(where :field > 10)                ; operators: = not= > < >= <= includes in
(where [:nested :path] = value)    ; nested field access
(where :field)                     ; truthy check (not nil, not false)
(where :status in ["a" "b"])       ; membership test
```

**Prefer truthy checks for boolean flags:**
```clojure
; GOOD - concise, handles messy data (1, "yes", etc.)
(filter (where :active) users)
(filter (where :verified) accounts)

; AVOID - only needed when distinguishing true from other truthy values
(filter (where :active = true) users)
```

**Combining predicates â€” use `all-of`/`any-of`/`none-of`, NOT `and`/`or`:**
```clojure
; WRONG - and/or return values, not combined predicates
(filter (and (where :a = 1) (where :b = 2)) coll)   ; BUG!

; CORRECT - predicate combinators
(filter (all-of (where :a = 1) (where :b = 2)) coll)
(filter (any-of (where :x = 1) (where :y = 1)) coll)
(filter (none-of (where :deleted)) coll)
```

### Core Functions
```clojure
; Arithmetic & Comparison
(+ 1 2 3)  (- 10 3)  (* 2 3)  (/ 10 2)  (mod 10 3)
(inc x)  (dec x)  (abs x)  (max 1 5 3)  (min 1 5 3)
(= a b)  (not= a b)  (< a b)  (> a b)  (<= a b)  (>= a b)

; Logic
(and x y ...)  (or x y ...)  (not x)

; Filtering
(filter pred coll)  (remove pred coll)  (find pred coll)
(some pred coll)  (every? pred coll)  (not-any? pred coll)

; Transforming
(map f coll)  (mapv f coll)  (pluck :key coll)  (reduce f init coll)
; map/filter/remove/sort-by on maps: each entry is [key value] vector
; Example: (map (fn [[key value]] {:cat key :avg (avg-by :amount value)}) grouped)

; Ordering
(sort coll)  (sort-by :key coll)  (sort-by :key > coll)  (reverse coll)

; Subsetting
(first coll)  (second coll)  (last coll)  (take n coll)  (drop n coll)  (nth coll i)
(take-while pred coll)  (drop-while pred coll)  (distinct coll)

; Combining
(conj coll x)  (concat c1 c2)  (into [] coll)  (flatten nested)  (zip c1 c2)

; Aggregation
(count coll)  (empty? coll)  (sum-by :key coll)  (avg-by :key coll)
(min-by :key coll)  (max-by :key coll)
(group-by :key coll)  ; returns {key => [items...]}, NOT counts!
; To count per group: (update-vals (group-by :key coll) count) - do NOT use ->>

; Maps
(get m :key)  (get-in m [:a :b])  (assoc m :k v)  (assoc-in m [:a :b] v)
(update m :k f)  (update-in m [:a :b] f)  (dissoc m :k)  (merge m1 m2)
(select-keys m [:a :b])  (keys m)  (vals m)  (entries m)
(:key m)  (:key m default)  ; keyword as function
(update-vals m f)  ; apply f to each value in map
(update-vals {:a 1 :b 2} inc)                        ; => {:a 2 :b 3}
(update-vals (group-by :region sales) count)         ; count per group

; group-by + update-vals: don't thread data through both, call group-by directly:
(-> (group-by :cat data) (update-vals f))   ; CORRECT
(->> data (group-by :cat) (update-vals f))  ; WRONG - incompatible arg positions

; Sets
(set? x)  (set [1 2 2])  (contains? #{1 2} 1)
; Note: map, filter, remove work on sets but return vectors

; Strings
(str "a" "b" 42)  (subs s start end)  (split s ",")  (join ", " coll)
(trim s)  (replace s "old" "new")  (upcase s)  (downcase s)
(starts-with? s prefix)  (ends-with? s suffix)  (includes? s sub)
(parse-long "42")  (parse-double "3.14")  ; returns nil on failure

; Type Predicates
(nil? x)  (some? x)  (number? x)  (string? x)  (keyword? x)
(vector? x)  (map? x)  (set? x)  (coll? x)  (boolean? x)
(zero? x)  (pos? x)  (neg? x)  (even? x)  (odd? x)
```

### Tool Calls
```clojure
(call "tool-name")                 ; no arguments
(call "tool-name" {:arg1 value})   ; with arguments map
; tool name MUST be a string literal
; WRONG: (call tool-name {...})    ; symbol not allowed
; WRONG: (call :tool-name {...})   ; keyword not allowed
```

### Memory: Persisting Data Between Turns

Use memory to store intermediate results and reference them in later programs.

**Reading from memory:**
```clojure
memory/results           ; access stored value by key
```

**Writing to memory:** Return a map to persist keys:

| Return | Effect |
|--------|--------|
| Non-map (number, vector, etc.) | No memory update, value returned |
| Map without `:result` | Merge into memory, map returned |
| Map with `:result` | Merge rest into memory, `:result` value returned |

**Multi-turn example:**
```clojure
; Turn 1: Store expensive computation
{:unique-users (->> ctx/events (pluck :user_id) (distinct))}

; Turn 2: Reference stored result
{:active-count (count memory/unique-users)
 :total-count (count ctx/sessions)
 :result (count memory/unique-users)}
```

**Other patterns:**
```clojure
; Pure query - no memory change
(->> ctx/items (filter (where :active)) (count))

; Store tool result for later use
{:cached-users (call "get-users" {})}
```

### Common Mistakes

| Wrong | Right |
|-------|-------|
| `(where :status "active")` | `(where :status = "active")` |
| `(where :active true)` | `(where :active)` (preferred) or `(where :active = true)` |
| `(and (where :a = 1) (where :b = 2))` | `(all-of (where :a = 1) (where :b = 2))` |
| `(<= 100 x 500)` | `(and (>= x 100) (<= x 500))` |
| `(ctx :input)` | `ctx/input` |
| `(call :get-users {})` | `(call "get-users" {})` |
| `(if cond then)` | `(if cond then nil)` or `(when cond then)` |
| `'(1 2 3)` | `[1 2 3]` |
| `:foo/bar` | `:foo-bar` (no namespaced keywords) |
| `(->> d (group-by :k) (update-vals f))` | `(-> (group-by :k d) (update-vals f))` |
| `#(> (:price %) 100)` in filter | `(where :price > 100)` (simpler) |

**Key constraints:**
- `where` predicates MUST have an operator (except for truthy check)
- Comparisons are strictly 2-arity: use `(and (>= x 100) (<= x 500))` NOT `(<= 100 x 500)`

<!-- PTC_PROMPT_END -->
