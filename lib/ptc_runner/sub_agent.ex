defmodule PtcRunner.SubAgent do
  @moduledoc """
  SubAgent definition for PtcRunner.

  A SubAgent is an isolated worker that executes tasks using PTC-Lisp programs
  generated by an LLM. SubAgents are defined as structs via `new/1`, separating
  definition from execution.

  See the [SubAgent Specification](docs/ptc_agents/specification.md) for full details.

  ## Fields

  - `prompt` - String.t(), required, template with `{{placeholder}}` support
  - `signature` - String.t() | nil, optional, contract for inputs/outputs
  - `tools` - map(), callable tools (default: %{})
  - `max_turns` - pos_integer(), maximum LLM calls (default: 5)
  - `tool_catalog` - map() | nil, schemas for planning (not callable)
  - `prompt_limit` - map() | nil, truncation config for LLM view
  - `mission_timeout` - pos_integer() | nil, max ms for entire execution
  - `llm_retry` - map() | nil, infrastructure retry config
  - `llm` - atom() | function() | nil, optional LLM override
  - `system_prompt` - system_prompt_opts() | nil, system prompt customization

  ## Examples

  Minimal SubAgent with just a prompt:
      iex> agent = PtcRunner.SubAgent.new(prompt: "Analyze the data")
      iex> agent.prompt
      "Analyze the data"
      iex> agent.max_turns
      5
      iex> agent.tools
      %{}

  SubAgent with all options:
      iex> email_tools = %{"list_emails" => fn _args -> [] end}
      iex> agent = PtcRunner.SubAgent.new(
      ...>   prompt: "Find urgent emails for {{user}}",
      ...>   signature: "(user :string) -> {count :int, _ids [:int]}",
      ...>   tools: email_tools,
      ...>   max_turns: 10
      ...> )
      iex> agent.prompt
      "Find urgent emails for {{user}}"
      iex> agent.max_turns
      10
  """

  @type system_prompt_opts ::
          %{
            optional(:prefix) => String.t(),
            optional(:suffix) => String.t(),
            optional(:language_spec) => String.t(),
            optional(:output_format) => String.t()
          }
          | (String.t() -> String.t())
          | String.t()

  @type t :: %__MODULE__{
          prompt: String.t(),
          signature: String.t() | nil,
          tools: map(),
          max_turns: pos_integer(),
          tool_catalog: map() | nil,
          prompt_limit: map() | nil,
          mission_timeout: pos_integer() | nil,
          llm_retry: map() | nil,
          llm: atom() | (map() -> {:ok, String.t()} | {:error, term()}) | nil,
          system_prompt: system_prompt_opts() | nil
        }

  defstruct [
    :prompt,
    :signature,
    :tool_catalog,
    :prompt_limit,
    :mission_timeout,
    :llm_retry,
    :llm,
    :system_prompt,
    tools: %{},
    max_turns: 5
  ]

  @doc """
  Creates a SubAgent struct from keyword options.

  Raises `ArgumentError` if validation fails (missing required fields or invalid types).

  ## Parameters

  - `opts` - Keyword list of options

  ## Required Options

  - `prompt` - String template describing what to accomplish (supports `{{placeholder}}` expansion)

  ## Optional Options

  - `signature` - String contract defining expected inputs and outputs
  - `tools` - Map of callable tools (default: %{})
  - `max_turns` - Positive integer for maximum LLM calls (default: 5)
  - `tool_catalog` - Map of schemas for planning (not callable)
  - `prompt_limit` - Map with truncation config for LLM view
  - `mission_timeout` - Positive integer for max milliseconds for entire execution
  - `llm_retry` - Map with infrastructure retry config
  - `llm` - Atom or function for optional LLM override
  - `system_prompt` - System prompt customization (map, function, or string)

  ## Returns

  A `%SubAgent{}` struct.

  ## Raises

  - `ArgumentError` - if prompt is missing or not a string, max_turns is not positive, tools is not a map, any optional field has an invalid type, or prompt placeholders don't match signature parameters (when signature is provided)

  ## Examples

      iex> agent = PtcRunner.SubAgent.new(prompt: "Analyze the data")
      iex> agent.prompt
      "Analyze the data"

      iex> email_tools = %{"list_emails" => fn _args -> [] end}
      iex> agent = PtcRunner.SubAgent.new(
      ...>   prompt: "Find urgent emails for {{user}}",
      ...>   signature: "(user :string) -> {count :int, _ids [:int]}",
      ...>   tools: email_tools,
      ...>   max_turns: 10
      ...> )
      iex> agent.max_turns
      10
  """
  @spec new(keyword()) :: t()
  def new(opts) when is_list(opts) do
    validate_required_fields!(opts)
    validate_types!(opts)
    struct(__MODULE__, opts)
  end

  # Validate that required fields are present
  defp validate_required_fields!(opts) do
    case Keyword.fetch(opts, :prompt) do
      {:ok, _} -> :ok
      :error -> raise ArgumentError, "prompt is required"
    end
  end

  # Validate types of provided fields
  defp validate_types!(opts) do
    validate_prompt!(opts)
    validate_tools!(opts)
    validate_max_turns!(opts)
    validate_mission_timeout!(opts)
    validate_signature!(opts)
    validate_llm_retry!(opts)
    validate_tool_catalog!(opts)
    validate_prompt_limit!(opts)
    validate_prompt_placeholders!(opts)
  end

  defp validate_prompt!(opts) do
    case Keyword.fetch(opts, :prompt) do
      {:ok, prompt} when is_binary(prompt) -> :ok
      {:ok, _} -> raise ArgumentError, "prompt must be a string"
      :error -> :ok
    end
  end

  defp validate_tools!(opts) do
    case Keyword.fetch(opts, :tools) do
      {:ok, tools} when is_map(tools) -> :ok
      {:ok, _} -> raise ArgumentError, "tools must be a map"
      :error -> :ok
    end
  end

  defp validate_max_turns!(opts) do
    case Keyword.fetch(opts, :max_turns) do
      {:ok, max_turns} when is_integer(max_turns) and max_turns > 0 -> :ok
      {:ok, _} -> raise ArgumentError, "max_turns must be a positive integer"
      :error -> :ok
    end
  end

  defp validate_mission_timeout!(opts) do
    case Keyword.fetch(opts, :mission_timeout) do
      {:ok, timeout} when is_integer(timeout) and timeout > 0 -> :ok
      {:ok, _} -> raise ArgumentError, "mission_timeout must be a positive integer"
      :error -> :ok
    end
  end

  defp validate_signature!(opts) do
    case Keyword.fetch(opts, :signature) do
      {:ok, sig} when is_binary(sig) -> :ok
      {:ok, _} -> raise ArgumentError, "signature must be a string"
      :error -> :ok
    end
  end

  defp validate_llm_retry!(opts) do
    case Keyword.fetch(opts, :llm_retry) do
      {:ok, retry} when is_map(retry) -> :ok
      {:ok, _} -> raise ArgumentError, "llm_retry must be a map"
      :error -> :ok
    end
  end

  defp validate_tool_catalog!(opts) do
    case Keyword.fetch(opts, :tool_catalog) do
      {:ok, catalog} when is_map(catalog) -> :ok
      {:ok, _} -> raise ArgumentError, "tool_catalog must be a map"
      :error -> :ok
    end
  end

  defp validate_prompt_limit!(opts) do
    case Keyword.fetch(opts, :prompt_limit) do
      {:ok, limit} when is_map(limit) -> :ok
      {:ok, _} -> raise ArgumentError, "prompt_limit must be a map"
      :error -> :ok
    end
  end

  # Validate that prompt placeholders match signature parameters
  defp validate_prompt_placeholders!(opts) do
    with {:ok, prompt} <- Keyword.fetch(opts, :prompt),
         {:ok, signature} <- Keyword.fetch(opts, :signature) do
      placeholders = extract_placeholders(prompt)
      signature_params = extract_signature_params(signature)

      case placeholders -- signature_params do
        [] ->
          :ok

        missing ->
          formatted_missing = Enum.map_join(missing, ", ", &"{{#{&1}}}")

          raise ArgumentError,
                "placeholders #{formatted_missing} not found in signature"
      end
    else
      _ -> :ok
    end
  end

  # Extract placeholders from prompt template (e.g., "{{user}}" -> "user")
  defp extract_placeholders(prompt) do
    ~r/\{\{([^}]+)\}\}/
    |> Regex.scan(prompt, capture: :all_but_first)
    |> List.flatten()
    |> Enum.map(&String.trim/1)
    |> Enum.uniq()
  end

  # Extract parameter names from signature string
  defp extract_signature_params(signature) do
    alias PtcRunner.SubAgent.Signature.Parser

    case Parser.parse(signature) do
      {:ok, {:signature, params, _output}} ->
        Enum.map(params, fn {name, _type} -> name end)

      {:error, _reason} ->
        # If signature parsing fails, we can't validate placeholders
        # Let the signature validation fail elsewhere
        []
    end
  end

  @doc """
  Executes a SubAgent with the given options.

  Returns a `Step` struct containing the result, metrics, and execution trace.

  ## Parameters

  - `agent` - A `%SubAgent{}` struct or a string prompt (for convenience)
  - `opts` - Keyword list of runtime options

  ## Runtime Options

  - `llm` - Required. LLM callback function `(map() -> {:ok, String.t()} | {:error, term()})` or atom
  - `context` - Map of input data (default: %{})
  - Other options from agent definition can be overridden

  ## Returns

  - `{:ok, Step.t()}` on success
  - `{:error, Step.t()}` on failure

  ## Examples

      # Using a SubAgent struct
      iex> agent = PtcRunner.SubAgent.new(prompt: "Calculate {{x}} + {{y}}", max_turns: 1)
      iex> llm = fn %{messages: [%{content: _prompt}]} -> {:ok, "```clojure\\n(+ ctx/x ctx/y)\\n```"} end
      iex> {:ok, step} = PtcRunner.SubAgent.run(agent, llm: llm, context: %{x: 5, y: 3})
      iex> step.return
      8

      # Using string convenience form
      iex> llm = fn %{messages: [%{content: _prompt}]} -> {:ok, "```clojure\\n42\\n```"} end
      iex> {:ok, step} = PtcRunner.SubAgent.run("Return 42", max_turns: 1, llm: llm)
      iex> step.return
      42
  """
  @spec run(t() | String.t(), keyword()) ::
          {:ok, PtcRunner.Step.t()} | {:error, PtcRunner.Step.t()}
  def run(agent_or_prompt, opts \\ [])

  # String convenience form - creates agent inline
  def run(prompt, opts) when is_binary(prompt) do
    # Extract struct fields from opts
    struct_opts =
      opts
      |> Keyword.take([
        :signature,
        :tools,
        :max_turns,
        :tool_catalog,
        :prompt_limit,
        :mission_timeout,
        :llm_retry,
        :llm,
        :system_prompt
      ])
      |> Keyword.put(:prompt, prompt)

    agent = new(struct_opts)

    # Remove struct opts and pass runtime opts
    runtime_opts =
      Keyword.drop(opts, [
        :signature,
        :tools,
        :max_turns,
        :tool_catalog,
        :prompt_limit,
        :mission_timeout,
        :llm_retry,
        :system_prompt,
        :prompt
      ])

    run(agent, runtime_opts)
  end

  # Main implementation with SubAgent struct
  def run(%__MODULE__{} = agent, opts) do
    start_time = System.monotonic_time(:millisecond)

    # Validate required llm option
    llm = Keyword.get(opts, :llm) || agent.llm

    if llm do
      # Get context
      context = Keyword.get(opts, :context, %{})

      # Determine execution mode
      if agent.max_turns == 1 and map_size(agent.tools) == 0 do
        # Single-shot mode
        run_single_shot(agent, llm, context, start_time)
      else
        # Loop mode - delegate to Loop.run/2
        alias PtcRunner.SubAgent.Loop
        Loop.run(agent, llm: llm, context: context)
      end
    else
      return_error(:llm_required, "llm option is required", %{}, start_time)
    end
  end

  # Single-shot execution: one LLM call, no tools, expression result returned
  defp run_single_shot(agent, llm, context, start_time) do
    # Expand template in prompt
    expanded_prompt = expand_template(agent.prompt, context)

    # Build LLM input
    llm_input = %{
      system: default_system_prompt(),
      messages: [%{role: :user, content: expanded_prompt}]
    }

    # Call LLM
    case call_llm(llm, llm_input) do
      {:ok, response} ->
        # Extract code from response
        case extract_code(response) do
          {:ok, code} ->
            # Execute via Lisp
            lisp_result = PtcRunner.Lisp.run(code, context: context, tools: %{})

            # Add usage metrics from this execution
            case lisp_result do
              {:ok, step} ->
                duration_ms = System.monotonic_time(:millisecond) - start_time
                updated_step = update_step_usage(step, duration_ms)
                {:ok, updated_step}

              {:error, step} ->
                duration_ms = System.monotonic_time(:millisecond) - start_time
                updated_step = update_step_usage(step, duration_ms)
                {:error, updated_step}
            end

          :none ->
            return_error(
              :no_code_found,
              "No PTC-Lisp code found in LLM response",
              %{},
              start_time
            )
        end

      {:error, reason} ->
        return_error(:llm_error, "LLM call failed: #{inspect(reason)}", %{}, start_time)
    end
  end

  # Expand template placeholders with context values
  defp expand_template(prompt, context) when is_map(context) do
    Regex.replace(~r/\{\{\s*(\w+)\s*\}\}/, prompt, fn _, key ->
      try do
        # Try as atom first, then as string
        context
        |> Map.get(String.to_existing_atom(key), Map.get(context, key, "{{#{key}}}"))
        |> to_string()
      rescue
        ArgumentError ->
          # String.to_existing_atom failed, try as string key
          context
          |> Map.get(key, "{{#{key}}}")
          |> to_string()
      end
    end)
  end

  # Extract PTC-Lisp code from LLM response
  defp extract_code(text) do
    # Try extracting from markdown code block (lisp, clojure, or unmarked)
    case Regex.run(~r/```(?:lisp|clojure)?\s*([\s\S]+?)\s*```/, text) do
      [_, content] ->
        {:ok, String.trim(content)}

      nil ->
        # Try finding a bare S-expression (starts with paren)
        # Match expressions like (+ 40 2) or more complex ones
        trimmed = String.trim(text)

        if String.starts_with?(trimmed, "(") do
          {:ok, trimmed}
        else
          :none
        end
    end
  end

  # Minimal system prompt for single-shot mode
  defp default_system_prompt do
    """
    You are an AI that solves tasks by writing PTC-Lisp programs.
    Output your program in a ```clojure code block.
    """
  end

  # Call the LLM (function or atom)
  defp call_llm(llm, input) when is_function(llm) do
    llm.(input)
  end

  defp call_llm(llm, _input) when is_atom(llm) do
    # For now, atoms are not supported (registry support comes later)
    {:error, :llm_atom_not_supported}
  end

  # Helper to create error Step
  defp return_error(reason, message, memory, start_time) do
    duration_ms = System.monotonic_time(:millisecond) - start_time

    step = PtcRunner.Step.error(reason, message, memory)

    updated_step = %{step | usage: %{duration_ms: duration_ms, memory_bytes: 0}}

    {:error, updated_step}
  end

  # Update step with usage metrics
  defp update_step_usage(step, duration_ms) do
    usage = step.usage || %{memory_bytes: 0}
    %{step | usage: Map.put(usage, :duration_ms, duration_ms)}
  end
end
