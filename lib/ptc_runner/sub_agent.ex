defmodule PtcRunner.SubAgent do
  @moduledoc """
  SubAgent definition for PtcRunner.

  A SubAgent is an isolated worker that executes tasks using PTC-Lisp programs
  generated by an LLM. SubAgents are defined as structs via `new/1`, separating
  definition from execution.

  See the [SubAgent Specification](docs/ptc_agents/specification.md) for full details.

  ## Fields

  - `prompt` - String.t(), required, template with `{{placeholder}}` support
  - `signature` - String.t() | nil, optional, contract for inputs/outputs
  - `tools` - map(), callable tools (default: %{})
  - `max_turns` - pos_integer(), maximum LLM calls (default: 5)
  - `tool_catalog` - map() | nil, schemas for planning (not callable)
  - `prompt_limit` - map() | nil, truncation config for LLM view
  - `mission_timeout` - pos_integer() | nil, max ms for entire execution
  - `llm_retry` - map() | nil, infrastructure retry config
  - `llm` - atom() | function() | nil, optional LLM override
  - `system_prompt` - system_prompt_opts() | nil, system prompt customization

  ## Examples

  Minimal SubAgent with just a prompt:
      iex> {:ok, agent} = PtcRunner.SubAgent.new(prompt: "Analyze the data")
      iex> agent.prompt
      "Analyze the data"
      iex> agent.max_turns
      5
      iex> agent.tools
      %{}

  SubAgent with all options:
      iex> email_tools = %{"list_emails" => fn _args -> [] end}
      iex> {:ok, agent} = PtcRunner.SubAgent.new(
      ...>   prompt: "Find urgent emails for {{user}}",
      ...>   signature: "(user :string) -> {count :int, _ids [:int]}",
      ...>   tools: email_tools,
      ...>   max_turns: 10
      ...> )
      iex> agent.prompt
      "Find urgent emails for {{user}}"
      iex> agent.max_turns
      10

  Error when prompt is missing:
      iex> PtcRunner.SubAgent.new(tools: %{})
      {:error, :missing_required_field}

  Error when prompt is not a string:
      iex> PtcRunner.SubAgent.new(prompt: 123)
      {:error, {:invalid_type, :prompt, :string}}

  Error when max_turns is not positive:
      iex> PtcRunner.SubAgent.new(prompt: "Test", max_turns: 0)
      {:error, {:invalid_value, :max_turns, "must be positive integer"}}

  Error when tools is not a map:
      iex> PtcRunner.SubAgent.new(prompt: "Test", tools: [])
      {:error, {:invalid_type, :tools, :map}}
  """

  @type system_prompt_opts ::
          %{
            optional(:prefix) => String.t(),
            optional(:suffix) => String.t(),
            optional(:language_spec) => String.t(),
            optional(:output_format) => String.t()
          }
          | (String.t() -> String.t())
          | String.t()

  @type t :: %__MODULE__{
          prompt: String.t(),
          signature: String.t() | nil,
          tools: map(),
          max_turns: pos_integer(),
          tool_catalog: map() | nil,
          prompt_limit: map() | nil,
          mission_timeout: pos_integer() | nil,
          llm_retry: map() | nil,
          llm: atom() | (map() -> {:ok, String.t()} | {:error, term()}) | nil,
          system_prompt: system_prompt_opts() | nil
        }

  defstruct [
    :prompt,
    :signature,
    :tool_catalog,
    :prompt_limit,
    :mission_timeout,
    :llm_retry,
    :llm,
    :system_prompt,
    tools: %{},
    max_turns: 5
  ]

  @doc """
  Creates a SubAgent struct from keyword options.

  ## Parameters

  - `opts` - Keyword list of options

  ## Required Options

  - `prompt` - String template describing what to accomplish (supports `{{placeholder}}` expansion)

  ## Optional Options

  - `signature` - String contract defining expected inputs and outputs
  - `tools` - Map of callable tools (default: %{})
  - `max_turns` - Positive integer for maximum LLM calls (default: 5)
  - `tool_catalog` - Map of schemas for planning (not callable)
  - `prompt_limit` - Map with truncation config for LLM view
  - `mission_timeout` - Positive integer for max milliseconds for entire execution
  - `llm_retry` - Map with infrastructure retry config
  - `llm` - Atom or function for optional LLM override
  - `system_prompt` - System prompt customization (map, function, or string)

  ## Returns

  `{:ok, t()}` on success, `{:error, reason}` on validation failure.

  ## Examples

  Valid - minimal:
      iex> {:ok, agent} = PtcRunner.SubAgent.new(prompt: "Analyze the data")
      iex> agent.prompt
      "Analyze the data"

  Valid - with options:
      iex> email_tools = %{"list_emails" => fn _args -> [] end}
      iex> {:ok, agent} = PtcRunner.SubAgent.new(
      ...>   prompt: "Find urgent emails for {{user}}",
      ...>   signature: "(user :string) -> {count :int, _ids [:int]}",
      ...>   tools: email_tools,
      ...>   max_turns: 10
      ...> )
      iex> agent.max_turns
      10

  Invalid - missing prompt:
      iex> PtcRunner.SubAgent.new(tools: %{})
      {:error, :missing_required_field}

  Invalid - wrong type:
      iex> PtcRunner.SubAgent.new(prompt: 123)
      {:error, {:invalid_type, :prompt, :string}}
  """
  @spec new(keyword()) :: {:ok, t()} | {:error, term()}
  def new(opts) when is_list(opts) do
    with :ok <- validate_required_fields(opts),
         :ok <- validate_types(opts) do
      agent = struct(__MODULE__, opts)
      {:ok, agent}
    end
  end

  # Validate that required fields are present
  defp validate_required_fields(opts) do
    case Keyword.fetch(opts, :prompt) do
      {:ok, _} -> :ok
      :error -> {:error, :missing_required_field}
    end
  end

  # Validate types of provided fields
  defp validate_types(opts) do
    with :ok <- validate_prompt(opts),
         :ok <- validate_tools(opts) do
      validate_max_turns(opts)
    end
  end

  defp validate_prompt(opts) do
    case Keyword.fetch(opts, :prompt) do
      {:ok, prompt} when is_binary(prompt) -> :ok
      {:ok, _} -> {:error, {:invalid_type, :prompt, :string}}
      :error -> :ok
    end
  end

  defp validate_tools(opts) do
    case Keyword.fetch(opts, :tools) do
      {:ok, tools} when is_map(tools) -> :ok
      {:ok, _} -> {:error, {:invalid_type, :tools, :map}}
      :error -> :ok
    end
  end

  defp validate_max_turns(opts) do
    case Keyword.fetch(opts, :max_turns) do
      {:ok, max_turns} when is_integer(max_turns) and max_turns > 0 -> :ok
      {:ok, _} -> {:error, {:invalid_value, :max_turns, "must be positive integer"}}
      :error -> :ok
    end
  end
end
