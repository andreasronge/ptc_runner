defmodule PtcRunner.SubAgent do
  @moduledoc """
  SubAgent definition for PtcRunner.

  A SubAgent is an isolated worker that executes tasks using PTC-Lisp programs
  generated by an LLM. SubAgents are defined as structs via `new/1`, separating
  definition from execution.

  See the [SubAgent Specification](docs/ptc_agents/specification.md) for full details.

  ## Fields

  - `prompt` - String.t(), required, template with `{{placeholder}}` support
  - `signature` - String.t() | nil, optional, contract for inputs/outputs
  - `tools` - map(), callable tools (default: %{})
  - `max_turns` - pos_integer(), maximum LLM calls (default: 5)
  - `tool_catalog` - map() | nil, schemas for planning (not callable)
  - `prompt_limit` - map() | nil, truncation config for LLM view
  - `mission_timeout` - pos_integer() | nil, max ms for entire execution
  - `llm_retry` - map() | nil, infrastructure retry config
  - `llm` - atom() | function() | nil, optional LLM override
  - `system_prompt` - system_prompt_opts() | nil, system prompt customization

  ## Examples

  Minimal SubAgent with just a prompt:
      iex> agent = PtcRunner.SubAgent.new(prompt: "Analyze the data")
      iex> agent.prompt
      "Analyze the data"
      iex> agent.max_turns
      5
      iex> agent.tools
      %{}

  SubAgent with all options:
      iex> email_tools = %{"list_emails" => fn _args -> [] end}
      iex> agent = PtcRunner.SubAgent.new(
      ...>   prompt: "Find urgent emails for {{user}}",
      ...>   signature: "(user :string) -> {count :int, _ids [:int]}",
      ...>   tools: email_tools,
      ...>   max_turns: 10
      ...> )
      iex> agent.prompt
      "Find urgent emails for {{user}}"
      iex> agent.max_turns
      10
  """

  @type system_prompt_opts ::
          %{
            optional(:prefix) => String.t(),
            optional(:suffix) => String.t(),
            optional(:language_spec) => String.t(),
            optional(:output_format) => String.t()
          }
          | (String.t() -> String.t())
          | String.t()

  @type t :: %__MODULE__{
          prompt: String.t(),
          signature: String.t() | nil,
          tools: map(),
          max_turns: pos_integer(),
          tool_catalog: map() | nil,
          prompt_limit: map() | nil,
          mission_timeout: pos_integer() | nil,
          llm_retry: map() | nil,
          llm: atom() | (map() -> {:ok, String.t()} | {:error, term()}) | nil,
          system_prompt: system_prompt_opts() | nil
        }

  defstruct [
    :prompt,
    :signature,
    :tool_catalog,
    :prompt_limit,
    :mission_timeout,
    :llm_retry,
    :llm,
    :system_prompt,
    tools: %{},
    max_turns: 5
  ]

  @doc """
  Creates a SubAgent struct from keyword options.

  Raises `ArgumentError` if validation fails (missing required fields or invalid types).

  ## Parameters

  - `opts` - Keyword list of options

  ## Required Options

  - `prompt` - String template describing what to accomplish (supports `{{placeholder}}` expansion)

  ## Optional Options

  - `signature` - String contract defining expected inputs and outputs
  - `tools` - Map of callable tools (default: %{})
  - `max_turns` - Positive integer for maximum LLM calls (default: 5)
  - `tool_catalog` - Map of schemas for planning (not callable)
  - `prompt_limit` - Map with truncation config for LLM view
  - `mission_timeout` - Positive integer for max milliseconds for entire execution
  - `llm_retry` - Map with infrastructure retry config
  - `llm` - Atom or function for optional LLM override
  - `system_prompt` - System prompt customization (map, function, or string)

  ## Returns

  A `%SubAgent{}` struct.

  ## Raises

  - `ArgumentError` - if prompt is missing or not a string, max_turns is not positive, tools is not a map, any optional field has an invalid type, or prompt placeholders don't match signature parameters (when signature is provided)

  ## Examples

      iex> agent = PtcRunner.SubAgent.new(prompt: "Analyze the data")
      iex> agent.prompt
      "Analyze the data"

      iex> email_tools = %{"list_emails" => fn _args -> [] end}
      iex> agent = PtcRunner.SubAgent.new(
      ...>   prompt: "Find urgent emails for {{user}}",
      ...>   signature: "(user :string) -> {count :int, _ids [:int]}",
      ...>   tools: email_tools,
      ...>   max_turns: 10
      ...> )
      iex> agent.max_turns
      10
  """
  @spec new(keyword()) :: t()
  def new(opts) when is_list(opts) do
    validate_required_fields!(opts)
    validate_types!(opts)
    struct(__MODULE__, opts)
  end

  # Validate that required fields are present
  defp validate_required_fields!(opts) do
    case Keyword.fetch(opts, :prompt) do
      {:ok, _} -> :ok
      :error -> raise ArgumentError, "prompt is required"
    end
  end

  # Validate types of provided fields
  defp validate_types!(opts) do
    validate_prompt!(opts)
    validate_tools!(opts)
    validate_max_turns!(opts)
    validate_mission_timeout!(opts)
    validate_signature!(opts)
    validate_llm_retry!(opts)
    validate_tool_catalog!(opts)
    validate_prompt_limit!(opts)
    validate_prompt_placeholders!(opts)
  end

  defp validate_prompt!(opts) do
    case Keyword.fetch(opts, :prompt) do
      {:ok, prompt} when is_binary(prompt) -> :ok
      {:ok, _} -> raise ArgumentError, "prompt must be a string"
      :error -> :ok
    end
  end

  defp validate_tools!(opts) do
    case Keyword.fetch(opts, :tools) do
      {:ok, tools} when is_map(tools) -> :ok
      {:ok, _} -> raise ArgumentError, "tools must be a map"
      :error -> :ok
    end
  end

  defp validate_max_turns!(opts) do
    case Keyword.fetch(opts, :max_turns) do
      {:ok, max_turns} when is_integer(max_turns) and max_turns > 0 -> :ok
      {:ok, _} -> raise ArgumentError, "max_turns must be a positive integer"
      :error -> :ok
    end
  end

  defp validate_mission_timeout!(opts) do
    case Keyword.fetch(opts, :mission_timeout) do
      {:ok, timeout} when is_integer(timeout) and timeout > 0 -> :ok
      {:ok, _} -> raise ArgumentError, "mission_timeout must be a positive integer"
      :error -> :ok
    end
  end

  defp validate_signature!(opts) do
    case Keyword.fetch(opts, :signature) do
      {:ok, sig} when is_binary(sig) -> :ok
      {:ok, _} -> raise ArgumentError, "signature must be a string"
      :error -> :ok
    end
  end

  defp validate_llm_retry!(opts) do
    case Keyword.fetch(opts, :llm_retry) do
      {:ok, retry} when is_map(retry) -> :ok
      {:ok, _} -> raise ArgumentError, "llm_retry must be a map"
      :error -> :ok
    end
  end

  defp validate_tool_catalog!(opts) do
    case Keyword.fetch(opts, :tool_catalog) do
      {:ok, catalog} when is_map(catalog) -> :ok
      {:ok, _} -> raise ArgumentError, "tool_catalog must be a map"
      :error -> :ok
    end
  end

  defp validate_prompt_limit!(opts) do
    case Keyword.fetch(opts, :prompt_limit) do
      {:ok, limit} when is_map(limit) -> :ok
      {:ok, _} -> raise ArgumentError, "prompt_limit must be a map"
      :error -> :ok
    end
  end

  # Validate that prompt placeholders match signature parameters
  defp validate_prompt_placeholders!(opts) do
    with {:ok, prompt} <- Keyword.fetch(opts, :prompt),
         {:ok, signature} <- Keyword.fetch(opts, :signature) do
      placeholders = extract_placeholders(prompt)
      signature_params = extract_signature_params(signature)

      case placeholders -- signature_params do
        [] ->
          :ok

        missing ->
          formatted_missing = Enum.map_join(missing, ", ", &"{{#{&1}}}")

          raise ArgumentError,
                "placeholders #{formatted_missing} not found in signature"
      end
    else
      _ -> :ok
    end
  end

  # Extract placeholders from prompt template (e.g., "{{user}}" -> "user")
  defp extract_placeholders(prompt) do
    ~r/\{\{([^}]+)\}\}/
    |> Regex.scan(prompt, capture: :all_but_first)
    |> List.flatten()
    |> Enum.map(&String.trim/1)
    |> Enum.uniq()
  end

  # Extract parameter names from signature string
  defp extract_signature_params(signature) do
    alias PtcRunner.SubAgent.Signature.Parser

    case Parser.parse(signature) do
      {:ok, {:signature, params, _output}} ->
        Enum.map(params, fn {name, _type} -> name end)

      {:error, _reason} ->
        # If signature parsing fails, we can't validate placeholders
        # Let the signature validation fail elsewhere
        []
    end
  end
end
