defmodule PtcRunner.SubAgent do
  @moduledoc """
  SubAgent definition for PtcRunner.

  A SubAgent is an isolated worker that executes tasks using PTC-Lisp programs
  generated by an LLM. SubAgents are defined as structs via `new/1`, separating
  definition from execution.

  See the [SubAgent Specification](docs/ptc_agents/specification.md) for full details.

  ## Fields

  - `prompt` - String.t(), required, template with `{{placeholder}}` support
  - `signature` - String.t() | nil, optional, contract for inputs/outputs
  - `tools` - map(), callable tools (default: %{})
  - `max_turns` - pos_integer(), maximum LLM calls (default: 5)
  - `tool_catalog` - map() | nil, schemas for planning (not callable)
  - `prompt_limit` - map() | nil, truncation config for LLM view
  - `mission_timeout` - pos_integer() | nil, max ms for entire execution
  - `llm_retry` - map() | nil, infrastructure retry config
  - `llm` - atom() | function() | nil, optional LLM override
  - `system_prompt` - system_prompt_opts() | nil, system prompt customization
  - `memory_limit` - pos_integer() | nil, max bytes for memory map (default: 1MB)
  - `max_depth` - pos_integer(), max nesting depth for SubAgents (default: 3)
  - `turn_budget` - pos_integer(), total turns across all nested agents (default: 20)

  ## Examples

  Minimal SubAgent with just a prompt:
      iex> agent = PtcRunner.SubAgent.new(prompt: "Analyze the data")
      iex> agent.prompt
      "Analyze the data"
      iex> agent.max_turns
      5
      iex> agent.tools
      %{}

  SubAgent with all options:
      iex> email_tools = %{"list_emails" => fn _args -> [] end}
      iex> agent = PtcRunner.SubAgent.new(
      ...>   prompt: "Find urgent emails for {{user}}",
      ...>   signature: "(user :string) -> {count :int, _ids [:int]}",
      ...>   tools: email_tools,
      ...>   max_turns: 10
      ...> )
      iex> agent.prompt
      "Find urgent emails for {{user}}"
      iex> agent.max_turns
      10
  """

  @type system_prompt_opts ::
          %{
            optional(:prefix) => String.t(),
            optional(:suffix) => String.t(),
            optional(:language_spec) => String.t(),
            optional(:output_format) => String.t()
          }
          | (String.t() -> String.t())
          | String.t()

  @type llm_callback :: (map() -> {:ok, String.t()} | {:error, term()})

  @type llm_registry :: %{atom() => llm_callback()}

  @type t :: %__MODULE__{
          prompt: String.t(),
          signature: String.t() | nil,
          tools: map(),
          max_turns: pos_integer(),
          tool_catalog: map() | nil,
          prompt_limit: map() | nil,
          mission_timeout: pos_integer() | nil,
          llm_retry: map() | nil,
          llm: atom() | (map() -> {:ok, String.t()} | {:error, term()}) | nil,
          system_prompt: system_prompt_opts() | nil,
          memory_limit: pos_integer() | nil,
          max_depth: pos_integer(),
          turn_budget: pos_integer()
        }

  defstruct [
    :prompt,
    :signature,
    :tool_catalog,
    :prompt_limit,
    :mission_timeout,
    :llm_retry,
    :llm,
    :system_prompt,
    tools: %{},
    max_turns: 5,
    memory_limit: 1_048_576,
    max_depth: 3,
    turn_budget: 20
  ]

  @doc """
  Creates a SubAgent struct from keyword options.

  Raises `ArgumentError` if validation fails (missing required fields or invalid types).

  ## Parameters

  - `opts` - Keyword list of options

  ## Required Options

  - `prompt` - String template describing what to accomplish (supports `{{placeholder}}` expansion)

  ## Optional Options

  - `signature` - String contract defining expected inputs and outputs
  - `tools` - Map of callable tools (default: %{})
  - `max_turns` - Positive integer for maximum LLM calls (default: 5)
  - `tool_catalog` - Map of schemas for planning (not callable)
  - `prompt_limit` - Map with truncation config for LLM view
  - `mission_timeout` - Positive integer for max milliseconds for entire execution
  - `llm_retry` - Map with infrastructure retry config
  - `llm` - Atom or function for optional LLM override
  - `system_prompt` - System prompt customization (map, function, or string)
  - `memory_limit` - Positive integer for max bytes for memory map (default: 1MB = 1,048,576 bytes)

  ## Returns

  A `%SubAgent{}` struct.

  ## Raises

  - `ArgumentError` - if prompt is missing or not a string, max_turns is not positive, tools is not a map, any optional field has an invalid type, or prompt placeholders don't match signature parameters (when signature is provided)

  ## Examples

      iex> agent = PtcRunner.SubAgent.new(prompt: "Analyze the data")
      iex> agent.prompt
      "Analyze the data"

      iex> email_tools = %{"list_emails" => fn _args -> [] end}
      iex> agent = PtcRunner.SubAgent.new(
      ...>   prompt: "Find urgent emails for {{user}}",
      ...>   signature: "(user :string) -> {count :int, _ids [:int]}",
      ...>   tools: email_tools,
      ...>   max_turns: 10
      ...> )
      iex> agent.max_turns
      10
  """
  @spec new(keyword()) :: t()
  def new(opts) when is_list(opts) do
    validate_required_fields!(opts)
    validate_types!(opts)
    struct(__MODULE__, opts)
  end

  # Validate that required fields are present
  defp validate_required_fields!(opts) do
    case Keyword.fetch(opts, :prompt) do
      {:ok, _} -> :ok
      :error -> raise ArgumentError, "prompt is required"
    end
  end

  # Validate types of provided fields
  defp validate_types!(opts) do
    validate_prompt!(opts)
    validate_tools!(opts)
    validate_max_turns!(opts)
    validate_mission_timeout!(opts)
    validate_signature!(opts)
    validate_llm_retry!(opts)
    validate_tool_catalog!(opts)
    validate_prompt_limit!(opts)
    validate_memory_limit!(opts)
    validate_max_depth!(opts)
    validate_turn_budget!(opts)
    validate_prompt_placeholders!(opts)
  end

  defp validate_prompt!(opts) do
    case Keyword.fetch(opts, :prompt) do
      {:ok, prompt} when is_binary(prompt) -> :ok
      {:ok, _} -> raise ArgumentError, "prompt must be a string"
      :error -> :ok
    end
  end

  defp validate_tools!(opts) do
    case Keyword.fetch(opts, :tools) do
      {:ok, tools} when is_map(tools) -> :ok
      {:ok, _} -> raise ArgumentError, "tools must be a map"
      :error -> :ok
    end
  end

  defp validate_max_turns!(opts) do
    case Keyword.fetch(opts, :max_turns) do
      {:ok, max_turns} when is_integer(max_turns) and max_turns > 0 -> :ok
      {:ok, _} -> raise ArgumentError, "max_turns must be a positive integer"
      :error -> :ok
    end
  end

  defp validate_mission_timeout!(opts) do
    case Keyword.fetch(opts, :mission_timeout) do
      {:ok, timeout} when is_integer(timeout) and timeout > 0 -> :ok
      {:ok, nil} -> :ok
      {:ok, _} -> raise ArgumentError, "mission_timeout must be a positive integer or nil"
      :error -> :ok
    end
  end

  defp validate_signature!(opts) do
    case Keyword.fetch(opts, :signature) do
      {:ok, sig} when is_binary(sig) -> :ok
      {:ok, _} -> raise ArgumentError, "signature must be a string"
      :error -> :ok
    end
  end

  defp validate_llm_retry!(opts) do
    case Keyword.fetch(opts, :llm_retry) do
      {:ok, retry} when is_map(retry) -> :ok
      {:ok, _} -> raise ArgumentError, "llm_retry must be a map"
      :error -> :ok
    end
  end

  defp validate_tool_catalog!(opts) do
    case Keyword.fetch(opts, :tool_catalog) do
      {:ok, catalog} when is_map(catalog) -> :ok
      {:ok, _} -> raise ArgumentError, "tool_catalog must be a map"
      :error -> :ok
    end
  end

  defp validate_prompt_limit!(opts) do
    case Keyword.fetch(opts, :prompt_limit) do
      {:ok, limit} when is_map(limit) -> :ok
      {:ok, _} -> raise ArgumentError, "prompt_limit must be a map"
      :error -> :ok
    end
  end

  defp validate_memory_limit!(opts) do
    case Keyword.fetch(opts, :memory_limit) do
      {:ok, limit} when is_integer(limit) and limit > 0 -> :ok
      {:ok, nil} -> :ok
      {:ok, _} -> raise ArgumentError, "memory_limit must be a positive integer or nil"
      :error -> :ok
    end
  end

  defp validate_max_depth!(opts) do
    case Keyword.fetch(opts, :max_depth) do
      {:ok, depth} when is_integer(depth) and depth > 0 -> :ok
      {:ok, _} -> raise ArgumentError, "max_depth must be a positive integer"
      :error -> :ok
    end
  end

  defp validate_turn_budget!(opts) do
    case Keyword.fetch(opts, :turn_budget) do
      {:ok, budget} when is_integer(budget) and budget > 0 -> :ok
      {:ok, _} -> raise ArgumentError, "turn_budget must be a positive integer"
      :error -> :ok
    end
  end

  # Validate that prompt placeholders match signature parameters
  defp validate_prompt_placeholders!(opts) do
    alias PtcRunner.SubAgent.Template

    with {:ok, prompt} <- Keyword.fetch(opts, :prompt),
         {:ok, signature} <- Keyword.fetch(opts, :signature) do
      placeholders = Template.extract_placeholder_names(prompt)
      signature_params = Template.extract_signature_params(signature)

      case placeholders -- signature_params do
        [] ->
          :ok

        missing ->
          formatted_missing = Enum.map_join(missing, ", ", &"{{#{&1}}}")

          raise ArgumentError,
                "placeholders #{formatted_missing} not found in signature"
      end
    else
      _ -> :ok
    end
  end

  @doc """
  Executes a SubAgent with the given options.

  Returns a `Step` struct containing the result, metrics, and execution trace.

  ## Parameters

  - `agent` - A `%SubAgent{}` struct or a string prompt (for convenience)
  - `opts` - Keyword list of runtime options

  ## Runtime Options

  - `llm` - Required. LLM callback function `(map() -> {:ok, String.t()} | {:error, term()})` or atom
  - `llm_registry` - Map of atom to LLM callback for atom-based LLM references (default: %{})
  - `context` - Map of input data (default: %{})
  - `llm_retry` - Optional map to configure retry behavior for transient LLM failures:
    - `max_attempts` - Maximum retry attempts (default: 3)
    - `backoff` - Backoff strategy: `:exponential`, `:linear`, or `:constant` (default: `:exponential`)
    - `base_delay` - Base delay in milliseconds (default: 1000)
    - `retryable_errors` - List of error types to retry (default: `[:rate_limit, :timeout, :server_error]`)
  - Other options from agent definition can be overridden

  ## LLM Registry

  When using atom LLMs (like `:haiku` or `:sonnet`), provide an `llm_registry` map:

      registry = %{
        haiku: fn input -> MyApp.LLM.haiku(input) end,
        sonnet: fn input -> MyApp.LLM.sonnet(input) end
      }

      SubAgent.run(agent, llm: :sonnet, llm_registry: registry)

  The registry is automatically inherited by all child SubAgents, so you only need
  to provide it once at the top level.

  ## Returns

  - `{:ok, Step.t()}` on success
  - `{:error, Step.t()}` on failure

  ## Examples

      # Using a SubAgent struct
      iex> agent = PtcRunner.SubAgent.new(prompt: "Calculate {{x}} + {{y}}", max_turns: 1)
      iex> llm = fn %{messages: [%{content: _prompt}]} -> {:ok, "```clojure\\n(+ ctx/x ctx/y)\\n```"} end
      iex> {:ok, step} = PtcRunner.SubAgent.run(agent, llm: llm, context: %{x: 5, y: 3})
      iex> step.return
      8

      # Using string convenience form
      iex> llm = fn %{messages: [%{content: _prompt}]} -> {:ok, "```clojure\\n42\\n```"} end
      iex> {:ok, step} = PtcRunner.SubAgent.run("Return 42", max_turns: 1, llm: llm)
      iex> step.return
      42

      # Using atom LLM with registry
      iex> registry = %{test: fn %{messages: [%{content: _}]} -> {:ok, "```clojure\\n100\\n```"} end}
      iex> {:ok, step} = PtcRunner.SubAgent.run("Test", max_turns: 1, llm: :test, llm_registry: registry)
      iex> step.return
      100
  """
  @spec run(t() | String.t(), keyword()) ::
          {:ok, PtcRunner.Step.t()} | {:error, PtcRunner.Step.t()}
  def run(agent_or_prompt, opts \\ [])

  # String convenience form - creates agent inline
  def run(prompt, opts) when is_binary(prompt) do
    # Extract struct fields from opts
    struct_opts =
      opts
      |> Keyword.take([
        :signature,
        :tools,
        :max_turns,
        :tool_catalog,
        :prompt_limit,
        :mission_timeout,
        :llm_retry,
        :llm,
        :system_prompt
      ])
      |> Keyword.put(:prompt, prompt)

    agent = new(struct_opts)

    # Remove struct opts and pass runtime opts
    runtime_opts =
      Keyword.drop(opts, [
        :signature,
        :tools,
        :max_turns,
        :tool_catalog,
        :prompt_limit,
        :mission_timeout,
        :llm_retry,
        :system_prompt,
        :prompt
      ])

    run(agent, runtime_opts)
  end

  # Main implementation with SubAgent struct
  def run(%__MODULE__{} = agent, opts) do
    start_time = System.monotonic_time(:millisecond)

    # Validate required llm option
    llm = Keyword.get(opts, :llm) || agent.llm

    # Validate llm_registry if provided
    llm_registry = Keyword.get(opts, :llm_registry, %{})

    with :ok <- validate_llm_presence(llm, start_time),
         :ok <- validate_llm_registry(llm_registry, start_time) do
      # Get and prepare context (handles Step auto-chaining)
      raw_context = Keyword.get(opts, :context, %{})

      case prepare_context(raw_context) do
        {:chained_failure, upstream_fail} ->
          # Short-circuit: upstream agent failed
          duration_ms = System.monotonic_time(:millisecond) - start_time

          step =
            PtcRunner.Step.error(
              :chained_failure,
              "Upstream agent failed: #{upstream_fail.reason}",
              %{},
              %{upstream: upstream_fail}
            )

          updated_step = %{step | usage: %{duration_ms: duration_ms, memory_bytes: 0}}
          {:error, updated_step}

        context ->
          # Determine execution mode
          if agent.max_turns == 1 and map_size(agent.tools) == 0 do
            # Single-shot mode
            run_single_shot(agent, llm, context, start_time, llm_registry)
          else
            # Loop mode - delegate to Loop.run/2
            # Update opts with prepared context
            updated_opts = Keyword.put(opts, :context, context)
            alias PtcRunner.SubAgent.Loop
            Loop.run(agent, updated_opts)
          end
      end
    else
      error -> error
    end
  end

  @doc """
  Bang variant of `run/2` that raises on failure.

  Returns the `Step` struct directly instead of `{:ok, step}`. Raises
  `SubAgentError` if execution fails.

  ## Examples

      iex> agent = PtcRunner.SubAgent.new(prompt: "Say hello", max_turns: 1)
      iex> mock_llm = fn _ -> {:ok, "```clojure\\n\\\"Hello!\\\"\\n```"} end
      iex> step = PtcRunner.SubAgent.run!(agent, llm: mock_llm)
      iex> step.return
      "Hello!"

      # Failure case (using loop mode)
      iex> agent = PtcRunner.SubAgent.new(prompt: "Fail", max_turns: 2)
      iex> mock_llm = fn _ -> {:ok, ~S|(call "fail" {:reason :test :message "Error"})|} end
      iex> PtcRunner.SubAgent.run!(agent, llm: mock_llm)
      ** (PtcRunner.SubAgentError) SubAgent failed: failed - %{message: "Error", reason: :test}

  """
  @spec run!(t() | String.t(), keyword()) :: PtcRunner.Step.t()
  def run!(agent, opts \\ []) do
    case run(agent, opts) do
      {:ok, step} -> step
      {:error, step} -> raise PtcRunner.SubAgentError, %{step: step}
    end
  end

  @doc """
  Chains agents in a pipeline, passing the previous step as context.

  Equivalent to `run!(agent, Keyword.put(opts, :context, step))`. Enables
  pipeline-style composition where each agent receives the previous agent's
  `return` value as input.

  ## Examples

      iex> doubler = PtcRunner.SubAgent.new(
      ...>   prompt: "Double {{n}}",
      ...>   signature: "(n :int) -> {result :int}",
      ...>   max_turns: 1
      ...> )
      iex> adder = PtcRunner.SubAgent.new(
      ...>   prompt: "Add 10 to {{result}}",
      ...>   signature: "(result :int) -> {final :int}",
      ...>   max_turns: 1
      ...> )
      iex> mock_llm = fn %{messages: msgs} ->
      ...>   content = msgs |> List.last() |> Map.get(:content)
      ...>   cond do
      ...>     content =~ "Double" -> {:ok, "```clojure\\n{:result (* 2 ctx/n)}\\n```"}
      ...>     content =~ "Add 10" -> {:ok, "```clojure\\n{:final (+ ctx/result 10)}\\n```"}
      ...>   end
      ...> end
      iex> result = PtcRunner.SubAgent.run!(doubler, llm: mock_llm, context: %{n: 5})
      ...> |> PtcRunner.SubAgent.then!(adder, llm: mock_llm)
      iex> result.return.final
      20

  """
  @spec then!(PtcRunner.Step.t(), t() | String.t(), keyword()) :: PtcRunner.Step.t()
  def then!(step, agent, opts \\ []) do
    run!(agent, Keyword.put(opts, :context, step))
  end

  defp validate_llm_presence(nil, start_time) do
    return_error(:llm_required, "llm option is required", %{}, start_time)
  end

  defp validate_llm_presence(_llm, _start_time), do: :ok

  defp validate_llm_registry(registry, start_time) when is_map(registry) do
    # Check that all registry values are function/1
    invalid_entries =
      Enum.reject(registry, fn {_key, value} -> is_function(value, 1) end)

    if invalid_entries == [] do
      :ok
    else
      {key, _value} = hd(invalid_entries)

      return_error(
        :invalid_llm_registry,
        "llm_registry values must be function/1. Invalid entry: #{inspect(key)}",
        %{},
        start_time
      )
    end
  end

  defp validate_llm_registry(_registry, start_time) do
    return_error(:invalid_llm_registry, "llm_registry must be a map", %{}, start_time)
  end

  # Prepares context for execution, handling Step auto-chaining
  defp prepare_context(%PtcRunner.Step{fail: fail} = _step) when fail != nil do
    {:chained_failure, fail}
  end

  defp prepare_context(%PtcRunner.Step{fail: nil, return: return} = _step) when is_map(return) do
    return
  end

  defp prepare_context(%PtcRunner.Step{fail: nil, return: nil} = _step) do
    %{}
  end

  defp prepare_context(%PtcRunner.Step{fail: nil} = _step) do
    # Non-map return value - can't use as context directly
    # This will be caught by template expansion or signature validation
    %{}
  end

  defp prepare_context(context) when is_map(context), do: context
  defp prepare_context(nil), do: %{}

  # Single-shot execution: one LLM call, no tools, expression result returned
  defp run_single_shot(agent, llm, context, start_time, llm_registry) do
    # Expand template in prompt
    expanded_prompt = expand_template(agent.prompt, context)

    # Build LLM input
    llm_input = %{
      system: default_system_prompt(),
      messages: [%{role: :user, content: expanded_prompt}]
    }

    # Call LLM
    alias PtcRunner.SubAgent.LLMResolver

    case LLMResolver.resolve(llm, llm_input, llm_registry) do
      {:ok, response} ->
        # Extract code from response
        case extract_code(response) do
          {:ok, code} ->
            # Execute via Lisp
            lisp_result = PtcRunner.Lisp.run(code, context: context, tools: %{})

            # Add usage metrics from this execution
            case lisp_result do
              {:ok, step} ->
                duration_ms = System.monotonic_time(:millisecond) - start_time
                updated_step = update_step_usage(step, duration_ms)
                {:ok, updated_step}

              {:error, step} ->
                duration_ms = System.monotonic_time(:millisecond) - start_time
                updated_step = update_step_usage(step, duration_ms)
                {:error, updated_step}
            end

          :none ->
            return_error(
              :no_code_found,
              "No PTC-Lisp code found in LLM response",
              %{},
              start_time
            )
        end

      {:error, reason} ->
        return_error(:llm_error, "LLM call failed: #{inspect(reason)}", %{}, start_time)
    end
  end

  # Expand template placeholders with context values
  defp expand_template(prompt, context) when is_map(context) do
    alias PtcRunner.SubAgent.Template
    {:ok, result} = Template.expand(prompt, context, on_missing: :keep)
    result
  end

  # Extract PTC-Lisp code from LLM response
  defp extract_code(text) do
    # Try extracting from markdown code block (lisp, clojure, or unmarked)
    case Regex.run(~r/```(?:lisp|clojure)?\s*([\s\S]+?)\s*```/, text) do
      [_, content] ->
        {:ok, String.trim(content)}

      nil ->
        # Try finding a bare S-expression (starts with paren)
        # Match expressions like (+ 40 2) or more complex ones
        trimmed = String.trim(text)

        if String.starts_with?(trimmed, "(") do
          {:ok, trimmed}
        else
          :none
        end
    end
  end

  # Minimal system prompt for single-shot mode
  defp default_system_prompt do
    """
    You are an AI that solves tasks by writing PTC-Lisp programs.
    Output your program in a ```clojure code block.
    """
  end

  # Helper to create error Step
  defp return_error(reason, message, memory, start_time) do
    duration_ms = System.monotonic_time(:millisecond) - start_time

    step = PtcRunner.Step.error(reason, message, memory)

    updated_step = %{step | usage: %{duration_ms: duration_ms, memory_bytes: 0}}

    {:error, updated_step}
  end

  # Update step with usage metrics
  defp update_step_usage(step, duration_ms) do
    usage = step.usage || %{memory_bytes: 0}
    %{step | usage: Map.put(usage, :duration_ms, duration_ms)}
  end

  @doc """
  Wraps a SubAgent as a tool callable by other agents.

  Returns a `SubAgentTool` struct that parent agents can include
  in their tools map. When called, the wrapped agent inherits
  LLM and registry from the parent unless overridden.

  ## Options

  - `:llm` - Bind specific LLM (atom or function). Overrides parent inheritance.
  - `:description` - Override auto-derived description from agent's prompt
  - `:name` - Suggested tool name (informational, not enforced by the struct)

  ## LLM Resolution

  When the tool is called, the LLM is resolved in priority order:
  1. `agent.llm` - The agent's own LLM override (highest priority)
  2. `bound_llm` - LLM bound via the `:llm` option
  3. Parent's llm - Inherited from the calling agent (lowest priority)

  ## Examples

      iex> child = PtcRunner.SubAgent.new(
      ...>   prompt: "Double {{n}}",
      ...>   signature: "(n :int) -> {result :int}"
      ...> )
      iex> tool = PtcRunner.SubAgent.as_tool(child)
      iex> tool.signature
      "(n :int) -> {result :int}"
      iex> tool.bound_llm
      nil

      iex> child = PtcRunner.SubAgent.new(prompt: "Process data")
      iex> tool = PtcRunner.SubAgent.as_tool(child, llm: :haiku, description: "Processes data")
      iex> tool.bound_llm
      :haiku
      iex> tool.description
      "Processes data"

      iex> child = PtcRunner.SubAgent.new(prompt: "Analyze {{text}}", signature: "(text :string) -> :string")
      iex> tool = PtcRunner.SubAgent.as_tool(child, name: "analyzer")
      iex> tool.signature
      "(text :string) -> :string"

  """
  @spec as_tool(t(), keyword()) :: PtcRunner.SubAgent.SubAgentTool.t()
  def as_tool(%__MODULE__{} = agent, opts \\ []) do
    alias PtcRunner.SubAgent.SubAgentTool

    %SubAgentTool{
      agent: agent,
      bound_llm: Keyword.get(opts, :llm),
      signature: agent.signature,
      description: Keyword.get(opts, :description)
    }
  end

  @doc "See `PtcRunner.SubAgent.Compiler.compile/2`."
  defdelegate compile(agent, opts), to: PtcRunner.SubAgent.Compiler

  @doc """
  Preview the system and user prompts that would be sent to the LLM.

  This function generates and returns the prompts without executing the agent,
  useful for debugging prompt generation, verifying template expansion, and
  reviewing what the LLM will see.

  ## Parameters

  - `agent` - A `%SubAgent{}` struct
  - `opts` - Keyword list with:
    - `context` - Context map for template expansion (default: %{})

  ## Returns

  A map with:
  - `:system` - The complete system prompt string
  - `:user` - The expanded user message (mission prompt)
  - `:tool_schemas` - List of tool schema maps with name, signature, and description fields

  ## Examples

      iex> agent = PtcRunner.SubAgent.new(
      ...>   prompt: "Find emails for {{user}}",
      ...>   signature: "(user :string) -> {count :int}",
      ...>   tools: %{"list_emails" => fn _ -> [] end}
      ...> )
      iex> preview = PtcRunner.SubAgent.preview_prompt(agent, context: %{user: "alice"})
      iex> preview.user
      "Find emails for alice"
      iex> preview.system =~ "PTC-Lisp"
      true
      iex> is_binary(preview.system)
      true

  """
  @spec preview_prompt(t(), keyword()) :: %{
          system: String.t(),
          user: String.t(),
          tool_schemas: [map()]
        }
  def preview_prompt(%__MODULE__{} = agent, opts \\ []) do
    context = Keyword.get(opts, :context, %{})

    # Generate system prompt using existing Prompt module
    alias PtcRunner.SubAgent.{Prompt, Template}
    system_prompt = Prompt.generate(agent, context: context)

    # Expand user message template
    {:ok, user_message} = Template.expand(agent.prompt, context, on_missing: :keep)

    # Tool schemas - extract from agent.tools
    tool_schemas =
      agent.tools
      |> Enum.map(fn {name, format} ->
        case PtcRunner.Tool.new(name, format) do
          {:ok, tool} ->
            schema = %{name: tool.name}

            schema =
              if tool.signature, do: Map.put(schema, :signature, tool.signature), else: schema

            schema =
              if tool.description,
                do: Map.put(schema, :description, tool.description),
                else: schema

            schema

          {:error, _} ->
            # Fallback for tools that fail normalization
            %{name: name}
        end
      end)

    %{
      system: system_prompt,
      user: user_message,
      tool_schemas: tool_schemas
    }
  end
end
