name: Claude Blocker Resolved

on:
  issues:
    types: [closed]

jobs:
  unblock-dependents:
    # When an issue closes, check if it was blocking other issues
    # Skip if it's an epic issue - epic-update.yml handles those with phase-aware ordering
    if: "!contains(toJSON(github.event.issue.labels), 'epic:')"

    runs-on: ubuntu-latest

    permissions:
      issues: write

    steps:
      - name: Find and unblock dependent issues
        env:
          # Use PAT so that adding needs-review label triggers issue-review workflow
          GH_TOKEN: ${{ secrets.PAT_WORKFLOW_TRIGGER || github.token }}
          CLOSED_ISSUE: ${{ github.event.issue.number }}
        run: |
          echo "Issue #$CLOSED_ISSUE closed, checking for dependent issues..."

          # Search for open issues that reference this one in "Blocked by:" section
          # GitHub search doesn't support exact body matching, so we search and filter
          POTENTIAL_DEPENDENTS=$(gh issue list \
            --repo "${{ github.repository }}" \
            --state open \
            --json number,body \
            --limit 100)

          # Process each issue to check if it's blocked by the closed issue
          echo "$POTENTIAL_DEPENDENTS" | jq -c '.[]' | while read -r issue; do
            ISSUE_NUMBER=$(echo "$issue" | jq -r '.number')
            ISSUE_BODY=$(echo "$issue" | jq -r '.body')

            # Check if this issue has a "Blocked by:" section referencing our closed issue
            if echo "$ISSUE_BODY" | grep -iE "blocked by:.*#$CLOSED_ISSUE|blocked by:.*#$CLOSED_ISSUE" > /dev/null; then
              echo "Found dependent issue: #$ISSUE_NUMBER"

              # Check if ALL blockers are now resolved
              # Handles both inline (Blocked by: #1, #2) and multiline (Blocked by:\n- #1\n- #2)
              ALL_RESOLVED=true
              BLOCKED_SECTION=$(echo "$ISSUE_BODY" | sed -n '/[Bb]locked [Bb]y:/,/\*\*[Bb]locks\|^##\|^$/p' | grep -v "^\*\*[Bb]locks" | head -10 || true)
              BLOCKERS=$(echo "$BLOCKED_SECTION" | grep -oE '#[0-9]+' | tr -d '#' | sort -u || true)

              for BLOCKER_NUM in $BLOCKERS; do
                # Skip self-references (issue blocking itself is invalid)
                if [ "$BLOCKER_NUM" = "$ISSUE_NUMBER" ]; then
                  echo "  WARNING: Issue #$ISSUE_NUMBER references itself as blocker - ignoring"
                  continue
                fi

                BLOCKER_STATE=$(gh issue view "$BLOCKER_NUM" --repo "${{ github.repository }}" --json state --jq '.state' 2>/dev/null || echo "UNKNOWN")
                if [ "$BLOCKER_STATE" != "CLOSED" ]; then
                  echo "  Still blocked by #$BLOCKER_NUM ($BLOCKER_STATE)"
                  ALL_RESOLVED=false
                  break
                fi
              done

              if [ "$ALL_RESOLVED" = "true" ]; then
                echo "All blockers resolved for #$ISSUE_NUMBER - re-enabling"

                # Check if it had ready-for-implementation before (was waiting)
                LABELS=$(gh issue view "$ISSUE_NUMBER" --repo "${{ github.repository }}" --json labels --jq '.labels[].name')

                # Only re-add if it doesn't already have needs-review or ready-for-implementation
                # and doesn't have needs-clarification, needs-breakdown, or quick-fix
                if echo "$LABELS" | grep -qE "needs-review|ready-for-implementation"; then
                  echo "  Already has needs-review or ready-for-implementation label"
                elif echo "$LABELS" | grep -qE "needs-clarification|needs-breakdown"; then
                  echo "  Issue needs clarification/breakdown, not re-enabling"
                elif echo "$LABELS" | grep -q "quick-fix"; then
                  echo "  Issue is quick-fix, handled by batch-fix workflow"
                else
                  # Add needs-review to trigger just-in-time review before implementation
                  gh issue edit "$ISSUE_NUMBER" --repo "${{ github.repository }}" --add-label "needs-review"

                  gh issue comment "$ISSUE_NUMBER" --repo "${{ github.repository }}" --body "$(cat <<EOF
          ## Blockers Resolved

          Issue #$CLOSED_ISSUE has been closed, and all blocking issues are now resolved.

          Adding \`needs-review\` label to trigger review before implementation.
          EOF
          )"
                  echo "  Added needs-review to #$ISSUE_NUMBER"
                fi
              fi
            fi
          done

          # Second pass: find any orphaned unblocked epic issues
          # This catches issues with no blockers that weren't triggered by epic-start
          echo "Checking for orphaned unblocked epic issues..."

          ORPHAN_TRIGGERED=""

          # Get all open issues with epic:* labels, sorted by number
          EPIC_ISSUES=$(gh issue list \
            --repo "${{ github.repository }}" \
            --state open \
            --label "epic:" \
            --json number,body,labels \
            --limit 100 \
            | jq -c 'sort_by(.number) | .[]' 2>/dev/null || echo "")

          # If no epic issues found with label filter, try searching all issues
          if [ -z "$EPIC_ISSUES" ]; then
            EPIC_ISSUES=$(echo "$POTENTIAL_DEPENDENTS" | jq -c '.[]')
          fi

          for issue in $EPIC_ISSUES; do
            [ -n "$ORPHAN_TRIGGERED" ] && break  # Only trigger one

            ISSUE_NUMBER=$(echo "$issue" | jq -r '.number')
            ISSUE_BODY=$(echo "$issue" | jq -r '.body')

            # Must have epic:* label
            HAS_EPIC=$(gh issue view "$ISSUE_NUMBER" --repo "${{ github.repository }}" --json labels --jq '[.labels[].name | select(startswith("epic:"))] | length' 2>/dev/null || echo "0")
            [ "$HAS_EPIC" -eq 0 ] && continue

            # Skip if already has workflow labels
            LABELS=$(gh issue view "$ISSUE_NUMBER" --repo "${{ github.repository }}" --json labels --jq '.labels[].name' 2>/dev/null || echo "")
            if echo "$LABELS" | grep -qE "needs-review|ready-for-implementation"; then
              continue
            fi

            # Skip if has blocking labels
            if echo "$LABELS" | grep -qE "needs-clarification|needs-breakdown|quick-fix"; then
              continue
            fi

            # Check if ALL blockers are closed (or no blockers)
            ALL_RESOLVED=true
            if echo "$ISSUE_BODY" | grep -qi "blocked by:"; then
              BLOCKED_SECTION=$(echo "$ISSUE_BODY" | sed -n '/[Bb]locked [Bb]y:/,/\*\*[Bb]locks\|^##\|^$/p' | head -10 || true)
              BLOCKERS=$(echo "$BLOCKED_SECTION" | grep -oE '#[0-9]+' | tr -d '#' | sort -u || true)
              for b in $BLOCKERS; do
                [ -z "$b" ] && continue
                # Skip self-references
                [ "$b" = "$ISSUE_NUMBER" ] && continue
                STATE=$(gh issue view "$b" --repo "${{ github.repository }}" --json state --jq '.state' 2>/dev/null || echo "OPEN")
                if [ "$STATE" != "CLOSED" ]; then
                  ALL_RESOLVED=false
                  break
                fi
              done
            fi

            if [ "$ALL_RESOLVED" = "true" ]; then
              echo "Found orphaned unblocked epic issue: #$ISSUE_NUMBER"
              gh issue edit "$ISSUE_NUMBER" --repo "${{ github.repository }}" --add-label "needs-review"

              gh issue comment "$ISSUE_NUMBER" --repo "${{ github.repository }}" --body "$(cat <<EOF
          ## Unblocked Issue Found

          Issue #$CLOSED_ISSUE closed. This issue has no open blockers and is ready for review.

          Adding \`needs-review\` label to trigger review before implementation.
          EOF
          )"
              echo "  Added needs-review to orphaned issue #$ISSUE_NUMBER"
              ORPHAN_TRIGGERED="$ISSUE_NUMBER"
              break  # Only one at a time
            fi
          done

          if [ -n "$ORPHAN_TRIGGERED" ]; then
            echo "Triggered orphaned issue #$ORPHAN_TRIGGERED"
          else
            echo "No orphaned unblocked issues found"
          fi

          echo "Blocker resolution check complete"
